<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ğŸ’openswanä¸“æ ç›®å½•ğŸ’</title>
    <url>/blogs/2021/11/20/openswan%E4%B8%93%E6%A0%8F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><font color="#0000bb">ä¸ºäº†æ–¹ä¾¿æŸ¥é˜…ç°æœ‰çš„æ–‡ç« ï¼Œç‰¹å‡†å¤‡ä¸€ä¸ªç›®å½•é¡µä¾›åç»­æŸ¥è¯¢ä½¿ç”¨</font></p>
<span id="more"></span>

<img src="https://img-blog.csdnimg.cn/20201122205357123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MyNjAzODk4MjYw,size_16,color_FFFFFF,t_70#pic_center"  />


<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105780700">ä¸“æ åºè¨€</a></li>
</ul>
<h3 id="1-åŸºç¡€çŸ¥è¯†"><a href="#1-åŸºç¡€çŸ¥è¯†" class="headerlink" title="1. åŸºç¡€çŸ¥è¯†"></a>1. åŸºç¡€çŸ¥è¯†</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105810406">openswanä»»åŠ¡è°ƒåº¦åŸºç¡€çŸ¥è¯†ä¹‹ä¿¡å·</a><h3 id="2-openswanç¯å¢ƒæ­å»º"><a href="#2-openswanç¯å¢ƒæ­å»º" class="headerlink" title="2. openswanç¯å¢ƒæ­å»º"></a>2. openswanç¯å¢ƒæ­å»º</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112975141">openswanæ¡†æ¶å’Œç¼–è¯‘æ—¶è¯´æ˜</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105855454">openswanç¼–è¯‘å®‰è£…</a><h3 id="3-NATç©¿è¶Š"><a href="#3-NATç©¿è¶Š" class="headerlink" title="3. NATç©¿è¶Š"></a>3. NATç©¿è¶Š</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105214411">NAT-Tä¸‹çš„ç«¯å£æµ®åŠ¨</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105212626">NAT-TåŸç†å’Œç¯å¢ƒæ­å»º</a><h3 id="4-openswanå‡½æ•°ç¬”è®°"><a href="#4-openswanå‡½æ•°ç¬”è®°" class="headerlink" title="4. openswanå‡½æ•°ç¬”è®°"></a>4. openswanå‡½æ•°ç¬”è®°</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106172947">in_structå’Œout_structè®²è§£</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106131750">openswanå‘é€çŠ¶æ€åˆ†æ</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107913541">plutoä¸­ç›‘å¬å„ä¸ªç½‘å£çš„500ç«¯å£å¤„ç†é€»è¾‘</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="">plutoä¸­CPUå æœ‰ç‡é«˜çš„æ¥å£ä¸ä¼˜åŒ–æ–¹æ¡ˆ</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106578067">Openswanæ”¯æŒçš„ç®—æ³•åŠå‚æ•°ä¿¡æ¯</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113447879">å‘½ä»¤è¡Œè§£æå‡½æ•°ï¼šgetopt_longã€getopt</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113445039">ipsec.confé…ç½®æ–‡ä»¶å¤šä¸ªä¿æŠ¤å­ç½‘è§£ææµç¨‹</a> </li>
</ul>
<h3 id="5-IKEv1åå•†æµç¨‹"><a href="#5-IKEv1åå•†æµç¨‹" class="headerlink" title="5. IKEv1åå•†æµç¨‹"></a>5. IKEv1åå•†æµç¨‹</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226299">openswanåå•†æµç¨‹ä¹‹ï¼ˆä¸€ï¼‰ï¼šmain_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226416">openswanåå•†æµç¨‹ä¹‹ï¼ˆäºŒï¼‰ï¼šmain_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106247599">openswanåå•†æµç¨‹ä¹‹ï¼ˆä¸‰ï¼‰ï¼šmain_inR1_outI2()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106271199">openswanåå•†æµç¨‹ä¹‹ï¼ˆå››ï¼‰ï¼šmain_inI2_outR2()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106310714">openswanåå•†æµç¨‹ä¹‹ï¼ˆäº”ï¼‰ï¼šmain_inR2_outI3()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106580396">openswanåå•†æµç¨‹ä¹‹ï¼ˆå…­ï¼‰ï¼šmain_inI3_outR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106592883">openswanåå•†æµç¨‹ä¹‹ï¼ˆä¸ƒï¼‰ï¼šmain_inR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108252077">openswanå¿«é€Ÿæ¨¡å¼åå•†æµç¨‹ä¹‹ï¼ˆä¸€ï¼‰ï¼šquick_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108459144">openswanå¿«é€Ÿæ¨¡å¼åå•†æµç¨‹ä¹‹ï¼ˆäºŒï¼‰ï¼šquick_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108560293">openswanå¿«é€Ÿæ¨¡å¼åå•†æµç¨‹ä¹‹ï¼ˆä¸‰ï¼‰ï¼šquick_inR1_outI2()</a></li>
</ul>
<hr>
<h3 id="6-IKEv2åè®®ç›¸å…³"><a href="#6-IKEv2åè®®ç›¸å…³" class="headerlink" title="6. IKEv2åè®®ç›¸å…³"></a>6. IKEv2åè®®ç›¸å…³</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106915035">IKEv2åè®®ç®€ä»‹</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107117675">IKEv2åè®®å…³é”®çŸ¥è¯†ç‚¹æ€»ç»“æ•´ç†</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109019539">IKEv2åè®®åå•†æµç¨‹: ï¼ˆIKE-SA-INIT äº¤æ¢ï¼‰ç¬¬ä¸€åŒ…</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109062848">IKEv2åè®®åå•†æµç¨‹: ï¼ˆIKE-SA-INIT äº¤æ¢ï¼‰ç¬¬äºŒåŒ…</a></li>
</ul>
<h3 id="7-åŠ å¯†æµç¨‹"><a href="#7-åŠ å¯†æµç¨‹" class="headerlink" title="7. åŠ å¯†æµç¨‹"></a>7. åŠ å¯†æµç¨‹</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109929113">ipsec åŠ å¯†æµç¨‹ï¼ˆä¸€ï¼‰ï¼šipsecç­–ç•¥åŒ¹é…</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109943878">ipsec åŠ å¯†æµç¨‹ï¼ˆäºŒï¼‰ï¼šipsecåˆå§‹åŒ–æ“ä½œ</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110018251">ipsec åŠ å¯†æµç¨‹ï¼ˆä¸‰ï¼‰ï¼šESPåŠ å¯†ã€AHè®¤è¯å¤„ç†æµç¨‹</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110410067">ipsec åŠ å¯†æµç¨‹ï¼ˆå››ï¼‰ï¼šå°è£…çŠ¶æ€æœºå’Œå‘é€æµç¨‹</a></li>
</ul>
<h3 id="8-ğŸ’–openswanè¿›é˜¶ğŸ’–"><a href="#8-ğŸ’–openswanè¿›é˜¶ğŸ’–" class="headerlink" title="8. ğŸ’–openswanè¿›é˜¶ğŸ’–"></a>8. ğŸ’–openswanè¿›é˜¶ğŸ’–</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113043610">ubantuä¸CentOSè™šæ‹Ÿæœºä¹‹é—´æ­å»ºGREéš§é“</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113008094">ğŸ”¥openswanä¸€æ¡éš§é“å¤šä¿æŠ¤å­ç½‘é…ç½®</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://mp.csdn.net/mp_blog/creation/editor/113075156">ğŸ”¥ä¸ºä½•GREå¯ä»¥å°è£…ç»„æ’­æŠ¥æ–‡è€ŒIPSECå´ä¸è¡Œï¼Ÿ</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/120593578">ğŸ”¥SSL/TLS ä¸ IPSec å¯¹æ¯”</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113575857">ğŸ”¥IKE å¤šé¢„å…±äº«å¯†é’¥é—®é¢˜ è§£å†³æ–¹æ¡ˆ</a><h3 id="9-å›¾è§£å¯†ç å­¦æŠ€æœ¯"><a href="#9-å›¾è§£å¯†ç å­¦æŠ€æœ¯" class="headerlink" title="9. å›¾è§£å¯†ç å­¦æŠ€æœ¯"></a>9. å›¾è§£å¯†ç å­¦æŠ€æœ¯</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112341844">DHç®—æ³•å›¾è§£+æ•°å­¦è¯æ˜</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112503905">openswanä¸­DHç®—æ³•è¯´æ˜</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112744384">å›¾è§£å¯†ç å­¦(ä¸€)</a></li>
</ul>
<h3 id="10-Linuxå†…æ ¸IPSECå®ç°"><a href="#10-Linuxå†…æ ¸IPSECå®ç°" class="headerlink" title="10. Linuxå†…æ ¸IPSECå®ç°"></a>10. Linuxå†…æ ¸IPSECå®ç°</h3>]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>IPSECçš„å®ç°æ–¹å¼</title>
    <url>/blogs/2021/11/20/IPSEC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>åœ¨IPSECé€šä¿¡ä¸­æ¶‰åŠåˆ°ä¸€ä¸ªé‡è¦æ–¹é¢ï¼Œé‚£å°±æ˜¯å¦‚ä½•å®šä¹‰è¦ä¿æŠ¤çš„æ•°æ®æµï¼ˆåˆç§°ä¸ºæ„Ÿå…´è¶£æµï¼‰ã€‚è¿™ä¸ä»…æ¶‰åŠåˆ°IPSECæœ€ç»ˆè¦ä¿æŠ¤å“ªéƒ¨åˆ†æ•°æ®ï¼Œè¿˜å…³ç³»åˆ°IPSECçš„å®ç°æ–¹å¼ï¼Œå› æ­¤æœ‰å¿…è¦æŠŠæ„Ÿå…´è¶£æµçš„å®šä¹‰æ–¹å¼è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚</p>
<span id="more"></span>

<h3 id="1-æ„Ÿå…´è¶£æµçš„å®šä¹‰æ–¹å¼"><a href="#1-æ„Ÿå…´è¶£æµçš„å®šä¹‰æ–¹å¼" class="headerlink" title="1. æ„Ÿå…´è¶£æµçš„å®šä¹‰æ–¹å¼"></a>1. æ„Ÿå…´è¶£æµçš„å®šä¹‰æ–¹å¼</h3><p>â€œæ„Ÿå…´è¶£æµâ€æŒ‡çš„æ˜¯å“ªäº›æ•°æ®å¯ä»¥è¿›å…¥IPsecéš§é“è¿›è¡Œä¼ è¾“ï¼Œå“ªäº›æ•°æ®ä¸èƒ½è¿›å…¥IPsecéš§é“ä¼ è¾“ã€‚åœ¨ç°æœ‰çš„IPsec å®ç°è¿‡ç¨‹ä¸­ï¼Œæœ€å¸¸ç”¨çš„å®ç°æ–¹å¼æœ‰ä¸¤ç§ï¼š<strong>â€œåŸºäºACLâ€</strong>ã€<strong>â€œåŸºäºè™šæ‹Ÿéš§é“æ¥å£â€</strong>ã€‚ä¸‹é¢æˆ‘ä»¬å¯¹è¿™ä¸¤ä¸­æ–¹å¼è¿›è¡Œè¯¦ç»†çš„ä»‹ç»ã€‚</p>
<h3 id="2-åŸºäºACL-è®¿é—®æ§åˆ¶-æ–¹å¼"><a href="#2-åŸºäºACL-è®¿é—®æ§åˆ¶-æ–¹å¼" class="headerlink" title="2. åŸºäºACL(è®¿é—®æ§åˆ¶)æ–¹å¼"></a>2. åŸºäºACL(è®¿é—®æ§åˆ¶)æ–¹å¼</h3><p>â€‹        æˆ‘ä»¬çŸ¥é“ï¼Œé«˜çº§IP ACLå¯ä»¥åŸºäºæº/ç›®çš„IPåœ°å€ã€æº/ç›®çš„ç«¯å£ã€åè®®ç­‰ä¿¡æ¯å¯¹æ•°æ®æŠ¥æ–‡è¿›è¡Œè¿‡æ»¤ï¼Œ è€Œè¿™IPsecæ­£å¥½å¯ä»¥ä½¿ç”¨ACLçš„æ–¹å¼æ¥ç¡®å®šå“ªäº›æ•°æ®æŠ¥æ–‡éœ€è¦éš§é“ä¿æŠ¤ã€‚</p>
<p>â€‹        å½“ä½¿ç”¨å½“é‡‡ç”¨ACLçš„æ–¹å¼æ¥å®šä¹‰â€œæ„Ÿå…´è¶£æµâ€æ—¶ï¼Œæ‰‹åŠ¨æ–¹å¼å’ŒIKEåå•†æ–¹å¼å»ºç«‹çš„IPsec éš§é“æ˜¯ç”±é«˜çº§ACLæ¥æŒ‡å®šéœ€è¦ä¿æŠ¤çš„æ•°æ®æµèŒƒå›´ï¼Œå¹¶ä»ä¸­è¿‡æ»¤å‡ºéœ€è¦è¿›è¡ŒIPsecéš§é“çš„æŠ¥æ–‡ã€‚ACLè§„åˆ™å…è®¸çš„æŠ¥æ–‡(permit)å°†è¢«ä¿æŠ¤ï¼›ACLè§„åˆ™æ‹’ç»çš„æŠ¥æ–‡(deny)å°†ä¸ä¼šè¢«ä¿æŠ¤ã€‚ </p>
<p>â€‹        å› ä¸ºè¿™é‡Œçš„ACLä¸º<strong>é«˜çº§IP ACL</strong>, æ‰€ä»¥å¯ä»¥æ˜ç¡®çš„æŒ‡å®šæ•°æ®æŠ¥æ–‡ä¸­çš„==æº/ç›®çš„IPåœ°å€<strong>ã€</strong>æº/ç›®çš„ç«¯å£<strong>ã€</strong>åè®®ç±»å‹==ç­‰å‚æ•°ã€‚ä½†æ˜¯è¿™é‡Œçš„æºã€ç›®çš„IPåœ°å€æŒ‡æ•°æ®å‘é€æ–¹å’Œæ¥æ”¶æ–¹çš„ä¸»æœºIPåœ°å€ï¼Œé€šå¸¸æ˜¯ä¸¤ç«¯å†…éƒ¨ç½‘ç»œä¸­çš„ç§ç½‘åœ°å€ã€‚</p>
<p>â€‹        è¿™ç§åŸºäºACLæ–¹å¼å®šä¹‰æ„Ÿå…´è¶£æµçš„æ–¹å¼çš„ä¼˜ç‚¹æ˜¯ï¼š</p>
<blockquote>
<p>å¯ä»¥åˆ©ç”¨ACLé…ç½®çš„çµæ´»æ€§ï¼Œæ ¹æ®IPåœ°å€ã€ç«¯å£ä¿¡æ¯ã€åè®®ç±»å‹(TCP, UDP, ICMP, IPç­‰)ç­‰ä¿¡æ¯å¯¹æŠ¥æ–‡è¿›è¡Œè¿‡æ»¤ä»è€ŒæŒ‡å®šçµæ´»çš„IPSecä¿æŠ¤æ–¹æ³•ã€‚</p>
</blockquote>
<h3 id="3-åŸºäºè™šæ‹Ÿéš§é“æ¥å£æ–¹å¼"><a href="#3-åŸºäºè™šæ‹Ÿéš§é“æ¥å£æ–¹å¼" class="headerlink" title="3. åŸºäºè™šæ‹Ÿéš§é“æ¥å£æ–¹å¼"></a>3. åŸºäºè™šæ‹Ÿéš§é“æ¥å£æ–¹å¼</h3><p>â€‹        åŸºäºè™šæ‹Ÿéš§é“æ¥å£æ¥å®šä¹‰éœ€è¦ä¿æŠ¤çš„æ•°æ®æµï¼Œé¦–å…ˆéœ€è¦åœ¨ä¸¤ç«¯çš„IPsecè®¾å¤‡<strong>åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿçš„éš§é“æ¥å£Tunnel</strong>, ç„¶åé€šè¿‡é…ç½®ä»¥è¯¥Tunnelæ¥å£ä¸ºå‡ºæ¥å£çš„é™æ€è·¯ç”±ï¼Œä»¥æ­¤æ¥å°†åˆ°è¾¾æŸä¸€ä¸ªå­ç½‘çš„æ•°æ®æµé‡é€šè¿‡IPSecéš§é“è¿›è¡Œè½¬å‘ã€‚å› ä¸ºTunnelæ¥å£ä¸ºç‚¹å¯¹ç‚¹ç±»å‹çš„æ¥å£ï¼Œæ˜¯è¿è¡ŒPPPé“¾è·¯å±‚åè®®çš„ï¼Œå› æ­¤ä»¥è¯¥æ¥å£ä¸ºå‡ºæ¥å£çš„é™æ€è·¯ç”±æ˜¯å¯ä»¥ä¸æŒ‡å®šä¸‹ä¸€è·³IPåœ°å€çš„ã€‚</p>
<p>â€‹        IPsecè™šæ‹Ÿéš§é“æ¥å£æ˜¯ä¸€ç§ä¸‰å±‚é€»è¾‘æ¥å£ï¼Œé‡‡ç”¨è¿™ç§æ–¹å¼æ—¶ï¼Œ<strong>æ‰€æœ‰è·¯ç”±åˆ°IPsecè™šæ‹Ÿéš§é“æ¥å£ä¸Šçš„æŠ¥æ–‡éƒ½å°†è¿›è¡ŒIPSecä¿æŠ¤ï¼Œè€Œä¸å†å¯¹æ•°æ®æµç±»å‹è¿›è¡Œç»†åˆ†</strong>ã€‚ä½¿ç”¨IPSecè™šæ‹Ÿéš§é“æ¥å£æœ‰å¦‚ä¸‹è¯¸å¤šä¼˜ç‚¹ï¼š</p>
<ul>
<li><p><strong>ç®€åŒ–é…ç½®</strong></p>
<p>åªéœ€è¦å°†IPSecä¿æŠ¤çš„æ•°æ®æµå¼•åˆ°è™šæ‹Ÿéš§é“æ¥å£ä¸Šï¼Œæ— éœ€å†é€šè¿‡ACLæ¥å®šä¹‰åŠ è§£å¯†æµé‡çš„ç‰¹å¾ã€‚è¿™ä½¿å¾—IPSecçš„é…ç½®ä¸ä¼šå—åˆ°ç½‘ç»œè§„åˆ’çš„å½±å“ï¼Œå¢åŠ äº†ç½‘ç»œè§„åˆ’çš„å¯æ‰©å±•æ€§ï¼Œé™ä½äº†ç½‘ç»œç»´æŠ¤çš„æˆæœ¬ã€‚</p>
</li>
<li><p><strong>è¾ƒå°å¼€é”€</strong></p>
<p>åœ¨ä¿æŠ¤è¿œç¨‹æ¥å…¥ç”¨æˆ·æµé‡çš„ç»„ç½‘ä¸­ï¼Œåªéœ€è¦åœ¨IPSecè™šæ‹Ÿéš§é“æ¥å£å¤„è¿›è¡ŒIPSecæŠ¥æ–‡å°è£…ï¼Œä¸IPSec over GRE æˆ–è€… IPSec over L2TPæ–¹å¼çš„éš§é“å°è£…ç›¸æ¯”ï¼Œè¾ƒå°‘äº†å°è£…å±‚æ¬¡ï¼ŒèŠ‚çœäº†å¸¦å®½ã€‚</p>
</li>
<li><p><strong>æ”¯æŒèŒƒå›´æ›´å¹¿</strong></p>
<p>==ç‚¹å¯¹ç‚¹IPSecè™šæ‹Ÿéš§é“æ¥å£å¯ä»¥æ”¯æŒåŠ¨æ€è·¯ç”±åè®®ï¼ŒåŒæ—¶è¿˜å¯ä»¥æ”¯æŒå¯¹ç»„æ’­æµé‡çš„æŠ¥æ–‡==ã€‚å¦å¤–ï¼ŒIPSecè™šæ‹Ÿéš§é“æ¥å£åœ¨å®æ–½è¿‡ç¨‹ä¸­æ˜ç¡®çš„åŒºåˆ†å‡ºâ€œåŠ å¯†å‰â€å’Œâ€œåŠ å¯†åâ€ä¸¤ä¸ªé˜¶æ®µï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®ä¸åŒçš„ç»„ç½‘éœ€æ±‚çµæ´»çš„é€‰æ‹©å…¶ä»–ä¸šåŠ¡(ä¾‹å¦‚NAT, QoS)å®æ–½çš„é˜¶æ®µã€‚ ä¾‹å¦‚ç”¨æˆ·å¸Œæœ›å¯¹åŠ å¯†å‰çš„æŠ¥æ–‡è¿›è¡ŒQoSï¼Œåˆ™å¯ä»¥åœ¨IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šåº”ç”¨QoSç­–ç•¥ï¼›å¦‚æœå¸Œæœ›å¯¹IPSecå°è£…åçš„æŠ¥æ–‡åº”ç”¨QoSï¼Œåˆ™å¯ä»¥åœ¨æŠ¥æ–‡å‘é€çš„ç‰©ç†æ¥å£ä¸Šåº”ç”¨QoSç­–ç•¥ã€‚</p>
</li>
</ul>
<h3 id="4-è™šæ‹Ÿéš§é“æ¥å£"><a href="#4-è™šæ‹Ÿéš§é“æ¥å£" class="headerlink" title="4. è™šæ‹Ÿéš§é“æ¥å£"></a>4. è™šæ‹Ÿéš§é“æ¥å£</h3><p>â€‹    IPSec è™šæ‹Ÿéš§é“æ¥å£(å³Tunnelæ¥å£)ï¼Œæ˜¯ä¸€ç§æ”¯æŒè·¯ç”±çš„ä¸‰å±‚é€»è¾‘æ¥å£ï¼Œå®ƒå¯ä»¥æ”¯æŒåŠ¨æ€è·¯ç”±åè®®ã€æ‰€æœ‰è·¯ç”±åˆ°IPSecè™šæ‹Ÿéš§é“æ¥å£çš„æŠ¥æ–‡éƒ½å°†è¿›è¡ŒIPSecä¿æŠ¤ï¼ŒåŒæ—¶å¯ä»¥æ”¯æŒå¯¹ç»„æ’­æµé‡çš„ä¿æŠ¤ã€‚</p>
<p>â€‹    ä¸‹é¢ç®€å•ä»‹ç»ä¸‹IPSecéš§é“ä¸¤ç«¯çš„è™šæ‹Ÿéš§é“æ¥å£ä¸ŠæŠ¥æ–‡å¤„ç†æµç¨‹ï¼š</p>
<h4 id="4-1-IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šå°è£…å’ŒåŠ å¯†æµç¨‹"><a href="#4-1-IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šå°è£…å’ŒåŠ å¯†æµç¨‹" class="headerlink" title="4.1 IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šå°è£…å’ŒåŠ å¯†æµç¨‹"></a>4.1 IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šå°è£…å’ŒåŠ å¯†æµç¨‹</h4><p>ç”¨æˆ·æ•°æ®åˆ°è¾¾IPSecè®¾å¤‡(å¦‚è·¯ç”±å™¨)ï¼Œéœ€è¦è¢«IPSecä¿æŠ¤çš„æŠ¥æ–‡(==æ„Ÿå…´è¶£æµ==)ä¼šè¢«è½¬å‘åˆ°IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè¿›è¡Œå°è£…å’ŒåŠ å¯†ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120210702.png" alt="image-20200515224718740"></p>
<ul>
<li>Routerå°†ä»å…¥æ¥å£ä¸Šæ”¶åˆ°çš„æ˜æ–‡IPæŠ¥æ–‡åå‘é€åˆ°è½¬å‘æ¨¡å—è¿›è¡Œå¤„ç†</li>
<li>è½¬å‘æ¨¡å—ä¾æ®è·¯ç”±è¡¨æŸ¥è¯¢ç»“æœè¿›è¡Œè½¬å‘ï¼Œå¦‚æœä¸ºç›¸åº”çš„æ„Ÿå…´è¶£æµï¼Œä¼šè¢«å¼•åˆ°IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè¿›è¡ŒAHæˆ–ESPå°è£…;</li>
<li>IPSecè™šæ‹Ÿéš§é“æ¥å£å®Œæˆå¯¹æ˜æ–‡çš„å°è£…å¤„ç†åï¼Œæ ¹æ®å»ºç«‹çš„IPSec SAå®‰å…¨ç­–ç•¥å†å°†å°è£…åçš„æŠ¥æ–‡è¿›è¡ŒåŠ å¯†ï¼Œç„¶åå†å°†åŠ å¯†åçš„æŠ¥æ–‡äº¤ç”±è½¬å‘æ¨¡å—è¿›è¡Œå¤„ç†</li>
<li>è½¬å‘æ¨¡å—é€šè¿‡ç¬¬äºŒæ¬¡è½¬å‘æŸ¥è¯¢åï¼Œå°†å·²ç»å°è£…å®Œæ¯•çš„åŠ å¯†IPSecæŠ¥æ–‡é€šè¿‡ç›¸åº”çš„ç‰©ç†æ¥å£å‘é€å‡ºå»ï¼Œæœ€ç»ˆå¯†æ–‡åˆ°è¾¾å¯¹ç«¯çš„IPSecè®¾å¤‡çš„è™šæ‹Ÿéš§é“æ¥å£ä¸Šã€‚</li>
</ul>
<h4 id="4-2-IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè§£å°è£…å’Œè§£å¯†æµç¨‹"><a href="#4-2-IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè§£å°è£…å’Œè§£å¯†æµç¨‹" class="headerlink" title="4.2 IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè§£å°è£…å’Œè§£å¯†æµç¨‹"></a>4.2 IPSecè™šæ‹Ÿéš§é“æ¥å£ä¸Šè§£å°è£…å’Œè§£å¯†æµç¨‹</h4><p>æ•°æ®ç»è¿‡IPSecéš§é“ä¼ è¾“åˆ°è¾¾å¯¹ç«¯IPSecè®¾å¤‡æ—¶ï¼Œéœ€è¦å¯¹æ•°æ®åŒ…è¿›è¡Œè§£å¯†ã€è§£å°è£…å¤„ç†ã€‚å®ƒçš„å¤„ç†æµç¨‹å¦‚ä¸‹æ‰€ç¤º:</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120210705.png" alt="image-20200515225103796"></p>
<ul>
<li>Routerå°†ä»å…¥æ¥å£ä¸Šæ”¶åˆ°çš„åŠ å¯†çš„IPæŠ¥æ–‡å‘é€åˆ°è½¬å‘æ¨¡å—è¿›è¡Œå¤„ç†</li>
<li>è½¬å‘æ¨¡å—è¯†åˆ«åˆ°æ­¤å¯†æ–‡çš„ç›®çš„IPåœ°å€ä¸ºæœ¬è®¾å¤‡çš„éš§é“æ¥å£IPåœ°å€ï¼Œä¸”IPæŠ¥æ–‡åè®®å·ä¸ºESPã€AHã€UDPæ—¶ï¼Œä¼šå°†æ­¤æŠ¥æ–‡å‘é€åˆ°ç›¸åº”çš„è™šæ‹Ÿéš§é“æ¥å£ä¸Šè¿›è¡Œè§£å¯†å’Œè§£å°è£…å¤„ç†;</li>
<li>IPSecè™šæ‹Ÿéš§é“æ¥å£å®Œæˆå¯¹å¯†æ–‡çš„è§£å°è£…å¤„ç†åï¼Œå†å°†è§£å°è£…åçš„æŠ¥æ–‡äº¤ç”±è½¬å‘æ¨¡å—è¿›è¡Œå¤„ç†</li>
<li>è½¬å‘æ¨¡å—é€šè¿‡ç¬¬äºŒæ¬¡è½¬å‘æŸ¥è¯¢åï¼Œå°†IPæ˜æ–‡é€šè¿‡ç›¸åº”çš„ç‰©ç†æ¥å£å‘é€å‡ºå»ï¼Œæœ€ç»ˆå¯†æ–‡åˆ°è¾¾ç›¸åº”çš„ä¸»æœºä¸Šã€‚</li>
</ul>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>openswanä¸“æ åºè¨€</title>
    <url>/blogs/2021/11/20/openswan%E4%B8%93%E6%A0%8F%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<h2 id="openswanä¸“æ åºè¨€"><a href="#openswanä¸“æ åºè¨€" class="headerlink" title="openswanä¸“æ åºè¨€"></a>openswanä¸“æ åºè¨€</h2><p><strong>â€œä¸€æ¯èŒ¶ï¼Œä¸€åŒ…çƒŸï¼Œä¸€ä¸ªbugè§£ä¸€å¤©ï¼ï¼ï¼â€ã€‚</strong></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120225547.jpg"></p>
<span id="more"></span>        

<p>2020å¹´æ˜¥å­£ï¼Œæ­£å€¼æ–°å† ç—…æ¯’åœ¨å…¨çƒè‚†è™ä¹‹é™…ï¼Œç¾å›½çš„ç–«æƒ…å·²ç»ç›¸å½“çš„ä¸¥å³»ï¼Œæ¯å¤©ä»ä»¥3ä¸‡é€Ÿåº¦ç‹‚å¥”ã€‚è€Œå›½å†…çš„ç–«æƒ…åœ¨å…¨å›½äººæ°‘çš„å…±åŒåŠªåŠ›ä¸‹å·²ç»é€æ¸å‡å¼±ï¼Œå¹¶è¶‹äºæ­£å¸¸ï¼Œäººä»¬çš„å·¥ä½œã€ç”Ÿæ´»é€æ­¥æ­¥å…¥æ­£è½¨ã€‚åœ¨è¿™é‡Œç”±è¡·çš„å¸Œæœ›å…¨çƒäººä»¬æ—©æ—¥åº¦è¿‡éš¾å…³ï¼Œå¼€å§‹æ–°çš„å¾ç¨‹ã€‚ </p>
<p>â€‹        é¦–å…ˆéœ€è¦è¯´æ˜openswançš„èµ·æºã€‚ ç°åœ¨ç½‘ç»œå·²ç»åŸºæœ¬å®ç°äº†äº’è”äº’é€šï¼Œä½†æ˜¯é€šè®¯é¢ä¸´ç€å¾ˆå¤§çš„æŒ‘æˆ˜ï¼šä¸å®‰å…¨ï¼Œå®¹æ˜“è¢«æ”»å‡»ã€çªƒå¬ã€‚æ¯”å¦‚å‡ å¹´å‰çš„æ£±é•œé—¨äº‹ä»¶ã€‚è€Œä¸ºäº†å®ç°å®‰å…¨ç½‘ç»œé€šè®¯ï¼Œå‡ºç°äº†å„ç§å„æ ·çš„åŠ å¯†æ‰‹æ®µï¼šç½‘ç»œå±‚åŠ å¯†ã€ä¼ è¾“å±‚åŠ å¯†ã€å¥—æ¥å­—å±‚åŠ å¯†ç­‰ç­‰ã€‚è€ŒIPsecä¾¿æ˜¯ç½‘ç»œå±‚åŠ å¯†çš„ä¸€ä¸ªæ°å‡ºçš„ä»£è¡¨ï¼ŒIPsecçš„å¼€æºå®ç°åŒ…æ‹¬æœ€åˆçš„freeswan, ä»¥åŠä¹‹åçš„å†æ¬¡åŸºç¡€ä¸Šå¼€å‘çš„openswanå’Œstrongswanå·¥ç¨‹ã€‚æˆ‘ä»¬è¿™é‡Œä¸»è¦é€šè¿‡openswanæ¥å­¦ä¹ IPsecåŠŸèƒ½ã€‚</p>
<p>â€‹        ä»Šå¤©ç‰¹åˆ«çš„åœ¨CSDNå¼€é€šä¸€ä¸ªopenswanæºç ä¸“æ ï¼Œä¸»è¦ç”¨æ¥åˆ†äº«ä¸ªäººåœ¨å­¦ä¹ openswanæºç çš„è¿‡ç¨‹ä¸­çš„å¿ƒå¾—å’Œä½“ä¼šï¼Œå°†ç”¨åˆ°çš„çŸ¥è¯†å’ŒæŠ€æœ¯åˆ†äº«å‡ºæ¥ï¼ŒåŒæ—¶ä¹Ÿæä¾›ä¸€ä¸ªå¹³å°ä¾›å¤§å®¶äº¤æµå­¦ä¹ ã€‚å¼€é€šè¿™ä¸ªä¸“æ çš„ç›®çš„ä¸»è¦æ˜¯ç”±äºï¼šåœ¨å­¦ä¹ çš„è¿‡ç¨‹ä¸­ï¼Œæ‰¾åˆ°çš„å¯ç”¨èµ„æ–™å¾ˆå°‘ï¼ŒåŸºæœ¬åªèƒ½å»æŸ¥è¯¢RFCæ–‡æ¡£ã€åˆ†ææºç ï¼Œè¿™æ ·å›ºç„¶è®©æˆ‘ä»¬å°è±¡æ›´åŠ æ·±åˆ»ï¼Œä½†æ˜¯ä¼šæµªè´¹å¾ˆå¤šçš„æ—¶é—´ã€‚å°½ç®¡å¦‚æ­¤ï¼Œä¹Ÿå¯èƒ½æ‰¾ä¸åˆ°åˆé€‚çš„èµ„æ–™æˆ–è€…ç»“è®ºï¼Œå› æ­¤ä¸ºäº†èŠ‚çœå®è´µçš„æ—¶é—´ï¼Œç‰¹å°†ä¸ªäººçš„å­¦ä¹ å†ç¨‹ã€è·å¾—çš„èµ„æ–™ã€ç”¨åˆ°çš„çŸ¥è¯†å’ŒæŠ€æœ¯ä¿¡æ¯ã€ç­‰ç­‰å„ç§ä¿¡æ¯å…¨éƒ¨ä»¥åšå®¢çš„æ–¹å¼åˆ†äº«ã€‚åŒæ—¶ä¹Ÿä¼šå°†ç¬”è®°ã€æµç¨‹å›¾ã€æ€ç»´å¯¼å›¾ç­‰ä¿¡æ¯æ•´ç†ä¸ºæ–‡æ¡£ï¼ŒåæœŸå¦‚æœéœ€è¦åˆ™å¯æäº¤è‡³ç½‘ç›˜ï¼Œå¹¶åœ¨åšå®¢é‡Œé™„ä¸Šç›¸åº”çš„é“¾æ¥ã€‚</p>
<p>â€‹        ç”±äºopenswançš„æºç ä»£ç é‡æ¯”è¾ƒå¤šï¼Œä¸”æ¶‰åŠåˆ°çš„çŸ¥è¯†ä¹Ÿå¾ˆå¹¿ï¼Œæ¯”å¦‚åŠ è§£å¯†ç®—æ³•ã€IKEåå•†ã€PKIå…¬é’¥è®¾æ–½ç­‰ï¼Œå› ä¸ºå®ƒçš„æœ€ç»ˆç›®çš„æ˜¯å®‰å…¨ï¼Œè€Œä¸æ˜¯åˆ›å»ºéš§é“è®¿é—®å†…ç½‘ï¼Œå› æ­¤æ¶‰åŠåˆ°å¾ˆå¤šçš„ç®—æ³•ï¼Œè¿™éƒ¨åˆ†å¯¼è‡´äº†IPsecå­¦ä¹ èµ·æ¥å¾ˆè´¹åŠ›ã€æ¯ç‡¥ã€‚ä¸ªäººæ²¡æœ‰è¿™éƒ¨åˆ†ç®—æ³•çš„ä»»ä½•åŸºç¡€ï¼Œå› æ­¤å¯¹ç®—æ³•çš„ä»‹ç»ä¼šæ”¾åˆ°å…¶ä»–å·¥ä½œä¹‹åã€‚åœ¨æ¥ä¸‹æ¥çš„å¤šåŠå¹´æ—¶é—´é‡Œï¼ˆ2020å¹´5æœˆ~2021å¹´åˆï¼‰ï¼Œæˆ‘ä¼šå°½è‡ªå·±æœ€å¤§çš„åŠªåŠ›æ¥å­¦ä¹ openswanæºç ã€‚è®¡åˆ’æ˜¯æ¯å‘¨åšä¸€ç¯‡åšå®¢ç”¨æ¥è®°å½•è¿™ä¸€å‘¨æ—¶é—´å†…çš„å­¦ä¹ å¿ƒå¾—å’ŒæŠ€æœ¯ï¼ŒåŒæ—¶ä¹Ÿä¼šå°†æ³¨é‡Šåçš„ä»£ç è¿›è¡Œåˆ†äº«ã€‚å¸Œæœ›é€šè¿‡è‡ªå·±çš„åŠªåŠ›å’Œä»˜å‡ºï¼Œä¸ºå…¶ä»–äººèŠ‚çœæ›´å¤šçš„æ—¶é—´æ¥å­¦ä¹ å…¶ä»–çš„çŸ¥è¯†å’ŒæŠ€æœ¯ã€‚åŒæ—¶å…¶ä»–äººä¹Ÿå¯ä»¥å°†è‡ªå·±çš„ç–‘é—®ã€è§è§£ã€ç›¸å…³æŠ€æœ¯åˆ†äº«å‡ºæ¥ä¾›å¤§å®¶å­¦ä¹ å’Œè®¨è®ºï¼Œå¢è¿›ç†è§£ã€‚        </p>
<p>ç»“è¯­ï¼šå†³å®šä¸€ä¸ªäººæˆå°±çš„ï¼Œä¸æ˜¯å¤©åˆ†ï¼Œä¹Ÿä¸æ˜¯è¿æ°”ï¼Œè€Œæ˜¯åšæŒå’Œä»˜å‡ºï¼Œæ˜¯ä¸åœçš„åšï¼Œé‡å¤çš„åšï¼Œç”¨å¿ƒçš„åšã€‚å¦‚æœæ²¡æœ‰é˜³å…‰ï¼Œæˆ‘ä»¬è¦å­¦ä¼šäº«å—é£é›¨çš„æ¸…å‡‰ï¼›å¦‚æœæ²¡æœ‰é²œèŠ±ï¼Œæˆ‘ä»¬è¦å­¦ä¼šäº«å—æ³¥åœŸçš„èŠ¬èŠ³ï¼›è®°ä½æ¯å¤©é¼“åŠ±è‡ªå·±ï¼Œè¶ŠåŠªåŠ›ï¼Œè¶Šå‹¤å¥‹ï¼Œè¶Šå¹¸è¿ï¼Œè¶Šæ„Ÿæ©ï¼Œè¶Šå¹¸ç¦ã€‚</p>
<p>â€‹        </p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬ä¸€åŒ…ï¼šmain_outI1()</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Amain_outI1()/</url>
    <content><![CDATA[<h2 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h2><p><code>main_outI1()</code>ä½œä¸ºä¸»æ¨¡å¼ä¸»åŠ¨å‘èµ·è¿æ¥è¯·æ±‚çš„æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å­¦ä¹ è¯¥å‡½æ•°çš„å¤„ç†æµç¨‹æ¥æ¢ç©¶openswanä¸­æŠ¥æ–‡å°è£…çš„åŸºæœ¬æ€æƒ³ã€‚å¦‚æœä¹‹å‰æ²¡æœ‰å­¦ä¹ åŸºæœ¬çš„å‡½æ•°æ¥å£(å¦‚in_struct, out_struct, out_saç­‰)ï¼Œé‚£ä¹ˆç›´æ¥å­¦ä¹ <code>main_outI1()</code>æµç¨‹æ˜¯æ¯”è¾ƒå›°éš¾çš„ã€‚å¦‚æœæƒ³å¿«é€Ÿå­¦ä¹ è¿™å‡ ä¸ªå‡½æ•°æ¥å£ï¼Œå¯ä»¥æŸ¥çœ‹æˆ‘å…ˆå‰çš„æ–‡ç« ï¼Œæˆ‘æŠŠéœ€è¦çš„åŸºæœ¬çŸ¥è¯†ã€æ€æƒ³ç­‰åšäº†åŸºæœ¬ä»‹ç»ï¼Œçœ‹å®Œé‚£å‡ ä¸ªæ¥å£å†æ¥å­¦ä¹ æ­¤åçš„ISAKMPåå•†æµç¨‹ä¼šå®¹æ˜“å¾ˆå¤šï¼Œèµ·åˆ°äº‹åŠåŠŸå€çš„æ•ˆæœã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œä¸€ä¸ªå‡½æ•°æœ‰å‡ ç™¾è¡Œéƒ½æ˜¯å¾ˆå¸¸è§çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<h2 id="2-main-outI1-æµç¨‹å›¾"><a href="#2-main-outI1-æµç¨‹å›¾" class="headerlink" title="2. main_outI1()æµç¨‹å›¾"></a>2. main_outI1()æµç¨‹å›¾</h2><p>ä¸‹é¢ä¸¤ä¸ªæµç¨‹å›¾ä¸­ä¸»è¦æè¿°äº†ä¸‰ä¸ªå‡½æ•°çš„å¤„ç†æµç¨‹ï¼Œåé¢æˆ‘ä¼šåˆ†åˆ«é™„ä¸Šè¿™ä¸‰ä¸ªå‡½æ•°çš„æºç ä¿¡æ¯ã€‚</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204802.png" alt="main_outI1"></p>
<p><img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Amain_outI1().assets%5Cimage-20200520000233483.png" alt="out_saå¤„ç†æµç¨‹"></p>
<h2 id="3-main-outI1-æºç æ³¨é‡Š"><a href="#3-main-outI1-æºç æ³¨é‡Š" class="headerlink" title="3. main_outI1()æºç æ³¨é‡Š"></a>3. main_outI1()æºç æ³¨é‡Š</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_outI1</span><span class="params">(<span class="keyword">int</span> whack_sock</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct connection *c</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct state *predecessor</span></span></span><br><span class="line"><span class="params"><span class="function">           , <span class="keyword">so_serial_t</span>  *newstateno</span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">lset_t</span> policy</span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">try</span></span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">enum</span> crypto_importance importance</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct xfrm_user_sec_ctx_ike * uctx</span></span></span><br><span class="line"><span class="params"><span class="function">	   )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> new_state();<span class="comment">/*åˆ›å»ºä¸€ä¸ªæ–°çš„çŠ¶æ€*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> <span class="title">md</span>;</span>   <span class="comment">/* use reply/rbody found inside */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numvidtosend = <span class="number">1</span>;  <span class="comment">/* we always send DPD VID */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled) &#123;</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SEND_PLUTO_VID || defined(openpgp_peer)</span></span><br><span class="line">    numvidtosend++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_client || c-&gt;spd.<span class="keyword">this</span>.xauth_server) &#123;</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*ç»Ÿè®¡VIDä¸ªæ•°*/</span></span><br><span class="line">    <span class="comment">/* set up new state */</span><span class="comment">/*æ ¹æ®å¯¹ç«¯IPåœ°å€ä¿¡æ¯ç”Ÿæˆä¸€ä¸ªæ–°çš„cookie*/</span></span><br><span class="line">    get_cookie(TRUE, st-&gt;st_icookie, COOKIE_SIZE, &amp;c-&gt;spd.that.host_addr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*åˆå§‹åŒ–æ–°çš„stateç»“æ„*/</span></span><br><span class="line">    initialize_new_state(st, c, policy, <span class="keyword">try</span>, whack_sock, importance);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(newstateno) *newstateno = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKE version numbers -- used mostly in logging */</span></span><br><span class="line">    st-&gt;st_ike_maj        = IKEv1_MAJOR_VERSION;</span><br><span class="line">    st-&gt;st_ike_min        = IKEv1_MINOR_VERSION;</span><br><span class="line"></span><br><span class="line">    change_state(st, STATE_MAIN_I1);<span class="comment">/*è®¾ç½®å½“å‰çš„çŠ¶æ€ä¸ºSTATE_MAIN_I1*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAS_IPSEC_POLICY(policy))</span><br><span class="line">	add_pending(dup_any(whack_sock), st, c, policy, <span class="number">1</span></span><br><span class="line">	    , predecessor == <span class="literal">NULL</span>? SOS_NOBODY : predecessor-&gt;st_serialno</span><br><span class="line">	    , uctx</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">    <span class="comment">/*For main modes states, sec ctx is always null*/</span></span><br><span class="line">    st-&gt;sec_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predecessor == <span class="literal">NULL</span>)</span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Main Mode&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Main Mode to replace #%lu&quot;</span>, predecessor-&gt;st_serialno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set up reply */</span></span><br><span class="line">    zero(reply_buffer);<span class="comment">/*åˆå§‹åŒ–åº”ç­”æŠ¥æ–‡(å‘é€çš„æŠ¥æ–‡)çš„ç»“æ„*/</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out */</span></span><br><span class="line">    &#123;<span class="comment">/*æ·»åŠ isakmpå¤´éƒ¨ä¿¡æ¯*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	zero(&amp;hdr);	<span class="comment">/* default to 0 */</span></span><br><span class="line">	hdr.isa_version = ISAKMP_MAJOR_VERSION &lt;&lt; ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION;</span><br><span class="line">	hdr.isa_np = ISAKMP_NEXT_SA;</span><br><span class="line">	hdr.isa_xchg = ISAKMP_XCHG_IDPROT;</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_icookie, st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line">	<span class="comment">/* R-cookie, flags and MessageID are left zero */</span></span><br><span class="line">	<span class="comment">/*é•¿åº¦å­—æ®µæœ€åè®¾ç½®: close_output_pbs(&amp;reply_stream);*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;md.rbody))</span><br><span class="line">	&#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA out */</span></span><br><span class="line">    &#123;<span class="comment">/************å°è£…SAè½½è·**************/</span></span><br><span class="line">	u_char *sa_start = md.rbody.cur;</span><br><span class="line">	<span class="keyword">int</span>    policy_index = POLICY_ISAKMP(policy</span><br><span class="line">					    , c-&gt;spd.<span class="keyword">this</span>.xauth_server</span><br><span class="line">					    , c-&gt;spd.<span class="keyword">this</span>.xauth_client);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we  have an OpenPGP certificate we assume an</span></span><br><span class="line"><span class="comment">	 * OpenPGP peer and have to send the Vendor ID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*å¦‚æœå­˜åœ¨VIDï¼Œåˆ™éœ€è¦è®¾ç½®ä¸‹ä¸€è½½è·çš„å€¼*/</span></span><br><span class="line">	<span class="keyword">int</span> np = numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_sa(&amp;md.rbody</span><br><span class="line">		    , &amp;oakley_sadb[policy_index], st, TRUE, FALSE, np))</span><br><span class="line">	&#123;</span><br><span class="line">	    openswan_log(<span class="string">&quot;outsa fail&quot;</span>);</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* save initiator SA for later HASH */</span></span><br><span class="line">	passert(st-&gt;st_p1isa.ptr == <span class="literal">NULL</span>);	<span class="comment">/* no leak!  (MUST be first time) */</span></span><br><span class="line">	clonetochunk(st-&gt;st_p1isa, sa_start, md.rbody.cur - sa_start</span><br><span class="line">	    , <span class="string">&quot;sa in main_outI1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SEND_PLUTO_VID || c-&gt;spd.<span class="keyword">this</span>.cert.type == CERT_PGP)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> *vendorid = (c-&gt;spd.<span class="keyword">this</span>.cert.type == CERT_PGP) ?</span><br><span class="line">	    pgp_vendorid : pluto_vendorid;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_vendor_id_desc, &amp;md.rbody</span><br><span class="line">			     , vendorid, <span class="built_in">strlen</span>(vendorid), <span class="string">&quot;Vendor ID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send DPD VID */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(np, &amp;md.rbody, VID_MISC_DPD)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;nat traversal enabled: %d&quot;</span></span><br><span class="line">			  , nat_traversal_enabled));</span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled) &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add supported NAT-Traversal VID */</span></span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_insert_vid(np, &amp;md.rbody, st)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_client || c-&gt;spd.<span class="keyword">this</span>.xauth_server) &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(np, &amp;md.rbody, VID_MISC_XAUTH)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* if we are not 0 then something went very wrong above */</span></span><br><span class="line">    <span class="keyword">if</span>(numvidtosend != <span class="number">0</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;payload alignment problem please check the code in main_inR1_outR2 (num=%d)&quot;</span>, numvidtosend);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    close_message(&amp;md.rbody);</span><br><span class="line">    close_output_pbs(&amp;reply_stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let TCL hack it before we mark the length and copy it */</span></span><br><span class="line">    TCLCALLOUT(<span class="string">&quot;avoidEmitting&quot;</span>, st, st-&gt;st_connection, &amp;md);</span><br><span class="line">    clonetochunk(st-&gt;st_tpacket, reply_stream.start, pbs_offset(&amp;reply_stream)</span><br><span class="line">	, <span class="string">&quot;reply packet for main_outI1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transmit */</span></span><br><span class="line">    send_packet(st, <span class="string">&quot;main_outI1&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a retransmission event, half a minute henceforth */</span></span><br><span class="line">    TCLCALLOUT(<span class="string">&quot;adjustTimers&quot;</span>, st, st-&gt;st_connection, &amp;md);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line"> tpm_stolen:</span><br><span class="line"> tpm_ignore:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    delete_event(st);</span><br><span class="line">    event_schedule(EVENT_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predecessor != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	update_pending(predecessor, st);</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_MAIN_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate, replacing #%lu&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state)</span><br><span class="line">	    , predecessor-&gt;st_serialno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_MAIN_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate&quot;</span>, enum_name(&amp;state_names, st-&gt;st_state));</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-out-sa-æºç æ³¨é‡Š"><a href="#4-out-sa-æºç æ³¨é‡Š" class="headerlink" title="4. out_sa()æºç æ³¨é‡Š"></a>4. out_sa()æºç æ³¨é‡Š</h2><p>ç•¥ã€‚æ­¤å‡½æ•°400å¤šè¡Œï¼Œç”±äºæµç¨‹å›¾ä¸Šæ¯”è¾ƒè¯¦ç»†å°±ä¸å†åˆ—å‡ºã€‚</p>
<h3 id="5-oakley-alg-makedb-æºç æ³¨é‡Š"><a href="#5-oakley-alg-makedb-æºç æ³¨é‡Š" class="headerlink" title="5. oakley_alg_makedb()æºç æ³¨é‡Š"></a>5. oakley_alg_makedb()æºç æ³¨é‡Š</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	Create an OAKLEY proposal based on alg_info and policy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: maxtrans is an enum, not a count</span></span><br><span class="line"><span class="comment"> * 	Should probably be declared an enum at some point.</span></span><br><span class="line"><span class="comment"> * 	-1 - ???</span></span><br><span class="line"><span class="comment"> * 	 0 - No limit</span></span><br><span class="line"><span class="comment"> * 	 1 - One proposal - period</span></span><br><span class="line"><span class="comment"> * 	 2 - One DH group, take first DH group and ignore any that don&#x27;t match</span></span><br><span class="line"><span class="comment"> *æ ¹æ®é…ç½®çš„ç§˜é’¥ç®—æ³•ä¿¡æ¯é‡æ–°ç”Ÿæˆä¸€ä¸ªsadbä¿¡æ¯</span></span><br><span class="line"><span class="comment"> *ä¼ å…¥çš„sadbåº”è¯¥ä¸ºå›ºå®šçš„ç§˜é’¥ç®—æ³•ä¿¡æ¯ï¼Œå› æ­¤éœ€è¦æ ¹æ®ç­–ç•¥æ¥é‡æ–°ç”Ÿæˆä¸€ä¸ªæ–°çš„sadb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct db_sa *</span></span><br><span class="line"><span class="function"><span class="title">oakley_alg_makedb</span><span class="params">(struct alg_info_ike *ai</span></span></span><br><span class="line"><span class="params"><span class="function">		  , struct db_sa *base</span></span></span><br><span class="line"><span class="params"><span class="function">		  , <span class="keyword">int</span> maxtrans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* struct db_context inprog UNUSED; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">gsp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">emp_sp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ike_info</span> *<span class="title">ike_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ealg, halg, modp, eklen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Next two are for multiple proposals in agressive mode... */</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_modp=<span class="number">0</span>, wrong_modp=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">encrypt_desc</span> *<span class="title">enc_desc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> transcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * start by copying the proposal that would have been picked by</span></span><br><span class="line"><span class="comment">     * standard defaults.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ai) &#123;</span><br><span class="line">	DBG(DBG_CRYPT,DBG_log(<span class="string">&quot;no IKE algorithms for this connection &quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gsp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for each group, we will create a new proposal item, and then</span></span><br><span class="line"><span class="comment">     * append it to the list of transforms in the conjoint point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * when creating each item, we will use the first transform</span></span><br><span class="line"><span class="comment">     * from the base item as the template.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALG_INFO_IKE_FOREACH(ai, ike_info, i) &#123;<span class="comment">//éå†ç­–ç•¥ä¸­çš„ç®—æ³•ä¿¡æ¯</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ike_info-&gt;ike_default == FALSE) &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_attr</span>  *<span class="title">enc</span>, *<span class="title">hash</span>, *<span class="title">auth</span>, *<span class="title">grp</span>, *<span class="title">enc_keylen</span>, *<span class="title">new_auth</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_prop</span>  *<span class="title">prop</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_prop_conj</span> *<span class="title">cprop</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*è·å–åˆ°åŠ å¯†ç®—æ³•ã€å“ˆå¸Œç®—æ³•ã€è®¤è¯ç®—æ³•ã€åŠ å¯†ç§˜é’¥é•¿åº¦ç­‰ä¿¡æ¯*/</span></span><br><span class="line">	    ealg = ike_info-&gt;ike_ealg;</span><br><span class="line">	    halg = ike_info-&gt;ike_halg;</span><br><span class="line">	    modp = ike_info-&gt;ike_modp;</span><br><span class="line">	    eklen= ike_info-&gt;ike_eklen;</span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">/*åˆ¤æ–­è¿™å‡ ä¸ªç®—æ³•æ˜¯å¦åˆæ³•ã€æ˜¯å¦å­˜åœ¨ç­‰*/</span></span></span><br><span class="line">	    <span class="keyword">if</span> (!ike_alg_enc_present(ealg)) &#123;</span><br><span class="line">		DBG_log(<span class="string">&quot;oakley_alg_makedb() &quot;</span></span><br><span class="line">			<span class="string">&quot;ike enc ealg=%d not present&quot;</span>,</span><br><span class="line">			ealg);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (!ike_alg_hash_present(halg)) &#123;</span><br><span class="line">		DBG_log(<span class="string">&quot;oakley_alg_makedb() &quot;</span></span><br><span class="line">			<span class="string">&quot;ike hash halg=%d not present&quot;</span>,</span><br><span class="line">			halg);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    enc_desc = ike_alg_get_encrypter(ealg);</span><br><span class="line"></span><br><span class="line">	    passert(enc_desc != <span class="literal">NULL</span>);</span><br><span class="line">	    <span class="keyword">if</span> (eklen	<span class="comment">/*ç§˜é’¥é•¿åº¦æ˜¯å¦ç¬¦åˆè¦æ±‚*/</span></span><br><span class="line">		&amp;&amp; (eklen &lt; enc_desc-&gt;keyminlen</span><br><span class="line">		    || eklen &gt;  enc_desc-&gt;keymaxlen))</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">		    DBG_log(<span class="string">&quot;ike_alg_db_new() &quot;</span></span><br><span class="line">			    <span class="string">&quot;ealg=%d (specified) keylen:%d, &quot;</span></span><br><span class="line">			    <span class="string">&quot;not valid &quot;</span></span><br><span class="line">			    <span class="string">&quot;min=%d, max=%d&quot;</span></span><br><span class="line">			    , ealg</span><br><span class="line">			    , eklen</span><br><span class="line">			    , enc_desc-&gt;keyminlen</span><br><span class="line">			    , enc_desc-&gt;keymaxlen</span><br><span class="line">			    );</span><br><span class="line">		    <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    <span class="comment">/* okay copy the basic item, and modify it. */</span></span><br><span class="line">	    <span class="keyword">if</span>(eklen &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		emp_sp = sa_copy_sa(&amp;oakley_empty, <span class="number">0</span>);<span class="comment">/*é‡æ–°åˆ†é…ä¸€ä¸ªæ–°çš„æè¿°ä¿¡æ¯*/</span></span><br><span class="line">		cprop = &amp;base-&gt;prop_conjs[<span class="number">0</span>];<span class="comment">/*ä»å®šä¹‰çš„æè¿°ä¿¡æ¯ä¸­è·å–å‚æ•°*/</span></span><br><span class="line">		prop = &amp;cprop-&gt;props[<span class="number">0</span>];<span class="comment">/*å»ºè®®è½½è·*/</span></span><br><span class="line">		trans = &amp;prop-&gt;trans[<span class="number">0</span>];<span class="comment">/*å˜æ¢è½½è·*/</span></span><br><span class="line">		new_auth = &amp;trans-&gt;attrs[<span class="number">2</span>];<span class="comment">/*å±æ€§è½½è·*/</span></span><br><span class="line"></span><br><span class="line">		cprop = &amp;emp_sp-&gt;prop_conjs[<span class="number">0</span>];</span><br><span class="line">		prop = &amp;cprop-&gt;props[<span class="number">0</span>];</span><br><span class="line">		trans = &amp;prop-&gt;trans[<span class="number">0</span>];</span><br><span class="line">		auth = &amp;trans-&gt;attrs[<span class="number">2</span>];</span><br><span class="line">		*auth = *new_auth;		<span class="comment">/*ç»™æ–°çš„æè¿°ç»“æ„ä¸­è®¾ç½®è®¤è¯ç®—æ³•*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		emp_sp = sa_copy_sa_first(base);</span><br><span class="line"></span><br><span class="line">	    passert(emp_sp-&gt;prop_conj_cnt == <span class="number">1</span>);</span><br><span class="line">	    cprop = &amp;emp_sp-&gt;prop_conjs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(cprop-&gt;prop_cnt == <span class="number">1</span>);</span><br><span class="line">	    prop = &amp;cprop-&gt;props[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(prop-&gt;trans_cnt == <span class="number">1</span>);</span><br><span class="line">	    trans = &amp;prop-&gt;trans[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(trans-&gt;attr_cnt == <span class="number">4</span> || trans-&gt;attr_cnt == <span class="number">5</span>);</span><br><span class="line">	    enc  = &amp;trans-&gt;attrs[<span class="number">0</span>]; <span class="comment">/*åŠ å¯†*/</span></span><br><span class="line">	    hash = &amp;trans-&gt;attrs[<span class="number">1</span>];<span class="comment">/*å“ˆå¸Œ*/</span></span><br><span class="line">	    auth = &amp;trans-&gt;attrs[<span class="number">2</span>];<span class="comment">/*è®¤è¯*/</span></span><br><span class="line">	    grp  = &amp;trans-&gt;attrs[<span class="number">3</span>];<span class="comment">/*DHç»„?*/</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(eklen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		enc_keylen = &amp;trans-&gt;attrs[<span class="number">4</span>];</span><br><span class="line">		enc_keylen-&gt;val = eklen;<span class="comment">/*è®¾ç½®åŠ å¯†ç®—æ³•é•¿åº¦*/</span></span><br><span class="line">	    &#125; <span class="keyword">else</span></span><br><span class="line">		trans-&gt;attr_cnt = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	    passert(enc-&gt;type.oakley == OAKLEY_ENCRYPTION_ALGORITHM);</span><br><span class="line">	    <span class="keyword">if</span>(ealg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		enc-&gt;val = ealg;<span class="comment">/*è®¾ç½®åŠ å¯†ç®—æ³•*/</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    modp = ike_info-&gt;ike_modp;</span><br><span class="line">	    eklen= ike_info-&gt;ike_eklen;</span><br><span class="line"></span><br><span class="line">	    passert(hash-&gt;type.oakley == OAKLEY_HASH_ALGORITHM);</span><br><span class="line">	    <span class="keyword">if</span>(halg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		hash-&gt;val = halg;<span class="comment">/*è®¾ç½®å“ˆå¸Œç®—æ³•*/</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    passert(auth-&gt;type.oakley == OAKLEY_AUTHENTICATION_METHOD);</span><br><span class="line">	    <span class="comment">/* no setting for auth type for IKE */</span></span><br><span class="line"></span><br><span class="line">	    passert(grp-&gt;type.oakley  == OAKLEY_GROUP_DESCRIPTION);</span><br><span class="line">	    <span class="keyword">if</span>(modp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		grp-&gt;val = modp;  <span class="comment">/*è®¾ç½®è®¤è¯ç®—æ³•*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    emp_sp = sa_copy_sa(base, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxtrans == <span class="number">1</span>) &#123;<span class="comment">/*æœ€å¤§å˜æ¢è½½è·æ•°*/</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  We&#x27;re going to leave maxtrans == 1 alone in case there</span></span><br><span class="line"><span class="comment">             * really really is a case where we only want 1.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(transcnt == <span class="number">0</span>) &#123;</span><br><span class="line">		DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;using transform (%d,%d,%d,%ld)&quot;</span></span><br><span class="line">					 , ike_info-&gt;ike_ealg</span><br><span class="line">					 , ike_info-&gt;ike_halg</span><br><span class="line">					 , ike_info-&gt;ike_modp</span><br><span class="line">					 , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen));</span><br><span class="line">		<span class="keyword">if</span>(gsp) &#123;</span><br><span class="line">		    free_sa(gsp);</span><br><span class="line">		&#125;</span><br><span class="line">		gsp = emp_sp;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(transcnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(transcnt == <span class="number">1</span>) &#123;</span><br><span class="line">		    loglog(RC_LOG_SERIOUS</span><br><span class="line"></span><br><span class="line">			   , <span class="string">&quot;multiple transforms were set in aggressive mode. Only first one used.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		loglog(RC_LOG_SERIOUS</span><br><span class="line">		       , <span class="string">&quot;transform (%d,%d,%d,%ld) ignored.&quot;</span></span><br><span class="line">		       , ike_info-&gt;ike_ealg</span><br><span class="line">		       , ike_info-&gt;ike_halg</span><br><span class="line">		       , ike_info-&gt;ike_modp</span><br><span class="line">		       , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Now...  We&#x27;re allowing multiple proposals...  Are we allowing</span></span><br><span class="line"><span class="comment">             * multiple DH groups?</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">	    struct db_sa *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxtrans == <span class="number">2</span> &amp;&amp; transcnt &gt; <span class="number">0</span> &amp;&amp; ike_info-&gt;ike_modp != last_modp ) &#123;</span><br><span class="line">                <span class="comment">/* Not good.</span></span><br><span class="line"><span class="comment">                 * Already got a DH group and this one doesn&#x27;t match */</span></span><br><span class="line">		<span class="keyword">if</span>(wrong_modp == <span class="number">0</span>) &#123;</span><br><span class="line">		    loglog(RC_LOG_SERIOUS</span><br><span class="line">			   , <span class="string">&quot;multiple DH groups were set in aggressive mode. Only first one used.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		loglog(RC_LOG_SERIOUS</span><br><span class="line">		           , <span class="string">&quot;transform (%d,%d,%d,%ld) ignored.&quot;</span></span><br><span class="line">		           , ike_info-&gt;ike_ealg</span><br><span class="line">		           , ike_info-&gt;ike_halg</span><br><span class="line">		           , ike_info-&gt;ike_modp</span><br><span class="line">		           , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen);</span><br><span class="line"></span><br><span class="line">                wrong_modp++;</span><br><span class="line"></span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(gsp) &#123;</span><br><span class="line">	    <span class="comment">/* now merge emp_sa and gsp */</span></span><br><span class="line">		<span class="keyword">new</span> = sa_merge_proposals(gsp, emp_sp);<span class="comment">/*å˜æ¢è½½è·åˆå¹¶*/</span></span><br><span class="line">		free_sa(gsp);</span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">		emp_sp = <span class="literal">NULL</span>;</span><br><span class="line">		gsp = <span class="keyword">new</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		gsp = emp_sp;</span><br><span class="line">	    &#125;</span><br><span class="line">            last_modp = ike_info-&gt;ike_modp;</span><br><span class="line">	&#125;</span><br><span class="line">	transcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    gsp-&gt;parentSA = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬äºŒåŒ…ï¼šmain_inI1_outR1()</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%8C%E5%8C%85%EF%BC%9Amain_inI1_outR1()/</url>
    <content><![CDATA[<h2 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h2><p><code>main_inI1_outR1()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­ç¬¬äºŒåŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼ŒåŒæ—¶ä¹Ÿæ˜¯å“åº”ç«¯å£çš„é¦–åŒ…ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inI1_outR1</code>çš„å¤„ç†æµç¨‹ï¼Œå…³äº<code>main_inI1_outR1</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œä¸€ä¸ªå‡½æ•°æœ‰å‡ ç™¾è¡Œéƒ½æ˜¯å¾ˆå¸¸è§çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<h3 id="2-main-inI1-outR1-å¤„ç†æµç¨‹å›¾"><a href="#2-main-inI1-outR1-å¤„ç†æµç¨‹å›¾" class="headerlink" title="2. main_inI1_outR1()å¤„ç†æµç¨‹å›¾"></a>2. <code>main_inI1_outR1()</code>å¤„ç†æµç¨‹å›¾</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205011.png" alt="image-20200520004303196"></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205022.png" alt="image-20200520004352037"></p>
<h3 id="3-main-inI1-outR1-æºç "><a href="#3-main-inI1-outR1-æºç " class="headerlink" title="3. main_inI1_outR1()æºç "></a>3. <code>main_inI1_outR1()æºç </code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* State Transition Functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The definition of state_microcode_table in demux.c is a good</span></span><br><span class="line"><span class="comment"> * overview of these routines.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Called from process_packet; result handled by complete_v1_state_transition</span></span><br><span class="line"><span class="comment"> * - struct state_microcode member &quot;processor&quot; points to these</span></span><br><span class="line"><span class="comment"> * - these routine definitionss are in state order</span></span><br><span class="line"><span class="comment"> * - these routines must be restartable from any point of error return:</span></span><br><span class="line"><span class="comment"> *   beware of memory allocated before any error.</span></span><br><span class="line"><span class="comment"> * - output HDR is usually emitted by process_packet (if state_microcode</span></span><br><span class="line"><span class="comment"> *   member first_out_payload isn&#x27;t ISAKMP_NEXT_NONE).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The transition functions&#x27; functions include:</span></span><br><span class="line"><span class="comment"> * - process and judge payloads</span></span><br><span class="line"><span class="comment"> * - update st_iv (result of decryption is in st_new_iv)</span></span><br><span class="line"><span class="comment"> * - build reply packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle a Main Mode Oakley first packet (responder side).</span></span><br><span class="line"><span class="comment"> * HDR;SA --&gt; HDR;SA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************</span></span><br><span class="line"><span class="comment">*main_inI1_outR1å‡½æ•°è¢«process_packetå‡½æ•°è°ƒç”¨</span></span><br><span class="line"><span class="comment">*å®ƒçš„è¿”å›ç»“æœç”±complete_v1_state_transitionå¤„ç†</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*********************************/</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI1_outR1</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DMALLOC</span></span><br><span class="line">     <span class="keyword">if</span> (_dm_initialized != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* log unfreed pointers that have been added to the heap since mark */</span></span><br><span class="line">	dmalloc_log_changed(_dm_mark, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	dmalloc_log_stats ();</span><br><span class="line">     &#125;</span><br><span class="line">     _dm_mark = dmalloc_mark() ;</span><br><span class="line">     _dm_initialized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*æ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¸­çš„SAè½½è·éƒ¨åˆ†*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sa_pd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="comment">/*å‡†å¤‡ä½œä¸ºåº”ç­”çš„SAè½½è·ç¼“å†²åŒº*/</span></span><br><span class="line">    pb_stream r_sa_pbs;</span><br><span class="line">    <span class="keyword">lset_t</span> policy_hint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are looking for an OpenPGP Vendor ID sent by the peer */</span></span><br><span class="line">    <span class="keyword">bool</span> openpgp_peer = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determin how many Vendor ID payloads we will be sending */</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> numvidtosend = <span class="number">1</span>;  <span class="comment">/* we always send DPD VID */</span></span><br><span class="line"><span class="comment">/*è‡³å°‘ä¼šå‘é€DPDçš„VID,å› æ­¤åˆå§‹å€¼ä¸º1*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL   <span class="comment">/*æ”¯æŒNAT-T,åˆ™å¢åŠ ä¸€ä¸ªnat-tæ¢æµ‹çš„VID*/</span></span></span><br><span class="line">    <span class="keyword">if</span> (md-&gt;quirks.nat_traversal_vid &amp;&amp; nat_traversal_enabled) &#123;</span><br><span class="line">	DBG(DBG_NATT, DBG_log(<span class="string">&quot;nat-t detected, sending nat-t VID&quot;</span>));</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*å¦‚æœé¢„å®šä¹‰äº†PLUUO VID æˆ–openpgp å¯¹ç«¯, å¢åŠ VID æ•°é‡*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SEND_PLUTO_VID || defined(openpgp_peer)</span></span><br><span class="line">    numvidtosend++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(openpgp_peer)</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">p</span>;</span></span><br><span class="line">	   <span class="comment">/*éå†æ¥æ”¶åˆ°çš„æ•°æ®åŒ…ä¸­çš„VID è½½è·é“¾è¡¨*/</span></span><br><span class="line">	    <span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_VID]; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">int</span> vid_len = <span class="keyword">sizeof</span>(pgp_vendorid) - <span class="number">1</span> &lt; pbs_left(&amp;p-&gt;pbs)</span><br><span class="line">			? <span class="keyword">sizeof</span>(pgp_vendorid) - <span class="number">1</span> : pbs_left(&amp;p-&gt;pbs);</span><br><span class="line"></span><br><span class="line">		    <span class="comment">/*æ£€æŸ¥æ˜¯å¦æ˜¯pgp VID, æ˜¯åˆ™è®¾ç½®openpgp_peer æ ‡å¿—ä¸ºTRUE*/</span></span><br><span class="line">		    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(pgp_vendorid, p-&gt;pbs.cur, vid_len) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			    openpgp_peer = TRUE;</span><br><span class="line">			    DBG(DBG_PARSING,</span><br><span class="line">				DBG_log(<span class="string">&quot;we have an OpenPGP peer&quot;</span>)</span><br><span class="line">				)</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*æ ¹æ®æ¥æ”¶åˆ°çš„æ•°æ®åŒ…çš„ç›®çš„åœ°å€,ç›®çš„ç«¯å£,æºåœ°å€,æºç«¯å£æŸ¥æ‰¾è¿æ¥ç»“æ„*/</span></span><br><span class="line">    <span class="comment">/* random source ports are handled by find_host_connection */</span></span><br><span class="line">    c = find_host_connection(ANY_MATCH, &amp;md-&gt;iface-&gt;ip_addr, pluto_port500</span><br><span class="line">                             , KH_IPADDR</span><br><span class="line">			     , &amp;md-&gt;sender</span><br><span class="line">			     , md-&gt;sender_port, LEMPTY, POLICY_IKEV1_DISABLE, &amp;policy_hint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>)<span class="comment">/*å¦‚æœæ²¡æ‰¾åˆ°*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream pre_sa_pbs = sa_pd-&gt;pbs;</span><br><span class="line">	<span class="keyword">lset_t</span> policy = preparse_isakmp_sa_body(&amp;pre_sa_pbs);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is XAUTH VID, copy it to policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (md-&gt;quirks.xauth_vid == TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">	  policy |= POLICY_XAUTH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* See if a wildcarded connection can be found.</span></span><br><span class="line"><span class="comment">	 * We cannot pick the right connection, so we&#x27;re making a guess.</span></span><br><span class="line"><span class="comment">	 * All Road Warrior connections are fair game:</span></span><br><span class="line"><span class="comment">	 * we pick the first we come across (if any).</span></span><br><span class="line"><span class="comment">	 * If we don&#x27;t find any, we pick the first opportunistic</span></span><br><span class="line"><span class="comment">	 * with the smallest subnet that includes the peer.</span></span><br><span class="line"><span class="comment">	 * There is, of course, no necessary relationship between</span></span><br><span class="line"><span class="comment">	 * an Initiator&#x27;s address and that of its client,</span></span><br><span class="line"><span class="comment">	 * but Food Groups kind of assumes one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">// å¯èƒ½æ˜¯é‚£ç§æœªå®šä¹‰å¯¹æ–¹åœ°å€çš„åŠ¨æ€è¿æ¥, å°†æºåœ°å€æ¡ä»¶ç½®ç©º,é‡æ–°æŸ¥æ‰¾è¿æ¥,</span></span><br><span class="line">       <span class="comment">// å¯èƒ½ä¼šæ‰¾åˆ°å¤šä¸ªè¿æ¥ç»“æ„,è¿”å›çš„æ˜¯ä¸€ä¸ªé“¾è¡¨</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">d</span>;</span></span><br><span class="line">	    d = find_host_connection(ANY_MATCH, &amp;md-&gt;iface-&gt;ip_addr, pluto_port500</span><br><span class="line">                                     , KH_ANY</span><br><span class="line">				     , (ip_address*)<span class="literal">NULL</span></span><br><span class="line">				     , md-&gt;sender_port, policy, POLICY_IKEV1_DISABLE, &amp;policy_hint);</span><br><span class="line">           <span class="comment">// éå†é“¾è¡¨</span></span><br><span class="line">	    <span class="keyword">for</span> (; d != <span class="literal">NULL</span>; d = d-&gt;IPhp_next)</span><br><span class="line">	    &#123;</span><br><span class="line">	       <span class="comment">// GROUP ç±»å‹è¿æ¥ä¸è€ƒè™‘</span></span><br><span class="line">		<span class="keyword">if</span> (d-&gt;kind == CK_GROUP)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="comment">/* ignore */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">// å¦‚æœè¿æ¥ç±»å‹ä¸ºæ¨¡æ¿å‹è€Œä¸”æ²¡å®šä¹‰OE, è¯¥è¿æ¥å¯ç”¨äºå¤„ç†è¯¥æ•°æ®åŒ…, è¿æ¥æ‰¾åˆ°,ä¸­æ–­å¾ªç¯</span></span><br><span class="line">		    <span class="keyword">if</span> (d-&gt;kind == CK_TEMPLATE &amp;&amp; !(d-&gt;policy &amp; POLICY_OPPO))</span><br><span class="line">		    &#123;</span><br><span class="line">			<span class="comment">/* must be Road Warrior: we have a winner */</span></span><br><span class="line">			c = d;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		    <span class="comment">/* Opportunistic or Shunt: pick tightest match */</span></span><br><span class="line">			<span class="comment">// æ¯”è¾ƒæ•°æ®åŒ…æºåœ°å€æ˜¯å¦åŒ¹é…è¿æ¥ä¸­å¯¹æ–¹åœ°å€çš„å®šä¹‰</span></span><br><span class="line">		    <span class="keyword">if</span> (addrinsubnet(&amp;md-&gt;sender, &amp;d-&gt;spd.that.client)</span><br><span class="line">		      <span class="comment">// è€Œä¸”ç›®å‰å¯ç”¨è¿æ¥ä¸ºç©º,æˆ–ç›®å‰å¯ç”¨è¿æ¥çš„åœ°å€èŒƒå›´æ¯”æ–°æ‰¾åˆ°çš„è¿æ¥èŒƒå›´å¤§, æ›´æ–°å¯ç”¨è¿æ¥</span></span><br><span class="line">		    &amp;&amp; (c == <span class="literal">NULL</span> || !subnetinsubnet(&amp;c-&gt;spd.that.client, &amp;d-&gt;spd.that.client)))</span><br><span class="line">			c = d;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// å¦‚æœæ²¡æ‰¾åˆ°è¿æ¥, è¯¥æ•°æ®åŒ…å¤„ç†ä¸äº†, è¿”å›å¿½ç•¥è¯¥æ•°æ®åŒ…</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		<span class="string">&quot; but no connection has been authorized%s%s&quot;</span></span><br><span class="line">		, ip_str(&amp;md-&gt;iface-&gt;ip_addr), ntohs(portof(&amp;md-&gt;iface-&gt;ip_addr))</span><br><span class="line">		, (policy != LEMPTY) ? <span class="string">&quot; with policy=&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">		, (policy != LEMPTY) ? bitnamesof(sa_policy_bit_names, policy) : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(policy_hint &amp; POLICY_IKEV1_DISABLE) &#123;</span><br><span class="line">                md-&gt;note = INVALID_MAJOR_VERSION;</span><br><span class="line">                <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* XXX notification is in order! */</span></span><br><span class="line">	    <span class="keyword">return</span> STF_IGNORE;</span><br><span class="line">	&#125;<span class="comment">/* å¦åˆ™å¦‚æœä¸æ˜¯æ¨¡æ¿ç±»å‹è¿æ¥(åŠ¨æ€è¿æ¥), è¿”å›å¿½ç•¥*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;kind != CK_TEMPLATE)</span><br><span class="line">	&#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		<span class="string">&quot; but \&quot;%s\&quot; forbids connection&quot;</span></span><br><span class="line">		, ip_str(&amp;md-&gt;iface-&gt;ip_addr), pluto_port500, c-&gt;name);</span><br><span class="line">	    <span class="comment">/* XXX notification is in order! */</span></span><br><span class="line">	    <span class="keyword">return</span> STF_IGNORE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* Create a temporary connection that is a copy of this one.</span></span><br><span class="line"><span class="comment">	     * His ID isn&#x27;t declared yet.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	   DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;instantiating \&quot;%s\&quot; for initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		, c-&gt;name, ip_str(&amp;md-&gt;iface-&gt;ip_addr), pluto_port500));</span><br><span class="line">	<span class="comment">// å°†æ¨¡æ¿è¿æ¥è¿›è¡Œå®ä¾‹åŒ–, æ ¹æ®æ¨¡æ¿è¿æ¥æ–°ç”Ÿæˆä¸€ä¸ªæ–°è¿æ¥ç»“æ„, å¡«å……å¯¹æ–¹åœ°å€</span></span><br><span class="line">	    c = rw_instantiate(c, &amp;md-&gt;sender</span><br><span class="line">			       , <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */</span></span><br><span class="line">	<span class="keyword">if</span> ((c-&gt;kind == CK_TEMPLATE) &amp;&amp; c-&gt;spd.that.virt) &#123;</span><br><span class="line">	   DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation&quot;</span>));</span><br><span class="line">	   c = rw_instantiate(c,&amp;md-&gt;sender,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_server || c-&gt;spd.<span class="keyword">this</span>.xauth_client)</span><br><span class="line">    &#123;</span><br><span class="line">        numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Set up state */</span></span><br><span class="line"><span class="comment">// æ–°åˆ†é…çŠ¶æ€ç»“æ„</span></span><br><span class="line">    md-&gt;st = st = new_state();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    passert(st-&gt;st_oakley.xauth == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    st-&gt;st_connection = c;</span><br><span class="line">    st-&gt;st_remoteaddr = md-&gt;sender;</span><br><span class="line">    st-&gt;st_remoteport = md-&gt;sender_port;</span><br><span class="line">    st-&gt;st_localaddr  = md-&gt;iface-&gt;ip_addr;</span><br><span class="line">    st-&gt;st_localport  = md-&gt;iface-&gt;port;</span><br><span class="line">    st-&gt;st_interface  = md-&gt;iface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKE version numbers -- used mostly in logging */</span></span><br><span class="line">    st-&gt;st_ike_maj        = md-&gt;maj;</span><br><span class="line">    st-&gt;st_ike_min        = md-&gt;min;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* (caller will reset cur_state) */</span></span><br><span class="line">    st-&gt;st_try = <span class="number">0</span>;	<span class="comment">/* not our job to try again from start */</span></span><br><span class="line">    st-&gt;st_policy = c-&gt;policy &amp; ~POLICY_IPSEC_MASK;	<span class="comment">/* only as accurate as connection */</span></span><br><span class="line">    <span class="comment">// çŠ¶æ€ç±»å‹ä¸ºR0(æ¥æ”¶åˆ°åˆå§‹åŒ–åŒ…)</span></span><br><span class="line">    change_state(st, STATE_MAIN_R0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¤åˆ¶å¯¹æ–¹çš„cookie</span></span><br><span class="line">    <span class="built_in">memcpy</span>(st-&gt;st_icookie, md-&gt;hdr.isa_icookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ç”Ÿæˆæœ¬åœ°çš„cookie</span></span><br><span class="line">    get_cookie(FALSE, st-&gt;st_rcookie, COOKIE_SIZE, &amp;md-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å°†æ–°çŠ¶æ€æ’å…¥åˆ°çŠ¶æ€å“ˆå¸Œè¡¨</span></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid (0) */</span></span><br><span class="line"></span><br><span class="line">    st-&gt;st_doi = ISAKMP_DOI_IPSEC;</span><br><span class="line">    st-&gt;st_situation = SIT_IDENTITY_ONLY; <span class="comment">/* We only support this */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the quirks we might have accumulated */</span></span><br><span class="line">	<span class="comment">// å¤åˆ¶ç‰¹æ®Šæ ‡å¿—</span></span><br><span class="line">    copy_quirks(&amp;st-&gt;quirks,&amp;md-&gt;quirks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;kind == CK_INSTANCE) &amp;&amp; (c-&gt;spd.that.host_port_specific))</span><br><span class="line">    &#123;</span><br><span class="line">       openswan_log(<span class="string">&quot;responding to Main Mode from unknown peer %s:%u&quot;</span></span><br><span class="line">	    , ip_str(&amp;c-&gt;spd.that.host_addr), c-&gt;spd.that.host_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;kind == CK_INSTANCE)</span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;responding to Main Mode from unknown peer %s&quot;</span></span><br><span class="line">	    , ip_str(&amp;c-&gt;spd.that.host_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;responding to Main Mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse_isakmp_sa also spits out a winning SA into our reply,</span></span><br><span class="line"><span class="comment">     * so we have to build our reply_stream and emit HDR before calling it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out.</span></span><br><span class="line"><span class="comment">     * We can&#x27;t leave this to comm_handle() because we must</span></span><br><span class="line"><span class="comment">     * fill in the cookie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// ä»¥ä¸‹å¼€å§‹å¡«å……è¦å‘é€çš„å›åº”åŒ…ä¿¡æ¯</span></span><br><span class="line">     </span><br><span class="line">    zero(reply_buffer);</span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// å¡«å……ISAKMPå¤´éƒ¨</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">r_hdr</span> =</span> md-&gt;hdr;</span><br><span class="line"></span><br><span class="line">	r_hdr.isa_flags &amp;= ~ISAKMP_FLAG_COMMIT;	<span class="comment">/* we won&#x27;t ever turn on this bit */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(r_hdr.isa_rcookie, st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line">	r_hdr.isa_np = ISAKMP_NEXT_SA;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;r_hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;md-&gt;rbody))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// å¡«å……SA ç»“æ„ä¿¡æ¯</span></span><br><span class="line">    <span class="comment">/* start of SA out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_sa</span> <span class="title">r_sa</span> =</span> sa_pd-&gt;payload.sa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we to send any VID, then set the NEXT payload correctly */</span></span><br><span class="line">	r_sa.isasa_np = numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;r_sa, &amp;isakmp_sa_desc, &amp;md-&gt;rbody, &amp;r_sa_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA body in and out */</span></span><br><span class="line">	<span class="comment">/*è§£æå¯¹æ–¹çš„SA,æ ¹æ®ä»–çš„å»ºè®®è½½è·æ¥ç¡®å®šæœ¬åœ°æ˜¯å¦æ”¯æŒï¼Œå¦‚æœæ”¯æŒåˆ™å›å¤æ”¯æŒçš„ç®—æ³•ä¿¡æ¯ï¼Œå¹¶æ„å»ºåº”ç­”SA*/</span></span><br><span class="line">    RETURN_STF_FAILURE(parse_isakmp_sa_body(&amp;sa_pd-&gt;pbs, &amp;sa_pd-&gt;payload.sa</span><br><span class="line">					    , &amp;r_sa_pbs, FALSE, st));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*å¡«å……VID*/</span></span><br><span class="line">    <span class="keyword">if</span> (SEND_PLUTO_VID || openpgp_peer)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> *vendorid = (openpgp_peer) ?</span><br><span class="line">	    pgp_vendorid : pluto_vendorid;</span><br><span class="line"></span><br><span class="line">	next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(next, &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody</span><br><span class="line">			     , vendorid, <span class="built_in">strlen</span>(vendorid), <span class="string">&quot;Vendor ID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * NOW SEND VENDOR ID payloads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/*å¡«å……DPD*/</span></span><br><span class="line">    <span class="comment">/* Announce our ability to do RFC 3706 Dead Peer Detection */</span></span><br><span class="line">    next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">    <span class="keyword">if</span>( !out_vid(next, &amp;md-&gt;rbody, VID_MISC_DPD))</span><br><span class="line">      <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="comment">/* If XAUTH is required, insert here Vendor ID */</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_server || c-&gt;spd.<span class="keyword">this</span>.xauth_client)</span><br><span class="line">    &#123;</span><br><span class="line">	    next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	    <span class="keyword">if</span> (!out_vendorid(next, &amp;md-&gt;rbody, VID_MISC_XAUTH))</span><br><span class="line">	       <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;sender checking NAT-T: %d and %d&quot;</span></span><br><span class="line">				, nat_traversal_enabled</span><br><span class="line">				, md-&gt;quirks.nat_traversal_vid));</span><br><span class="line">   <span class="comment">/*å¡«å……NAT-Tçš„VID*/</span></span><br><span class="line">    <span class="keyword">if</span> (md-&gt;quirks.nat_traversal_vid &amp;&amp; nat_traversal_enabled) &#123;</span><br><span class="line"></span><br><span class="line">        next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="comment">/* reply if NAT-Traversal draft is supported */</span></span><br><span class="line">	<span class="comment">/*nat_traversal_vid_to_method:å°†VIDè½¬æ¢ä¸ºå¯¹åº”çš„æ ‡å‡†*/</span></span><br><span class="line">	st-&gt;hidden_variables.st_nat_traversal = nat_traversal_vid_to_method(md-&gt;quirks.nat_traversal_vid);</span><br><span class="line">	<span class="comment">/*å¡«å……VIDè½½è·ï¼Œè¿™é‡Œçš„NAT-T VIDé€‰æ‹©çš„æ˜¯å¯¹æ–¹å‘æ¥çš„æœ€å¤§çš„NAT-T çš„VID,ä¹Ÿå°±æ˜¯è¯´é€‰ç”¨æœ€æ–°çš„NAT-Tæ ‡å‡†*/</span></span><br><span class="line">	<span class="keyword">if</span> ((st-&gt;hidden_variables.st_nat_traversal) &amp;&amp; (!out_vendorid(next,</span><br><span class="line">	    &amp;md-&gt;rbody, md-&gt;quirks.nat_traversal_vid))) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* if we are not 0 then something went very wrong above */</span></span><br><span class="line">    <span class="keyword">if</span>(numvidtosend != <span class="number">0</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;payload alignment problem please check the code in main_inI1_outR1 (num=%d)&quot;</span>, numvidtosend);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*åº”ç­”æŠ¥æ–‡å°è£…å®Œæ¯•ï¼Œå¡«å……é•¿åº¦å­—æ®µ*/</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save initiator SA for HASH */</span></span><br><span class="line">    clonereplacechunk(st-&gt;st_p1isa, sa_pd-&gt;pbs.start, pbs_room(&amp;sa_pd-&gt;pbs), <span class="string">&quot;sa in main_inI1_outR1()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-parse-isakmp-sa-body-æºç "><a href="#4-parse-isakmp-sa-body-æºç " class="headerlink" title="4. parse_isakmp_sa_body()æºç "></a>4. <code>parse_isakmp_sa_body()æºç </code></h3><p>æš‚ç•¥ã€‚</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬ä¸‰åŒ…ï¼šmain_inR1_outI2</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85%EF%BC%9Amain_inR1_outI2/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p><code>main_inR1_outI2()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­==ç¬¬ä¸‰åŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°çš„å…¥å£==ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inR1_outI2</code>çš„å‡½æ•°è°ƒç”¨å…³ç³»ã€å¤„ç†æµç¨‹ä»¥åŠå¯¹æºç çš„æ³¨é‡Šåˆ†æï¼Œå…³äº<code>main_inR1_outI2</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œä¸€ä¸ªå‡½æ•°æœ‰å‡ ç™¾è¡Œéƒ½æ˜¯å¾ˆå¸¸è§çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<p>å¯¹äºæºç çš„å­¦ä¹ ï¼Œæˆ‘å¹¶æ²¡æœ‰æŠŠæ¯ä¸€è¡Œè¿›è¡Œå¤‡æ³¨ï¼Œè€Œæ˜¯å°†è‡ªå·±è®¤ä¸ºçš„å…³é”®ç‚¹åšäº†æ³¨é‡Šæˆ–è€…æ ‡æ³¨ã€‚</p>
<hr>
<h3 id="2-å‡½æ•°è°ƒç”¨å…³ç³»"><a href="#2-å‡½æ•°è°ƒç”¨å…³ç³»" class="headerlink" title="2. å‡½æ•°è°ƒç”¨å…³ç³»"></a>2. å‡½æ•°è°ƒç”¨å…³ç³»</h3><blockquote>
<p>æ³¨æ„ï¼šè¿™é‡Œæˆ‘æŠŠæ”¶åˆ°å¯¹æ–¹æŠ¥æ–‡åçš„å¤„ç†æµç¨‹ä¹Ÿæ·»åŠ ä¸Šäº†ï¼Œä¸»è¦æ˜¯åœ¨å­¦ä¹ æºç è¿‡ç¨‹ä¸­é‡åˆ°<code>complete_v1_state_transition</code>æ‰§è¡Œäº†ä¸¤æ¬¡ã€‚ç¬¬äºŒæ¬¡ä¼šæ£€æµ‹ç¬¬ä¸€æ¬¡çš„è¿”å›å€¼ï¼Œå› æ­¤ä¸ä¼šé‡å¤çš„å‘é€æŠ¥æ–‡æ›´æ–°çŠ¶æ€ã€‚</p>
</blockquote>
<ul>
<li>process_v1_packet<ul>
<li>process_packet_tail<ul>
<li>smc-&gt;processor(md)<ul>
<li>main_inR1_outI2<ul>
<li>build_ke<ul>
<li>send_crypto_helper_request<ul>
<li>pluto_do_crypto_op</li>
<li>main_inR1_outI2_continue<ul>
<li>main_inR1_outI2_tail<ul>
<li>init_pbs</li>
<li>ship_KE</li>
<li>ship_nonce</li>
<li>nat_traversal_add_natd</li>
<li>close_message</li>
<li>insert_state</li>
</ul>
</li>
<li>complete_v1_state_transition</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>complete_v1_state_transition</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204847.png" alt="image-20200521075841786"></p>
<h3 id="3-ç¬¬ä¸‰ä¸ªæŠ¥æ–‡æµç¨‹å›¾"><a href="#3-ç¬¬ä¸‰ä¸ªæŠ¥æ–‡æµç¨‹å›¾" class="headerlink" title="3. ç¬¬ä¸‰ä¸ªæŠ¥æ–‡æµç¨‹å›¾"></a>3. ç¬¬ä¸‰ä¸ªæŠ¥æ–‡æµç¨‹å›¾</h3><p>ç”±äºç¬¬ä¸‰ä¸ªæŠ¥æ–‡çš„æ ¸å¿ƒå¤„ç†å‡½æ•°åŒ…å«å¤šä¸ªï¼Œä¸ä»…ä»…åŒ…å«<code>main_inR1_outI2</code>, å› æ­¤è¿™é‡Œä¼šå°†æ¶‰åŠçš„å…³é”®å‡½æ•°æ¥å£éƒ½æ·»åŠ åˆ°æµç¨‹å›¾ä¸­ï¼Œæ–¹ä¾¿æ ¹æ®å‡½æ•°å®šä½å¯¹åº”çš„åŠŸèƒ½ã€‚</p>
<hr>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>è§£æå¯¹ç«¯å‘é€çš„SAè½½è·ï¼Œç¡®å®šå¯¹ç«¯é€‰æ‹©çš„ç®—æ³•ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨çŠ¶æ€/è¿æ¥ä¸Š</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>ç”Ÿæˆç§˜é’¥äº¤æ¢ææ–™å’ŒNonceä¿¡æ¯</strong></li>
<li><input checked="" disabled="" type="checkbox"> ==æ„é€ åº”ç­”æŠ¥æ–‡(ç¬¬å››ä¸ªæŠ¥æ–‡ï¼‰==<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>å¡«å……KEè½½è·å’ŒNonceè½½è·</strong>ã€‚</li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204851.png" alt="image-20200520231919967"></p>
<h3 id="4-main-inR1-outI2æºç æ³¨é‡Š"><a href="#4-main-inR1-outI2æºç æ³¨é‡Š" class="headerlink" title="4. main_inR1_outI2æºç æ³¨é‡Š"></a>4. main_inR1_outI2æºç æ³¨é‡Š</h3><ul>
<li><input checked="" disabled="" type="checkbox"> è§£ææ”¶åˆ°çš„ç¬¬äºŒä¸ªæŠ¥æ–‡ï¼Œç¡®å®šå¯¹ç«¯é€‰æ‹©çš„ç®—æ³•ï¼Œå¹¶å°†ç®—æ³•å­˜å‚¨åœ¨çŠ¶æ€ç»“æ„ä¸Š</li>
<li><input checked="" disabled="" type="checkbox"> ç”³è¯·ç”Ÿæˆäº¤æ¢å¯†é’¥ä¿¡æ¯</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* verify echoed SA */</span></span><br><span class="line">    &#123;<span class="comment">/*md-&gt;chainä¸ºè§£æå®Œæ¯•çš„æ”¶åˆ°çš„æŠ¥æ–‡,ä¸‹æ ‡ä¸ºnpçš„å€¼*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sapd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*è§£æå¯¹ç«¯SA, ç”±äºæ— éœ€å¡«å……åº”ç­”SAå› æ­¤ç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºNULL*/</span></span><br><span class="line">	RETURN_STF_FAILURE(parse_isakmp_sa_body(&amp;sapd-&gt;pbs</span><br><span class="line">						, &amp;sapd-&gt;payload.sa</span><br><span class="line">						, <span class="literal">NULL</span>, TRUE, st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;sender checking NAT-T: %d and %d&quot;</span></span><br><span class="line">				 , nat_traversal_enabled</span><br><span class="line">				 , md-&gt;quirks.nat_traversal_vid))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled &amp;&amp; md-&gt;quirks.nat_traversal_vid) &#123;<span class="comment">/*è·å–NAT-Té‡‡ç”¨çš„æ ‡å‡†*/</span></span><br><span class="line">	st-&gt;hidden_variables.st_nat_traversal = nat_traversal_vid_to_method(md-&gt;quirks.nat_traversal_vid);</span><br><span class="line">	openswan_log(<span class="string">&quot;enabling possible NAT-traversal with method %s&quot;</span></span><br><span class="line">	     , bitnamesof(natt_type_bitnames, st-&gt;hidden_variables.st_nat_traversal));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">/*å¯†é’¥äº¤æ¢*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> alloc_thing(struct ke_continuation</span><br><span class="line">						 , <span class="string">&quot;outI2 KE&quot;</span>);</span><br><span class="line">	ke-&gt;md = md;</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_sec_in_use==FALSE);<span class="comment">/*æ˜¯å¦å·²ç»åŠ å¯†,æ˜¯çš„è¯ï¼ŒçŠ¶æ€æœ‰è¯¯ï¼Œè¿”å›é€€å‡º*/</span></span><br><span class="line">	pcrc_init(&amp;ke-&gt;ke_pcrc);</span><br><span class="line">	ke-&gt;ke_pcrc.pcrc_func = main_inR1_outI2_continue;</span><br><span class="line">	set_suspended(st, md);</span><br><span class="line">        <span class="comment">/*æ„å»ºç§˜é’¥äº¤æ¢è½½è·ä¿¡æ¯*/</span></span><br><span class="line">	<span class="keyword">return</span> build_ke(&amp;ke-&gt;ke_pcrc, st, st-&gt;st_oakley.group, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-build-keæºç æ³¨é‡Š"><a href="#5-build-keæºç æ³¨é‡Š" class="headerlink" title="5. build_keæºç æ³¨é‡Š"></a>5. build_keæºç æ³¨é‡Š</h2><ul>
<li><input checked="" disabled="" type="checkbox"> åˆå§‹åŒ–å¹¶å‘é€åŠ å¯†è¯·æ±‚<ul>
<li><input disabled="" type="checkbox"> ç”ŸæˆåŠ å¯†ææ–™ã€Nonceè½½è·ã€æ„å»ºåº”ç­”æŠ¥æ–‡åœ¨<code>send_crypto_helper_request</code>åŠå…¶ä»¥åã€‚</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> å®ŒæˆæŠ¥æ–‡å‘é€åçš„åç»­æ“ä½œ</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status <span class="title">build_ke</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">		    , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">const</span> struct oakley_group_desc *group</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">enum</span> crypto_importance importance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">rd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> *<span class="title">r</span> =</span> &amp;rd;</span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"><span class="comment">/*åˆå§‹åŒ–åŠ å¯†è¯·æ±‚*/</span></span><br><span class="line">    pcr_init(r, pcr_build_kenonce, importance);</span><br><span class="line">    r-&gt;pcr_d.kn.oakley_group   = group-&gt;group;</span><br><span class="line"></span><br><span class="line">    cn-&gt;pcrc_serialno = st-&gt;st_serialno;</span><br><span class="line">	<span class="comment">/*å‘é€åŠ å¯†è¯·æ±‚*/</span></span><br><span class="line">    e= send_crypto_helper_request(r, cn, &amp;toomuch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;<span class="comment">/*åŠ å¯†å¤±è´¥*/</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;<span class="comment">/*åŠ å¯†ä»»åŠ¡ç¹å¿™ï¼Œå…ˆæŒ‚èµ·ç­‰å¾…å†æ¬¡è°ƒåº¦*/</span></span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_v1_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 * ç”±äºæˆ‘ä»¬å·²ç»æ‰‹åŠ¨æ‰§è¡Œäº†main_inR1_outI2_continue(),è¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨åˆ°complete_v1_state_transition, å› æ­¤åœ¨(process_v1_state_xxxæµç¨‹ä¸­ä¸å¿…å†æ­¤æ‰§è¡ŒçŠ¶æ€è½¬æ¢å‡½æ•°ã€‚å› æ­¤è¿”å›STF_INLINEï¼Œå½“å†æ¬¡åˆ°complete_v1_state_transitionåˆ¤æ–­è¿”å›å€¼ä¸ºå®ƒï¼Œåˆ™ä¸å†æ‰§è¡Œæ­¤å‡½æ•°ã€‚)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-send-crypto-helper-requestæºç æ³¨é‡Š"><a href="#6-send-crypto-helper-requestæºç æ³¨é‡Š" class="headerlink" title="6. send_crypto_helper_requestæºç æ³¨é‡Š"></a>6. send_crypto_helper_requestæºç æ³¨é‡Š</h2><ul>
<li><input checked="" disabled="" type="checkbox"> ç”Ÿæˆç§˜é’¥ä¿¡æ¯(KEä¿¡æ¯ã€Nonceä¿¡æ¯)ï¼Œå¹¶å­˜å‚¨åœ¨rä¸­ï¼›</li>
<li><input checked="" disabled="" type="checkbox"> æ‰§è¡Œåç»­å¤„ç†å‡½æ•°ï¼š<code>main_inR1_outI2_continue</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this function is called with a request to do some cryptographic operations</span></span><br><span class="line"><span class="comment"> * along with a continuation structure, which will be used to deal with</span></span><br><span class="line"><span class="comment"> * the response.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This may fail if there are no helpers that can take any data, in which</span></span><br><span class="line"><span class="comment"> * case an error is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">err_t</span> <span class="title">send_crypto_helper_request</span><span class="params">(struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">				 , struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">				 , <span class="keyword">bool</span> *toomuch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_worker</span> *<span class="title">w</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do it all ourselves? */</span></span><br><span class="line">    <span class="keyword">if</span>(pc_workers == <span class="literal">NULL</span>) &#123;<span class="comment">/*æ®è¯´ä¸€èˆ¬ä¼šæ‰§è¡Œæ­¤åˆ†æ”¯*/</span></span><br><span class="line">	reset_cur_state();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*ç”Ÿæˆnonceå€¼ç›¸å…³*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LIBNSS</span></span><br><span class="line">	pluto_do_crypto_op(r,pc_helper_num);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	pluto_do_crypto_op(r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* call the continuation */</span></span><br><span class="line">	(*cn-&gt;pcrc_func)(cn, r, <span class="literal">NULL</span>);<span class="comment">//1 /*æ‰§è¡Œåç»­å‡½æ•°ï¼Œå¦‚main_inR1_outI2_continueç­‰*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* indicate that we did everything ourselves */</span></span><br><span class="line">	*toomuch = TRUE;</span><br><span class="line"></span><br><span class="line">	pfree(cn);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*åç»­ä»£ç å°šæœªæ•´ç†ï¼Œæš‚ä¸è€ƒè™‘*/</span></span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-send-crypto-helper-requestæºç æ³¨é‡Š"><a href="#7-send-crypto-helper-requestæºç æ³¨é‡Š" class="headerlink" title="7. send_crypto_helper_requestæºç æ³¨é‡Š"></a>7. send_crypto_helper_requestæºç æ³¨é‡Š</h2><ul>
<li><input checked="" disabled="" type="checkbox"> é€šè¿‡<code>main_inR1_outI2_tail</code>æ„å»ºåº”ç­”æŠ¥æ–‡</li>
<li><input checked="" disabled="" type="checkbox"> é€šè¿‡<code>complete_v1_state_transition</code>å®ŒæˆæŠ¥æ–‡çš„å‘é€å’Œåç»­çš„çŠ¶æ€åˆ‡æ¢ç­‰ã€‚</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STATE_MAIN_I1: HDR, SA --&gt; auth dependent</span></span><br><span class="line"><span class="comment"> * PSK_AUTH, DS_AUTH: --&gt; HDR, KE, Ni</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We do heavy computation here. For Main Mode, this is mostly okay,</span></span><br><span class="line"><span class="comment"> * since have already done a return routeability check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    stf_status e;</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">/*ä¸­é—´è°ƒè¯•ä¿¡æ¯ä»£ç ç•¥å»*/</span></span><br><span class="line"></span><br><span class="line">    e = main_inR1_outI2_tail(pcrc, r);<span class="comment">/*æ„é€ åº”ç­”æŠ¥æ–‡(ç¬¬å››åŒ…)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ke-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	complete_v1_state_transition(&amp;ke-&gt;md, e);<span class="comment">/*å®ŒæˆçŠ¶æ€è½¬æ¢ã€å‘é€æŠ¥æ–‡ï¼Œ...*/</span></span><br><span class="line">	<span class="keyword">if</span>(ke-&gt;md) release_md(ke-&gt;md);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-main-inR1-outI2-tailæºç æ³¨é‡Š"><a href="#8-main-inR1-outI2-tailæºç æ³¨é‡Š" class="headerlink" title="8. main_inR1_outI2_tailæºç æ³¨é‡Š"></a>8. main_inR1_outI2_tailæºç æ³¨é‡Š</h2><ul>
<li><input checked="" disabled="" type="checkbox"> æ„å»ºISAKMPå¤´éƒ¨ä¿¡æ¯</li>
<li><input checked="" disabled="" type="checkbox"> æ„å»ºKEè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> æ„å»ºNonceè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> æ„å»ºNAT-dè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> è½½è·æ·»åŠ å®Œæ¯•ï¼Œå…³é—­åº”ç­”buf, ç¡®å®šISAKMPæŠ¥æ–‡é•¿åº¦å¹¶å¡«å……é•¿åº¦å­—æ®µã€‚</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* STATE_MAIN_I1: HDR, SA --&gt; auth dependent</span></span><br><span class="line"><span class="comment"> * PSK_AUTH, DS_AUTH: --&gt; HDR, KE, Ni</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following are not yet implemented:</span></span><br><span class="line"><span class="comment"> * PKE_AUTH: --&gt; HDR, KE, [ HASH(1), ] &lt;IDi1_b&gt;PubKey_r, &lt;Ni_b&gt;PubKey_r</span></span><br><span class="line"><span class="comment"> * RPKE_AUTH: --&gt; HDR, [ HASH(1), ] &lt;Ni_b&gt;Pubkey_r, &lt;KE_b&gt;Ke_i,</span></span><br><span class="line"><span class="comment"> *                &lt;IDi1_b&gt;Ke_i [,&lt;&lt;Cert-I_b&gt;Ke_i]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We must verify that the proposal received matches one we sent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build output packet HDR;KE;Ni ****************/</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out.</span></span><br><span class="line"><span class="comment">     * We can&#x27;t leave this to comm_handle() because the isa_np</span></span><br><span class="line"><span class="comment">     * depends on the type of Auth (eventually).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*ä¸‹ä¸€ä¸ªè½½è·ï¼šå¯†é’¥äº¤æ¢. å¡«å……ISAKMPå¤´éƒ¨ä¿¡æ¯*/</span></span><br><span class="line">    echo_hdr(md, FALSE, ISAKMP_NEXT_KE);<span class="comment">/*reply_stream-----md-&gt;rbody*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE out */</span></span><br><span class="line"><span class="comment">/*å¡«å……å¯†é’¥äº¤æ¢è½½è·ï¼ŒåŒæ—¶çŠ¶æ€ä¸Šè®°å½•äº†å¯†é’¥çš„ç›¸å…³ä¿¡æ¯*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_KE(st, r , &amp;st-&gt;st_gi</span><br><span class="line">		 , &amp;md-&gt;rbody, ISAKMP_NEXT_NONCE))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*å¡«å……Nonceè½½è·*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* Ni out */</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;md-&gt;rbody</span><br><span class="line">		    , (cur_debugging &amp; IMPAIR_BUST_MI2)? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE</span><br><span class="line">		    , <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_debugging &amp; IMPAIR_BUST_MI2)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* generate a pointless large VID payload to push message over MTU */</span></span><br><span class="line">	pb_stream vid_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic(ISAKMP_NEXT_NONE, &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody</span><br><span class="line">	    , &amp;vid_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="keyword">if</span> (!out_zero(<span class="number">1500</span> <span class="comment">/*MTU?*/</span>, &amp;vid_pbs, <span class="string">&quot;Filler VID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;vid_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Ni out */</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;md-&gt;rbody, ISAKMP_NEXT_NONE, <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*å¡«å……NAT-Dè½½è·*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T checking st_nat_traversal for NAT_T_WITH_NATD&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">        DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T found NAT_T_WITH_NATD&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_add_natd(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, md))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish message æŠ¥æ–‡æ„å»ºç»“æŸï¼Œç¡®å®šæŠ¥æ–‡é•¿åº¦*/</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reinsert the state, using the responder cookie we just received */</span></span><br><span class="line">	<span class="comment">//å°†stä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤</span></span><br><span class="line">    unhash_state(st);<span class="comment">/*unhash_stateï¼šä½¿ç”¨äºŒçº§æŒ‡é’ˆä»åŒå‘é“¾è¡¨ä¸­åˆ é™¤stèŠ‚ç‚¹*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(st-&gt;st_rcookie, md-&gt;hdr.isa_rcookie, COOKIE_SIZE);</span><br><span class="line">	<span class="comment">/*é‡æ–°è®¡ç®—hashå€¼ï¼Œå¹¶æ’å…¥å…¨å±€çŠ¶æ€é“¾è¡¨ä¸­*/</span></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid (0) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-NAT-Dè½½è·ä¸­å“ˆå¸Œå€¼è¯´æ˜"><a href="#9-NAT-Dè½½è·ä¸­å“ˆå¸Œå€¼è¯´æ˜" class="headerlink" title="9. NAT-Dè½½è·ä¸­å“ˆå¸Œå€¼è¯´æ˜"></a>9. NAT-Dè½½è·ä¸­å“ˆå¸Œå€¼è¯´æ˜</h2><p>åœ¨NAT-Dè½½è·ä¸­ï¼Œhashå€¼çš„è®¡ç®—å…¬å¼ä¸ºï¼š<br>$$<br>HASH(CKY-I | CKY-R | IP | PORT)<br>$$<br>å³åˆ†åˆ«è®¡ç®—å‘èµ·è€…cookieã€ç›¸åº”è€…cookieã€IPã€ç«¯å£å››ä¸ªä¿¡æ¯çš„å“ˆå¸Œå€¼ã€‚å¯¹ç«¯æ”¶åˆ°åé€šè¿‡è®¡ç®—æŠ¥æ–‡ä¿¡æ¯çš„å“ˆå¸Œå€¼å’ŒæŠ¥æ–‡ä¸­çš„NAT-Dè½½è·çš„å“ˆå¸Œå€¼ç›¸æ¯”è¾ƒï¼Œä»¥æ­¤æ¥ç¡®å®šä¸­é—´æ˜¯å¦å­˜åœ¨NATè®¾å¤‡ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nat_traversal_add_natd</span><span class="params">(<span class="keyword">u_int8_t</span> np, pb_stream *outs,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nat_np;</span><br><span class="line">	<span class="keyword">const</span> ip_address *first, *second;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> firstport, secondport;</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_oakley.prf_hasher);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_EMITTING|DBG_NATT, DBG_log(<span class="string">&quot;sending NAT-D payloads&quot;</span>));</span><br><span class="line"></span><br><span class="line">	nat_np = (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_RFC_VALUES</span><br><span class="line">		  ? ISAKMP_NEXT_NATD_RFC : ISAKMP_NEXT_NATD_DRAFTS);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!out_modify_previous_np(nat_np, outs)) &#123;<span class="comment">/*ä¿®æ”¹ä¸Šä¸€ä¸ªè½½è·çš„npå­—æ®µ*/</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*è·å–æœ¬ç«¯å’Œå¯¹ç«¯çš„IPå’Œç«¯å£*/</span></span><br><span class="line">	first      = &amp;(md-&gt;sender);</span><br><span class="line">	firstport  = ntohs(st-&gt;st_remoteport);</span><br><span class="line">	second     = &amp;(md-&gt;iface-&gt;ip_addr);</span><br><span class="line">	secondport = ntohs(st-&gt;st_localport);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;forceencaps) &#123;<span class="comment">/*å¼ºåˆ¶å°è£…*/</span></span><br><span class="line">		DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T: forceencaps=yes, so mangling hash to force NAT-T detection&quot;</span>));</span><br><span class="line">		firstport=secondport=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * First one with sender IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*è®¡ç®—å¯¹ç«¯çš„å“ˆå¸Œå€¼: rcookie, icookie, ip, port*/</span></span><br><span class="line">        _natd_hash(st-&gt;st_oakley.prf_hasher, hash, st-&gt;st_icookie</span><br><span class="line">		       , is_zero_cookie(st-&gt;st_rcookie) ? md-&gt;hdr.isa_rcookie : st-&gt;st_rcookie</span><br><span class="line">		       , first, firstport);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(nat_np, &amp;isakmp_nat_d, outs</span><br><span class="line">			     , hash</span><br><span class="line">			     , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len</span><br><span class="line">			     , <span class="string">&quot;NAT-D&quot;</span>)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Second one with my IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*è®¡ç®—æœ¬ç«¯çš„å“ˆå¸Œå€¼: rcookie, icookie, ip, port*/</span></span><br><span class="line">        _natd_hash(st-&gt;st_oakley.prf_hasher, hash</span><br><span class="line">		       , st-&gt;st_icookie</span><br><span class="line">		       , is_zero_cookie(st-&gt;st_rcookie) ? md-&gt;hdr.isa_rcookie : st-&gt;st_rcookie</span><br><span class="line">		       , second, secondport);</span><br><span class="line">	<span class="keyword">return</span> (out_generic_raw(np, &amp;isakmp_nat_d, outs,</span><br><span class="line">		hash, st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len, <span class="string">&quot;NAT-D&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬å…­åŒ…(æ”¶åŒ…)ï¼šmain_inR3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%85%AD%E5%8C%85(%E6%94%B6%E5%8C%85)%EF%BC%9Amain_inR3/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p><code>main_inR3()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­==ç¬¬ä¸€é˜¶æ®µçš„æœ€åä¸€ä¸ªæŠ¥æ–‡çš„æ¥æ”¶å¤„ç†å‡½æ•°==ï¼Œå®ƒçš„ä½œç”¨åŒ<code>main_inI3_outR3()</code>éƒ¨åˆ†åŠŸèƒ½ç›¸åŒï¼šå®Œæˆå¯¹å¯¹ç«¯èº«ä»½çš„è®¤è¯ã€‚ä»–ä»¬çš„ä¸åŒä¹‹å¤„åœ¨äºä¸åœ¨éœ€è¦å“åº”æŠ¥æ–‡ï¼ˆå¦‚æœä¸è€ƒè™‘ç¬¬äºŒé˜¶æ®µçš„è¯ï¼‰ã€‚æ­¤åŒ…å¤„ç†å®Œæ¯•åï¼Œå‘èµ·ç«¯ä¾¿æˆåŠŸå»ºç«‹äº†ISAKMP SA, å®Œæˆäº†ç¬¬ä¸€é˜¶æ®µä¸»æ¨¡å¼çš„åå•†ã€‚åç»­ä¾¿æ˜¯ç¬¬äºŒé˜¶æ®µçš„åå•†ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inR3</code>çš„å‡½æ•°è°ƒç”¨å…³ç³»ã€å¤„ç†æµç¨‹ä»¥åŠå¯¹æºç çš„æ³¨é‡Šåˆ†æï¼Œå…³äº<code>main_inR3</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œæ­¤å‡½æ•°åœ¨åå•†çš„æŠ¥æ–‡å¤„ç†å‡½æ•°ä¸­æ¯”è¾ƒå¤æ‚çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<hr>
<p>ç›®å‰ä¸»è¦æ˜¯æ•´ç†æºç ä¸­çš„å¤„ç†é‡Œæµç¨‹å’Œå®ç°é€»è¾‘ï¼Œå°šæœªæ·±å…¥æ¯”è¾ƒç»†èŠ‚çš„å¤„ç†ï¼›åç»­åœ¨æˆ‘æ•´ç†å®Œæ¯•ä½¿ç”¨ä¸»æ¨¡å¼åå•†çš„9ä¸ªæŠ¥æ–‡åï¼Œæˆ‘å†æ¬¡ç»“åˆä»£ç æ•´ç†æ¯ä¸€ä¸ªæŠ¥æ–‡çš„è¯¦ç»†æµç¨‹ï¼Œåˆ°æ—¶æŠŠæ¯ä¸€ä¸ªæŠ¥æ–‡çš„æ³¨æ„äº‹é¡¹ã€ä½œç”¨ï¼Œå¤„ç†æ–¹å¼åšä¸€ä¸ªæ•´ä½“ä¸Šçš„æŠŠæ¡ã€‚åŒæ—¶ç»“åˆä¹¦æœ¬ä¸Šçš„æè¿°æ¥è§£é‡Šä»£ç å±‚çš„å®ç°ã€‚</p>
<hr>
<p>ISAKMPä¸»æ¨¡å¼åå•†æµç¨‹å¦‚ä¸‹ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204950.png" alt="image-20200606195135324"></p>
<p>æœ¬æ–‡è¦è¯´æ˜çš„ä¾¿æ˜¯ç¬¬â‘¥åŒ…çš„æ¥æ”¶å‡½æ•°ï¼š<code>main_inR3()</code>;</p>
<h3 id="2-å‡½æ•°è°ƒç”¨å…³ç³»"><a href="#2-å‡½æ•°è°ƒç”¨å…³ç³»" class="headerlink" title="2. å‡½æ•°è°ƒç”¨å…³ç³»"></a>2. å‡½æ•°è°ƒç”¨å…³ç³»</h3><p><code>main_inR3()</code>å‡½æ•°çš„è°ƒç”¨å±‚æ¬¡å°‘äº†å¾ˆå¤šï¼ˆå¦‚æœä¸è€ƒè™‘åŠ è§£å¯†ã€è¯ä¹¦è®¤è¯çš„è¯ï¼‰ï¼Œå®ƒçš„è°ƒç”¨å…³ç³»å›¾å¦‚ä¸‹æ‰€ç¤º</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204953.png" alt="image-20200606195717889"></p>
<h3 id="3-ç¬¬â‘¥ä¸ªæŠ¥æ–‡æ¥æ”¶æµç¨‹å›¾"><a href="#3-ç¬¬â‘¥ä¸ªæŠ¥æ–‡æ¥æ”¶æµç¨‹å›¾" class="headerlink" title="3. ç¬¬â‘¥ä¸ªæŠ¥æ–‡æ¥æ”¶æµç¨‹å›¾"></a>3. ç¬¬â‘¥ä¸ªæŠ¥æ–‡æ¥æ”¶æµç¨‹å›¾</h3><p><strong>ç¬¬â‘¥ä¸ªæŠ¥æ–‡çš„æ¥æ”¶æµç¨‹<code>main_inR3</code>çš„åŠŸèƒ½å¯ä»¥åˆ†ä¸ºä¸‰ç±»</strong>(å¦‚æœæŠŠå»ºç«‹ISAKMP SAä¹Ÿçœ‹ä½œä¸€ç±»çš„è¯)ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>è§£æå¯¹æ–¹çš„èº«ä»½æ ‡è¯†(ID)å’Œè¯ä¹¦è½½è·ï¼ŒåŒ¹é…å¯¹æ–¹çš„èº«ä»½æ ‡è¯†</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>èº«ä»½éªŒè¯</strong><ul>
<li><input checked="" disabled="" type="checkbox"> é¢„å…±äº«ç§˜é’¥</li>
<li><input checked="" disabled="" type="checkbox"> æ•°å­—è¯ä¹¦</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>å»ºç«‹ISAKMP SA</strong></li>
</ul>
<p>æµç¨‹å›¾ä¸‹å›¾ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204955.png" alt="image-20200606185131522"></p>
<h3 id="4-æºç åˆ†æ"><a href="#4-æºç åˆ†æ" class="headerlink" title="4. æºç åˆ†æ"></a>4. æºç åˆ†æ</h3><p>ç”±äº<code>main_R3()</code>çš„å¤„ç†æµç¨‹å’Œ<code>main_inI3_outR3()</code>ä¸­çš„éƒ¨åˆ†å¤„ç†æµç¨‹è°ƒç”¨äº†ç›¸åŒçš„å‡½æ•°æ¥å£ï¼Œå› æ­¤æ— éœ€å†è¿›è¡Œè¯´æ˜ï¼Œå¦‚æœæœ‰ç–‘é—®å¯ä»¥æŸ¥çœ‹<code>main_inI3_outR3()</code>çš„ä¸­çš„æºç éƒ¨åˆ†ã€‚</p>
<h3 id="5-æ€»ç»“"><a href="#5-æ€»ç»“" class="headerlink" title="5. æ€»ç»“"></a>5. æ€»ç»“</h3><p>openswançš„æºç ç¡®å®éš¾åº¦å¾ˆé«˜ï¼Œè™½ç„¶ç”¨äº†å¾ˆé•¿çš„æ—¶é—´æ¥çœ‹ä¸»æ¨¡å¼çš„6ä¸ªæŠ¥æ–‡7ä¸ªä¸»è¦çš„å‡½æ•°æ¥å£ï¼Œå‰åèŠ±è´¹äº†ä¸€ä¸ªæœˆæ—¶é—´å§ï¼ˆä¹‹å‰é™†é™†ç»­ç»­çœ‹è¿‡éƒ¨åˆ†æ¥å£ï¼‰ï¼Œä½†æ˜¯å­¦ä¹ çš„æ—¶å€™æ¯”è¾ƒæµ…ï¼Œæ²¡æœ‰æ·±å±‚æ¬¡çš„ç†è§£ã€‚æœ€ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  æŠ¥æ–‡çš„åŠ è§£å¯†</p>
<p>æŠ¥æ–‡åŠ å¯†ã€è§£å¯†æ˜¯åœ¨ç¬¬â‘¤â‘¥ä¸ªæŠ¥æ–‡ä¸­æ‰æœ‰çš„ï¼Œå…³äºè¿™éƒ¨åˆ†çš„åŠŸèƒ½ï¼ˆåŠ å¯†ã€å“ˆå¸Œã€æ•°å­—è¯ä¹¦ç­¾åéªŒç­¾ã€é¢„å…±äº«å¯†é’¥ç­‰ï¼‰ï¼ŒåªçŸ¥é“å®ƒæ˜¯åœ¨åšè¿™ç§å¤„ç†ï¼ŒåŸºæœ¬æ²¡æœ‰æ·±å…¥å»åˆ†æä»£ç ã€‚è¿™ä¸ªä¸»è¦æ˜¯ç”±äºçœ‹ä¸æ‡‚ï¼Œå†…å¿ƒé‡Œæœ‰ç§æŠµè§¦å¿ƒç†ï¼›å…¶æ¬¡æ˜¯ä¸æƒ³ç›´æ¥æ·±å…¥å­¦ä¹ è¿™éƒ¨åˆ†ï¼Œå…ˆå­¦ä¹ æ•´ä½“å¤„ç†æ¡†æ¶ï¼Œç„¶åå†æ…¢æ…¢æ·±å…¥å­¦ä¹ è¿™éƒ¨åˆ†åŠŸèƒ½ã€‚å³â€œ<strong>å…ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå†æ·±åº¦ä¼˜å…ˆæœç´¢</strong>â€</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ç®—æ³•ç›¸å…³çš„æ“ä½œ</p>
<p>è¿™é‡Œçš„ç®—æ³•ç›¸å…³ï¼Œæˆ‘æ˜¯æƒ³è¡¨è¾¾å¯¹äºç­–ç•¥çš„é…ç½®è§£æå­˜å‚¨ç®—æ³•ã€å¦‚ä½•ä¸æŠ¥æ–‡ä¸­çš„è½½è·ç›¸å¯¹åº”ã€æ”¯æŒçš„ç®—æ³•ç±»å‹ã€åå•†æ—¶å¤„ç†å¯¹æ–¹å»ºè®®è½½è·çš„åŸåˆ™ç­‰ç­‰é—®é¢˜ã€‚è¿™éƒ¨åˆ†æœ‰çš„å¯èƒ½å·²ç»åœ¨åå•†æµç¨‹ä¸­æœ‰æ‰€æ¶‰åŠï¼Œä½†æ˜¯å…³äºç®—æ³•çš„å­˜å‚¨ç­‰æ˜¯åœ¨è¿™éƒ¨åˆ†ä¹‹å‰çš„æµç¨‹ä¸­å¤„ç†çš„(<code>whack_handle()</code>)ï¼Œå› æ­¤æ²¡æœ‰è¿‡å¤šå­¦ä¹ ã€‚åé¢å†è¡¥å……whackå‘½ä»¤ç›¸å…³çš„çŸ¥è¯†ã€‚</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  è¿æ¥å’ŒçŠ¶æ€ä¹‹é—´çš„è”ç³»</p>
<p>ä¸»è¦çš„ç–‘æƒ‘æ˜¯ä¸æ¸…æ¥šä»–ä»¬æˆå‘˜ä¹‹é—´çš„å…³ç³»ï¼Œå¯èƒ½æ˜¯ç‰¹åˆ«å¤§ï¼ŒåŒæ—¶å…³ç³»æœ‰æ¯”è¾ƒå¤æ‚çš„ç¼˜æ•…ã€‚çŠ¶æ€æ˜¯ä¸€ä¸ªåŠ¨æ€çš„æ¦‚å¿µï¼Œå³åå•†è¿‡ç¨‹ä¸­çš„å‚æ•°ï¼›è¿æ¥æ˜¯æˆ‘ä»¬çš„éš§é“é…ç½®ä¿¡æ¯ï¼ŒåŸºæœ¬æ˜¯ä¸ªå›ºå®šçš„ç»“æ„ã€‚ä»–ä»¬æ˜¯å¦‚ä½•ç»´æŠ¤ã€ä»¥åŠåå•†è¿‡ç¨‹ä¸­å¦‚ä½•è”ç³»èµ·æ¥ï¼Œè¿™éƒ¨åˆ†æ²¡æœ‰ç³»ç»Ÿæ•´ç†å’Œåˆ†æè¿‡ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š<strong>NAT-Tåœ¨ISAKMPä¸­æ˜¯å¦‚ä½•å®Œæˆåå•†çš„ï¼Ÿ</strong> è¿™ä¸ªæˆ‘ä¹‹å‰å¤„ç†è¿‡ä¸€ä¸ªbug,å› æ­¤å¯èƒ½åˆ†æè¿‡åå•†è¿‡ç¨‹ä¸­çš„è”ç³»ï¼Œä½†æ˜¯å…¶ä»–çš„æˆ‘å°±ä¸å¾—è€ŒçŸ¥äº†ã€‚</p>
</li>
</ul>
<p><strong>ä»»é‡è€Œé“è¿œï¼Œç»§ç»­åŠªåŠ›å§ã€‚</strong></p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬äº”åŒ…ï¼šmain_inR2_outI3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%94%E5%8C%85%EF%BC%9Amain_inR2_outI3/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p><code>main_inR2_outI3()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­==ç¬¬äº”åŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°çš„å…¥å£==ï¼Œå‘èµ·ç«¯é€šè¿‡æ­¤åŒ…æ”¶åˆ°ç›¸åº”ç«¯çš„KEå€¼å’ŒNonceå€¼æ”¶åˆ°ï¼Œå¯ä»¥ç”Ÿæˆéœ€è¦çš„å¯†é’¥ä¿¡æ¯ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inR2_outI3</code>çš„å‡½æ•°è°ƒç”¨å…³ç³»ã€å¤„ç†æµç¨‹ä»¥åŠå¯¹æºç çš„æ³¨é‡Šåˆ†æï¼Œå…³äº<code>main_inR2_outI3</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œæ­¤å‡½æ•°åœ¨åå•†çš„æŠ¥æ–‡å¤„ç†å‡½æ•°ä¸­æ¯”è¾ƒå¤æ‚çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<p>å¯¹äºæºç çš„å­¦ä¹ ï¼Œæˆ‘å¹¶æ²¡æœ‰æŠŠæ¯ä¸€è¡Œè¿›è¡Œå¤‡æ³¨ï¼Œè€Œæ˜¯å°†è‡ªå·±è®¤ä¸ºçš„å…³é”®ç‚¹åšäº†æ³¨é‡Šæˆ–è€…æ ‡æ³¨ã€‚</p>
<span id="more"></span>

<hr>
<p>ç›®å‰ä¸»è¦æ˜¯æ•´ç†æºç ä¸­çš„å¤„ç†é‡Œæµç¨‹å’Œå®ç°é€»è¾‘ï¼Œå°šæœªæ·±å…¥æ¯”è¾ƒç»†èŠ‚çš„å¤„ç†ï¼›åç»­åœ¨æˆ‘æ•´ç†å®Œæ¯•ä½¿ç”¨ä¸»æ¨¡å¼åå•†çš„9ä¸ªæŠ¥æ–‡åï¼Œæˆ‘å†æ¬¡ç»“åˆä»£ç æ•´ç†æ¯ä¸€ä¸ªæŠ¥æ–‡çš„è¯¦ç»†æµç¨‹ï¼Œåˆ°æ—¶æŠŠæ¯ä¸€ä¸ªæŠ¥æ–‡çš„æ³¨æ„äº‹é¡¹ã€ä½œç”¨ï¼Œå¤„ç†æ–¹å¼åšä¸€ä¸ªæ•´ä½“ä¸Šçš„æŠŠæ¡ã€‚åŒæ—¶ç»“åˆä¹¦æœ¬ä¸Šçš„æè¿°æ¥è§£é‡Šä»£ç å±‚çš„å®ç°ã€‚</p>
<hr>
<h3 id="2-å‡½æ•°è°ƒç”¨å…³ç³»"><a href="#2-å‡½æ•°è°ƒç”¨å…³ç³»" class="headerlink" title="2.å‡½æ•°è°ƒç”¨å…³ç³»"></a>2.å‡½æ•°è°ƒç”¨å…³ç³»</h3><p>è¿™é‡Œæš‚æ—¶ç»™å‡ºxmindæ•´ç†çš„æ€ç»´å¯¼å›¾ã€‚</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204817.png" alt="image-20200524090446620"></p>
<h3 id="3-ç¬¬äº”ä¸ªæŠ¥æ–‡æµç¨‹å›¾"><a href="#3-ç¬¬äº”ä¸ªæŠ¥æ–‡æµç¨‹å›¾" class="headerlink" title="3. ç¬¬äº”ä¸ªæŠ¥æ–‡æµç¨‹å›¾"></a>3. ç¬¬äº”ä¸ªæŠ¥æ–‡æµç¨‹å›¾</h3><p>ç¬¬äº”ä¸ªæŠ¥æ–‡çš„å¤„ç†æµç¨‹ä¸»è¦åˆ†ä¸ºä¸‰ä¸ªå¤§åŠŸèƒ½ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>è§£ææ”¶åˆ°çš„å¯¹ç«¯æŠ¥æ–‡</strong><ul>
<li><input checked="" disabled="" type="checkbox"> å¯†é’¥äº¤æ¢è½½è·KE</li>
<li><input checked="" disabled="" type="checkbox"> Nonceè½½è·</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>ä½¿ç”¨DHç®—æ³•åˆ¶ä½œåŠ å¯†å¯†é’¥ã€è®¤è¯å¯†é’¥ã€å“ˆå¸Œå¯†é’¥ç­‰</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>æ„é€ åº”ç­”æŠ¥æ–‡ï¼ˆç¬¬äº”ä¸ªæŠ¥æ–‡ï¼‰</strong><ul>
<li><input checked="" disabled="" type="checkbox"> ç­¾å</li>
<li><input checked="" disabled="" type="checkbox"> æŠ¥æ–‡åŠ å¯†</li>
</ul>
</li>
</ul>
<img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%94%E5%8C%85%EF%BC%9Amain_inR2_outI3.assets%5Cimage-20200524091648492.png" alt="image-20200524091648492" style="zoom:200%;" />



<h3 id="4-main-inR2-outI3ï¼ˆï¼‰æºç å­¦ä¹ "><a href="#4-main-inR2-outI3ï¼ˆï¼‰æºç å­¦ä¹ " class="headerlink" title="4. main_inR2_outI3ï¼ˆï¼‰æºç å­¦ä¹ "></a>4. main_inR2_outI3ï¼ˆï¼‰æºç å­¦ä¹ </h3><p>è¯¥å‡½æ•°ä¸»è¦çš„åŠŸèƒ½æ˜¯ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> è§£æå¯¹ç«¯çš„KEè½½è·å’ŒNonceï¼Œå› ä¸ºè¿™æ˜¯åˆ¶ä½œå¯†é’¥çš„åŸºç¡€ææ–™ã€‚</li>
<li><input checked="" disabled="" type="checkbox"> è§£æå®Œæ¯•åï¼Œå¼€å§‹åˆ¶ä½œå¯†é’¥ã€‚</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span>;</span></span><br><span class="line">	<span class="comment">/*è·å–å—åˆ°çš„ç¬¬å››ä¸ªæŠ¥æ–‡ä¸­çš„KEè½½è·*/</span></span><br><span class="line">    pb_stream *<span class="keyword">const</span> keyex_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_KE]-&gt;pbs;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;</span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE in */</span><span class="comment">/*è§£æKEè½½è·å¹¶å­˜å‚¨åœ¨st-&gt;st_grä¸Š*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_KE(&amp;st-&gt;st_gr, <span class="string">&quot;Gr&quot;</span></span><br><span class="line">				 , st-&gt;st_oakley.group, keyex_pbs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nr in */</span><span class="comment">/*è§£æNonceè½½è·ï¼Œå¹¶å­˜å‚¨åœ¨st-&gt;st_nr*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_nr, <span class="string">&quot;Nr&quot;</span>));</span><br><span class="line"></span><br><span class="line">    dh = alloc_thing(struct dh_continuation, <span class="string">&quot;aggr outR1 DH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dh) &#123; <span class="keyword">return</span> STF_FATAL; &#125;</span><br><span class="line"></span><br><span class="line">    dh-&gt;md = md;</span><br><span class="line">    set_suspended(st, md);<span class="comment">/*æŒ‚èµ·å½“å‰æŠ¥æ–‡ï¼Œé˜²æ­¢ç”±äºè€—æ—¶æ“ä½œé‡æ–°æ”¶åˆ°å¯¹æ–¹çš„é‡å‘æŠ¥æ–‡*/</span></span><br><span class="line">    pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">    dh-&gt;dh_pcrc.pcrc_func = main_inR2_outI3_cryptotail;</span><br><span class="line">    <span class="keyword">return</span> start_dh_secretiv(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">			     , st-&gt;st_import</span><br><span class="line">			     , INITIATOR</span><br><span class="line">			     , st-&gt;st_oakley.group-&gt;group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-start-dh-secretivï¼ˆï¼‰æºç å­¦ä¹ "><a href="#5-start-dh-secretivï¼ˆï¼‰æºç å­¦ä¹ " class="headerlink" title="5. start_dh_secretivï¼ˆï¼‰æºç å­¦ä¹ "></a>5. start_dh_secretivï¼ˆï¼‰æºç å­¦ä¹ </h3><p>è¯¥å‡½æ•°çš„ä¸»è¦åŠŸèƒ½ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> è·å–åå•†çš„è®¤è¯ç®—æ³•ã€å“ˆå¸Œç®—æ³•ã€oakleyç¾¤ä¿¡æ¯</li>
<li><input checked="" disabled="" type="checkbox"> å‡†å¤‡Nonceã€KEã€cookieã€st_sec_chunkï¼ˆå¯†é’¥ä¿¡æ¯?ï¼‰</li>
<li><input checked="" disabled="" type="checkbox"> åˆ¶ä½œå¯†é’¥ï¼ˆè¯¥æµç¨‹ä¸­ä¼šé€šè¿‡å›è°ƒå‡½æ•°ç»„è£…æŠ¥æ–‡å¹¶å‘é€ï¼‰</li>
<li><input checked="" disabled="" type="checkbox"> å‘é€å®Œæ¯•æŠ¥æ–‡çš„åç»­å¤„ç†</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * invoke helper to do DH work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status <span class="title">start_dh_secretiv</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">			     , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">enum</span> crypto_importance importance</span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">enum</span> phase1_role init       <span class="comment">/* TRUE=g_init,FALSE=g_r */</span></span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">u_int16_t</span> oakley_group2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcr_skeyid_q</span> *<span class="title">dhq</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">chunk_t</span> *pss = get_preshared_secret(st-&gt;st_connection);<span class="comment">/*è·å–é¢„å…±äº«ç§˜é’¥*/</span></span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"></span><br><span class="line">    pcr_init(&amp;r, pcr_compute_dh_iv, importance);<span class="comment">/*ä½¿ç”¨DHç®—æ³•ç”Ÿæˆä¸‰æŠŠç§˜é’¥*/</span></span><br><span class="line"></span><br><span class="line">    dhq = &amp;r.pcr_d.dhq;</span><br><span class="line"></span><br><span class="line">    passert(st-&gt;st_sec_in_use);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert appropriate data to dhq */</span></span><br><span class="line">    dhq-&gt;auth = st-&gt;st_oakley.auth;</span><br><span class="line">    dhq-&gt;prf_hash = st-&gt;st_oakley.prf_hash;</span><br><span class="line">    dhq-&gt;oakley_group = oakley_group2;</span><br><span class="line">    dhq-&gt;init = init;</span><br><span class="line">    dhq-&gt;keysize = st-&gt;st_oakley.enckeylen/BITS_PER_BYTE;</span><br><span class="line"></span><br><span class="line">    passert(r.pcr_d.dhq.oakley_group != <span class="number">0</span>);</span><br><span class="line">    DBG(DBG_CONTROL | DBG_CRYPT,</span><br><span class="line">       DBG_log(<span class="string">&quot;parent1 type: %d group: %d len: %d\n&quot;</span>, r.pcr_type,</span><br><span class="line">	    r.pcr_d.dhq.oakley_group, (<span class="keyword">int</span>)r.pcr_len));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*å°†*pssçš„å†…å®¹æ‹·è´åˆ°dhq-&gt;spaceä¸­ï¼Œèµ·å§‹ä½ç½®æ˜¯thespaceï¼›åŒæ—¶å°†dhq-&gt;pssæŒ‡å‘spceå¯¹åº”çš„ç©ºé—´ã€‚ç„¶åæ›´æ–°thespace*/</span></span><br><span class="line">    <span class="keyword">if</span>(pss) &#123;</span><br><span class="line">	pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;pss, *pss);</span><br><span class="line">    &#125;</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;ni,  st-&gt;st_ni);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;nr,  st-&gt;st_nr);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;gi,  st-&gt;st_gi);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;gr,  st-&gt;st_gr);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space</span><br><span class="line">			   , &amp;dhq-&gt;secret, st-&gt;st_sec_chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*æœ€åå‘èµ·ç«¯å’Œç›¸åº”è€…Nonceã€KEç­‰ä¿¡æ¯å…¨éƒ¨æ‹·è´åˆ°äº†spaceä¸­*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LIBNSS</span></span><br><span class="line">    <span class="comment">/*copying required encryption algo*/</span></span><br><span class="line">    <span class="comment">/*dhq-&gt;encrypt_algo = st-&gt;st_oakley.encrypt;*/</span></span><br><span class="line">    dhq-&gt;encrypter = st-&gt;st_oakley.encrypter;</span><br><span class="line">    DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;Copying DH pub key pointer to be sent to a thread helper&quot;</span>));</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space , &amp;dhq-&gt;pubk, st-&gt;pubk);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*å°†å‘èµ·è€…ã€ç›¸åº”è€…cookieä¹Ÿæ‹·è´åˆ°dhq-&gt;spaceä¸­*/</span></span><br><span class="line">    pluto_crypto_allocchunk(&amp;dhq-&gt;thespace, &amp;dhq-&gt;icookie, COOKIE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(wire_chunk_ptr(dhq, &amp;dhq-&gt;icookie), st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line">    pluto_crypto_allocchunk(&amp;dhq-&gt;thespace, &amp;dhq-&gt;rcookie, COOKIE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(wire_chunk_ptr(dhq, &amp;dhq-&gt;rcookie)</span><br><span class="line">	   , st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*è‡³æ­¤ï¼Œå‘èµ·ç«¯å’Œç›¸åº”è€…Nonceã€KEã€cookieç­‰ä¿¡æ¯å…¨éƒ¨æ‹·è´åˆ°äº†spaceä¸­*/</span></span><br><span class="line">    passert(dhq-&gt;oakley_group != <span class="number">0</span>);</span><br><span class="line">    e = send_crypto_helper_request(&amp;r, cn, &amp;toomuch);<span class="comment">/*r ä¸­åŒ…å«ä¸Šè¿°ä¿¡æ¯ï¼Œç”¨æ¥ç”Ÿæˆä¸‰æŠŠç§˜é’¥*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;</span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-main-inR2-outI3-cryptotailï¼ˆï¼‰æºç å­¦ä¹ "><a href="#6-main-inR2-outI3-cryptotailï¼ˆï¼‰æºç å­¦ä¹ " class="headerlink" title="6. main_inR2_outI3_cryptotailï¼ˆï¼‰æºç å­¦ä¹ "></a>6. main_inR2_outI3_cryptotailï¼ˆï¼‰æºç å­¦ä¹ </h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3_cryptotail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			   , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			   , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> (struct dh_continuation *)pcrc;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> dh-&gt;md;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">  stf_status e;</span><br><span class="line"></span><br><span class="line">  DBG(DBG_CONTROLMORE</span><br><span class="line">      , DBG_log(<span class="string">&quot;main inR2_outI3: calculated DH, sending R1&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: Request was disconnected from state&quot;</span>,</span><br><span class="line">	      __FUNCTION__);</span><br><span class="line">      <span class="keyword">if</span> (dh-&gt;md)</span><br><span class="line">          release_md(dh-&gt;md);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  passert(cur_state == <span class="literal">NULL</span>);</span><br><span class="line">  passert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  passert(st-&gt;st_suspended_md == dh-&gt;md);</span><br><span class="line">  set_suspended(st, <span class="literal">NULL</span>);	<span class="comment">/* no longer connected or suspended */</span></span><br><span class="line"></span><br><span class="line">  set_cur_state(st);</span><br><span class="line">  st-&gt;st_calculating = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ugh) &#123;</span><br><span class="line">      loglog(RC_LOG_SERIOUS, <span class="string">&quot;failed in DH exponentiation: %s&quot;</span>, ugh);</span><br><span class="line">      e = STF_FATAL;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      e = main_inR2_outI3_continue(md, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dh-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      complete_v1_state_transition(&amp;dh-&gt;md, e);</span><br><span class="line">      <span class="keyword">if</span>(dh-&gt;md) release_md(dh-&gt;md);</span><br><span class="line">  &#125;</span><br><span class="line">  reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-main-inR2-outI3-cryptotailï¼ˆï¼‰æºç å­¦ä¹ "><a href="#7-main-inR2-outI3-cryptotailï¼ˆï¼‰æºç å­¦ä¹ " class="headerlink" title="7. main_inR2_outI3_cryptotailï¼ˆï¼‰æºç å­¦ä¹ "></a>7. main_inR2_outI3_cryptotailï¼ˆï¼‰æºç å­¦ä¹ </h3><p>è¯¥å‡½æ•°çš„ä¸»è¦åŠŸèƒ½æ˜¯ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> å°†åˆ¶ä½œçš„å¯†é’¥å­˜å‚¨åœ¨çŠ¶æ€ä¸Š</li>
<li><input checked="" disabled="" type="checkbox"> è§£æå¯¹æ–¹æŠ¥æ–‡ä¸­çš„è¯ä¹¦ï¼Œç¡®å®šæ˜¯å¦éœ€è¦å‘é€è¯ä¹¦è½½è·</li>
<li><input checked="" disabled="" type="checkbox"> æ„é€ IDæ ‡è¯†è½½è·ã€å¹¶è®¡ç®—å“ˆå¸Œ</li>
<li><input checked="" disabled="" type="checkbox"> å¦‚æœä½¿ç”¨å“ˆå¸Œè®¤è¯åˆ™å¡«å……å“ˆå¸Œè½½è·ï¼›å¦‚æœä½¿ç”¨ç­¾åè®¤è¯åˆ™è¿›è¡Œæ•°å­—ç­¾å</li>
<li><input checked="" disabled="" type="checkbox"> æŠ¥æ–‡åŠ å¯†</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* STATE_MAIN_I2:</span></span><br><span class="line"><span class="comment"> * SMF_PSK_AUTH: HDR, KE, Nr --&gt; HDR*, IDi1, HASH_I</span></span><br><span class="line"><span class="comment"> * SMF_DS_AUTH: HDR, KE, Nr --&gt; HDR*, IDi1, [ CERT, ] SIG_I</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following are not yet implemented.</span></span><br><span class="line"><span class="comment"> * SMF_PKE_AUTH: HDR, KE, &lt;IDr1_b&gt;PubKey_i, &lt;Nr_b&gt;PubKey_i</span></span><br><span class="line"><span class="comment"> *	    --&gt; HDR*, HASH_I</span></span><br><span class="line"><span class="comment"> * SMF_RPKE_AUTH: HDR, &lt;Nr_b&gt;PubKey_i, &lt;KE_b&gt;Ke_r, &lt;IDr1_b&gt;Ke_r</span></span><br><span class="line"><span class="comment"> *	    --&gt; HDR*, HASH_I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3_continue</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="comment">/*é€‰æ‹©è®¤è¯çš„è½½è·ç±»å‹:å“ˆå¸Œ\ç­¾å*/</span></span><br><span class="line">    <span class="keyword">int</span> auth_payload = st-&gt;st_oakley.auth == OAKLEY_PRESHARED_KEY</span><br><span class="line">	? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;</span><br><span class="line">    pb_stream id_pbs;	<span class="comment">/* ID Payload; also used for hash calculation */</span></span><br><span class="line">    <span class="keyword">bool</span> send_cert = FALSE;</span><br><span class="line">    <span class="keyword">bool</span> send_cr = FALSE;</span><br><span class="line">    generalName_t *requested_ca = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">cert_t</span> mycert = st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.cert;<span class="comment">/*è·å–è‡ªå·±çš„è¯ä¹¦*/</span></span><br><span class="line"></span><br><span class="line">    finish_dh_secretiv(st, r);<span class="comment">/*å°†DHäº§ç”Ÿçš„ä¸‰æŠŠç§˜é’¥å­˜å‚¨åœ¨ç»“æ„ä½“ä¸Š*/</span></span><br><span class="line">    <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decode certificate requests */</span></span><br><span class="line">    decode_cr(md, &amp;requested_ca);<span class="comment">/*è§£ææŠ¥æ–‡ä¸­çš„è¯ä¹¦è½½è·ï¼Œå¹¶ä½¿ç”¨requested_caé“¾èµ·æ¥*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(requested_ca != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	st-&gt;hidden_variables.st_got_certrequest = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * send certificate if we have one and auth is RSA, and we were</span></span><br><span class="line"><span class="comment">     * told we can send one if asked, and we were asked, or we were told</span></span><br><span class="line"><span class="comment">     * to always send one.</span></span><br><span class="line"><span class="comment">     * åŒæ—¶æ»¡è¶³ä¸‹é¢çš„æ¡ä»¶å†å‘é€è¯ä¹¦è½½è·:</span></span><br><span class="line"><span class="comment">     *		1. ä½¿ç”¨RSAç­¾å</span></span><br><span class="line"><span class="comment">     *		2. æœ¬ç«¯å¯¼å…¥äº†æ•°å­—è¯ä¹¦</span></span><br><span class="line"><span class="comment">     *		3. é…ç½®è¦æ±‚å‘é€è¯ä¹¦æˆ–å¼ºåˆ¶å‘é€è¯ä¹¦</span></span><br><span class="line"><span class="comment">     *		4. ä»å¯¹ç«¯æ”¶åˆ°äº†è¯ä¹¦</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    send_cert = st-&gt;st_oakley.auth == OAKLEY_RSA_SIG</span><br><span class="line">	&amp;&amp; mycert.type != CERT_NONE</span><br><span class="line">	&amp;&amp; ((st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert == cert_sendifasked</span><br><span class="line">	     &amp;&amp; st-&gt;hidden_variables.st_got_certrequest)</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_alwayssend</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_forcedtype);</span><br><span class="line"></span><br><span class="line">    doi_log_cert_thinking(md</span><br><span class="line">			  , st-&gt;st_oakley.auth</span><br><span class="line">			  , mycert.type</span><br><span class="line">			  , st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert</span><br><span class="line">			  , st-&gt;hidden_variables.st_got_certrequest</span><br><span class="line">			  , send_cert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send certificate request, if we don&#x27;t have a preloaded RSA public key */</span></span><br><span class="line">    send_cr = !no_cr_send &amp;&amp; send_cert &amp;&amp; !has_preloaded_public_key(st);<span class="comment">/*æ˜¯å¦å¯ä»¥å‘é€è¯ä¹¦*/</span></span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROL</span><br><span class="line">	, DBG_log(<span class="string">&quot; I am %ssending a certificate request&quot;</span></span><br><span class="line">		  , send_cr ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;not &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * free collected certificate requests since as initiator</span></span><br><span class="line"><span class="comment">     * we don&#x27;t heed them anyway</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    free_generalNames(requested_ca, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* done parsing; initialize crypto  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">      nat_traversal_natd_lookup(md);<span class="comment">/*æ£€æµ‹éš§é“ä¸¤ç«¯æ˜¯å¦ç»è¿‡NATç©¿è¶Š*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal) &#123;</span><br><span class="line">      nat_traversal_show_result(st-&gt;hidden_variables.st_nat_traversal</span><br><span class="line">				, md-&gt;sender_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_KA) &#123;</span><br><span class="line">      nat_traversal_new_ka_event();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************** build output packet HDR*;IDii;HASH/SIG_I ***************/</span></span><br><span class="line">    <span class="comment">/* ??? <span class="doctag">NOTE:</span> this is almost the same as main_inI3_outR3&#x27;s code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out done */</span></span><br><span class="line">	<span class="comment">/*HDRåœ¨å“ªé‡Œå®Œæˆå¡«å……çš„å‘¢???*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* IDii out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id_hd</span>;</span></span><br><span class="line">	<span class="keyword">chunk_t</span> id_b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*ä»çŠ¶æ€/è¿æ¥ä¸Šè·å–æœ¬ç«¯æ ‡è¯†ä¿¡æ¯*/</span></span><br><span class="line">	build_id_payload(&amp;id_hd, &amp;id_b, &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>);</span><br><span class="line">	id_hd.isaiid_np = (send_cert)? ISAKMP_NEXT_CERT : auth_payload;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;id_hd</span><br><span class="line">			, &amp;isakmp_ipsec_identification_desc</span><br><span class="line">			, &amp;md-&gt;rbody</span><br><span class="line">			, &amp;id_pbs)</span><br><span class="line">	    || !out_chunk(id_b, &amp;id_pbs, <span class="string">&quot;my identity&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CERT out */</span></span><br><span class="line">    <span class="keyword">if</span> (send_cert)</span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream cert_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_cert</span> <span class="title">cert_hd</span>;</span></span><br><span class="line">	cert_hd.isacert_np = (send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_SIG;</span><br><span class="line">	cert_hd.isacert_type = mycert.type;</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending my cert&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;cert_hd</span><br><span class="line">			, &amp;isakmp_ipsec_certificate_desc</span><br><span class="line">			, &amp;md-&gt;rbody</span><br><span class="line">			, &amp;cert_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mycert.forced) &#123;</span><br><span class="line">	  <span class="keyword">if</span> (!out_chunk(mycert.u.blob, &amp;cert_pbs, <span class="string">&quot;forced CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="keyword">if</span> (!out_chunk(get_mycert(mycert), &amp;cert_pbs, <span class="string">&quot;CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	close_output_pbs(&amp;cert_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CR out */</span><span class="comment">/*æ·»åŠ è¯ä¹¦è¯·æ±‚è½½è·,å³è¦æ±‚å¯¹å¯¹ç«¯è¿›è¡Œå‘é€è¯ä¹¦ä»¥æ±‚è®¤è¯...*/</span></span><br><span class="line">    <span class="keyword">if</span> (send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending a certificate request&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!build_and_ship_CR(mycert.type</span><br><span class="line">			       , st-&gt;st_connection-&gt;spd.that.ca</span><br><span class="line">			       , &amp;md-&gt;rbody, ISAKMP_NEXT_SIG))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;md-&gt;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find location of ID PBS */</span></span><br><span class="line">	tpm_findID(pbs, &amp;id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH_I or SIG_I out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char hash_val[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="keyword">size_t</span> hash_len = main_mode_hash(st, hash_val, TRUE, &amp;id_pbs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (auth_payload == ISAKMP_NEXT_HASH)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* HASH_I out */</span></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(ISAKMP_NEXT_NONE</span><br><span class="line">				 , &amp;isakmp_hash_desc</span><br><span class="line">				 , &amp;md-&gt;rbody</span><br><span class="line">				 , hash_val, hash_len, <span class="string">&quot;HASH_I&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* SIG_I out */</span></span><br><span class="line">	    u_char sig_val[RSA_MAX_OCTETS];</span><br><span class="line">	    <span class="keyword">size_t</span> sig_len = RSA_sign_hash(st-&gt;st_connection</span><br><span class="line">		, sig_val, hash_val, hash_len);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (sig_len == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;unable to locate my private key for RSA Signature&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + AUTHENTICATION_FAILED;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(ISAKMP_NEXT_NONE</span><br><span class="line">				 , &amp;isakmp_signature_desc</span><br><span class="line">				 , &amp;md-&gt;rbody</span><br><span class="line">				 , sig_val</span><br><span class="line">				 , sig_len</span><br><span class="line">				 , <span class="string">&quot;SIG_I&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* st_new_iv was computed by generate_skeyids_iv */</span></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬å…­åŒ…ï¼šmain_inI3_outR 3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%85%AD%E5%8C%85%EF%BC%9Amain_inI3_outR3/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p><code>main_inI3_outR3()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­==ç¬¬å…­åŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°çš„å…¥å£==ï¼Œç¬¬äº”å…­åŒ…ä¸»è¦ç”¨æ¥éªŒè¯å¯¹æ–¹çš„èº«ä»½ä¿¡æ¯ï¼ŒåŒæ—¶æ­¤æŠ¥æ–‡ä¹Ÿæ˜¯åŠ å¯†åçš„æŠ¥æ–‡ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inI3_outR3</code>çš„å‡½æ•°è°ƒç”¨å…³ç³»ã€å¤„ç†æµç¨‹ä»¥åŠå¯¹æºç çš„æ³¨é‡Šåˆ†æï¼Œå…³äº<code>main_inI3_outR3</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œæ­¤å‡½æ•°åœ¨åå•†çš„æŠ¥æ–‡å¤„ç†å‡½æ•°ä¸­æ¯”è¾ƒå¤æ‚çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<hr>
<p>ç›®å‰ä¸»è¦æ˜¯æ•´ç†æºç ä¸­çš„å¤„ç†é‡Œæµç¨‹å’Œå®ç°é€»è¾‘ï¼Œå°šæœªæ·±å…¥æ¯”è¾ƒç»†èŠ‚çš„å¤„ç†ï¼›åç»­åœ¨æˆ‘æ•´ç†å®Œæ¯•ä½¿ç”¨ä¸»æ¨¡å¼åå•†çš„9ä¸ªæŠ¥æ–‡åï¼Œæˆ‘å†æ¬¡ç»“åˆä»£ç æ•´ç†æ¯ä¸€ä¸ªæŠ¥æ–‡çš„è¯¦ç»†æµç¨‹ï¼Œåˆ°æ—¶æŠŠæ¯ä¸€ä¸ªæŠ¥æ–‡çš„æ³¨æ„äº‹é¡¹ã€ä½œç”¨ï¼Œå¤„ç†æ–¹å¼åšä¸€ä¸ªæ•´ä½“ä¸Šçš„æŠŠæ¡ã€‚åŒæ—¶ç»“åˆä¹¦æœ¬ä¸Šçš„æè¿°æ¥è§£é‡Šä»£ç å±‚çš„å®ç°ã€‚</p>
<hr>
<p>ç¬¬äº”å…­ä¸ªæŠ¥æ–‡çš„è½½è·å†…å®¹å¦‚ä¸‹ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205001.png" alt="image-20200605231831766"></p>
<h3 id="2-å‡½æ•°è°ƒç”¨å…³ç³»"><a href="#2-å‡½æ•°è°ƒç”¨å…³ç³»" class="headerlink" title="2.å‡½æ•°è°ƒç”¨å…³ç³»"></a>2.å‡½æ•°è°ƒç”¨å…³ç³»</h3><p>ç•¥ã€‚</p>
<h3 id="3-ç¬¬å…­ä¸ªæŠ¥æ–‡æµç¨‹å›¾"><a href="#3-ç¬¬å…­ä¸ªæŠ¥æ–‡æµç¨‹å›¾" class="headerlink" title="3. ç¬¬å…­ä¸ªæŠ¥æ–‡æµç¨‹å›¾"></a>3. ç¬¬å…­ä¸ªæŠ¥æ–‡æµç¨‹å›¾</h3><p>ç¬¬å…­ä¸ªæŠ¥æ–‡çš„å¤„ç†æµç¨‹å¯ä»¥åˆ†ä¸ºä¸‰ç±»ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>è§£æå¯¹æ–¹çš„èº«ä»½æ ‡è¯†(ID)å’Œè¯ä¹¦è½½è·ï¼ŒåŒ¹é…å¯¹æ–¹çš„èº«ä»½æ ‡è¯†</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>èº«ä»½éªŒè¯</strong><ul>
<li><input checked="" disabled="" type="checkbox"> é¢„å…±äº«ç§˜é’¥</li>
<li><input checked="" disabled="" type="checkbox"> æ•°å­—è¯ä¹¦</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>æ„å»ºåº”ç­”æŠ¥æ–‡</strong><ul>
<li><input checked="" disabled="" type="checkbox"> èº«ä»½æ ‡è¯†</li>
<li><input checked="" disabled="" type="checkbox"> è¯ä¹¦è½½è·</li>
<li><input checked="" disabled="" type="checkbox"> å¯¹æ•°æ®åŒ…è¿›è¡Œç­¾å</li>
<li><input checked="" disabled="" type="checkbox"> åŠ å¯†</li>
</ul>
</li>
</ul>
<p>æµç¨‹å›¾ä¸‹å›¾ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205004.png" alt="image-20200605232806235"></p>
<h3 id="4-main-inI3-outR3-tailæºç å­¦ä¹ "><a href="#4-main-inI3-outR3-tailæºç å­¦ä¹ " class="headerlink" title="4. main_inI3_outR3_tailæºç å­¦ä¹ "></a>4. main_inI3_outR3_tailæºç å­¦ä¹ </h3><p>å› ä¸º<code>main_inI3_outR3</code>ä¸­ç›´æ¥è°ƒç”¨äº†<code>main_inI3_outR3_tail</code>, æ•…è€Œç›´æ¥å°†<code>main_inI3_outR3_tail</code>çš„æºä»£ç è¿›è¡Œè¯´æ˜ï¼Œè€Œä¸å†ä»‹ç»<code>main_inI3_outR3</code>ã€‚</p>
<p>è¯¥å‡½æ•°çš„æ˜¯ç¬¬å…­åŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼Œå®ƒä¸­è°ƒç”¨äº†<code>main_id_and_auth()</code>å®Œæˆäº†å¯¹æ–¹çš„IDè½½è·ã€è¯ä¹¦è½½è·ç­‰çš„è§£æå’Œè®¤è¯å·¥ä½œã€‚</p>
<p>åœ¨è®¤è¯æˆåŠŸçš„å‰æä¸‹ï¼Œåœ¨ç»§ç»­æ„å»ºè‡ªå·²çš„åº”ç­”æŠ¥æ–‡ï¼Œå°†è‡ªå·±çš„èº«ä»½æ ‡è¯†ã€è¯ä¹¦ã€ç­¾åå€¼ç­‰è½½è·å°è£…ç„¶åå¯¹æŠ¥æ–‡è¿›è¡ŒåŠ å¯†ï¼Œæœ€åå‘é€ç»™éš§é“çš„å‘èµ·è€…ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI3_outR3_tail</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">, struct key_continuation *kc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    <span class="keyword">u_int8_t</span> auth_payload;</span><br><span class="line">    pb_stream r_id_pbs;	<span class="comment">/* ID Payload; also used for hash calculation */</span></span><br><span class="line">    <span class="keyword">cert_t</span> mycert;</span><br><span class="line">    <span class="keyword">bool</span> send_cert;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> np;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID and HASH_I or SIG_I in</span></span><br><span class="line"><span class="comment">     * Note: this may switch the connection being used!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	stf_status r = main_id_and_auth(md, FALSE</span><br><span class="line">					, main_inI3_outR3_continue</span><br><span class="line">					, kc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r != STF_OK)</span><br><span class="line">	    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send certificate if we have one and auth is RSA */</span></span><br><span class="line">    mycert = st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.cert;</span><br><span class="line"></span><br><span class="line">    send_cert = st-&gt;st_oakley.auth == OAKLEY_RSA_SIG</span><br><span class="line">	&amp;&amp; mycert.type != CERT_NONE</span><br><span class="line">	&amp;&amp; ((st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert == cert_sendifasked</span><br><span class="line">	     &amp;&amp; st-&gt;hidden_variables.st_got_certrequest)</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_alwayssend);</span><br><span class="line"></span><br><span class="line">    doi_log_cert_thinking(md</span><br><span class="line">			  , st-&gt;st_oakley.auth</span><br><span class="line">			  , mycert.type</span><br><span class="line">			  , st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert</span><br><span class="line">			  , st-&gt;hidden_variables.st_got_certrequest</span><br><span class="line">			  , send_cert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************** build output packet HDR*;IDir;HASH/SIG_R ***************/</span></span><br><span class="line">    <span class="comment">/* proccess_packet() would automatically generate the HDR*</span></span><br><span class="line"><span class="comment">     * payload if smc-&gt;first_out_payload is not ISAKMP_NEXT_NONE.</span></span><br><span class="line"><span class="comment">     * We don&#x27;t do this because we wish there to be no partially</span></span><br><span class="line"><span class="comment">     * built output packet if we need to suspend for asynch DNS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* ??? <span class="doctag">NOTE:</span> this is almost the same as main_inR2_outI3&#x27;s code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out</span></span><br><span class="line"><span class="comment">     * If auth were PKE_AUTH or RPKE_AUTH, ISAKMP_NEXT_HASH would</span></span><br><span class="line"><span class="comment">     * be first payload.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    echo_hdr(md, TRUE, ISAKMP_NEXT_ID);<span class="comment">/*å›è½¬æ•°æ®åŒ…å¤´;*/</span></span><br><span class="line"></span><br><span class="line">    auth_payload = st-&gt;st_oakley.auth == OAKLEY_PRESHARED_KEY</span><br><span class="line">	? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IDir out */</span><span class="comment">/*æ·»åŠ IDè½½è·*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* id_hd should be struct isakmp_id, but struct isakmp_ipsec_id</span></span><br><span class="line"><span class="comment">	 * allows build_id_payload() to work for both phases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id_hd</span>;</span></span><br><span class="line">		<span class="keyword">chunk_t</span> id_b;</span><br><span class="line"></span><br><span class="line">		build_id_payload(&amp;id_hd, &amp;id_b, &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>);</span><br><span class="line">		</span><br><span class="line">		id_hd.isaiid_np = (send_cert)? ISAKMP_NEXT_CERT : auth_payload;</span><br><span class="line">		<span class="keyword">if</span> (!out_struct(&amp;id_hd, &amp;isakmp_ipsec_identification_desc, &amp;md-&gt;rbody, &amp;r_id_pbs)<span class="comment">/*æ·»åŠ å¤´éƒ¨*/</span></span><br><span class="line">		|| !out_chunk(id_b, &amp;r_id_pbs, <span class="string">&quot;my identity&quot;</span>))<span class="comment">/*æ·»åŠ IDå†…å®¹*/</span></span><br><span class="line">		    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">		close_output_pbs(&amp;r_id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CERT out, if we have one */</span></span><br><span class="line">    <span class="keyword">if</span> (send_cert)<span class="comment">/*æ·»åŠ è¯ä¹¦è½½è·*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream cert_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_cert</span> <span class="title">cert_hd</span>;</span></span><br><span class="line">	cert_hd.isacert_np = ISAKMP_NEXT_SIG;</span><br><span class="line">	cert_hd.isacert_type = mycert.type;</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending my cert&quot;</span>);</span><br><span class="line">	<span class="comment">/*æ·»åŠ è¯ä¹¦å¤´éƒ¨æè¿°*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;cert_hd, &amp;isakmp_ipsec_certificate_desc, &amp;md-&gt;rbody, &amp;cert_pbs))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="comment">/*æ·»åŠ è¯ä¹¦ä¸»ä½“å†…å®¹*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_chunk(get_mycert(mycert), &amp;cert_pbs, <span class="string">&quot;CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;cert_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;md-&gt;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find location of ID PBS */</span></span><br><span class="line">	tpm_findID(pbs, &amp;r_id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKEv2 NOTIFY payload */</span></span><br><span class="line">    np = ISAKMP_NEXT_NONE;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;policy &amp; POLICY_IKEV2_ALLOW) &#123;</span><br><span class="line">	np = ISAKMP_NEXT_VID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH_R or SIG_R out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char hash_val[MAX_DIGEST_LEN];<span class="comment">/*è®¡ç®—IDè½½è·çš„hashå€¼*/</span></span><br><span class="line">	<span class="keyword">size_t</span> hash_len = main_mode_hash(st, hash_val, FALSE, &amp;r_id_pbs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (auth_payload == ISAKMP_NEXT_HASH)<span class="comment">/*å¦‚æœé‡‡ç”¨hashè¿›åˆ¶è®¤è¯*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* HASH_R out */</span><span class="comment">/*å¡«å……å“ˆå¸Œå€¼*/</span></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_hash_desc, &amp;md-&gt;rbody</span><br><span class="line">	    , hash_val, hash_len, <span class="string">&quot;HASH_R&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">/*åœ¨å“ˆå¸Œçš„åŸºç¡€ä¸Šå†è¿›è¡Œä¸€ä¸ªç­¾åé‡‡ç”¨ç­¾åè¿›åˆ¶è®¤è¯*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* SIG_R out */</span></span><br><span class="line">	    u_char sig_val[RSA_MAX_OCTETS];</span><br><span class="line">	    <span class="keyword">size_t</span> sig_len = RSA_sign_hash(st-&gt;st_connection</span><br><span class="line">		, sig_val, hash_val, hash_len);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (sig_len == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;unable to locate my private key for RSA Signature&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + AUTHENTICATION_FAILED;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_signature_desc<span class="comment">/*å¡«å……ç­¾åç­¾åä¿¡æ¯*/</span></span><br><span class="line">	    , &amp;md-&gt;rbody, sig_val, sig_len, <span class="string">&quot;SIG_R&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;policy &amp; POLICY_IKEV2_ALLOW) &#123;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, VID_MISC_IKEv2))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, sans fixed part of header */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last block of Phase 1 (R3), kept for Phase 2 IV generation */</span></span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;last encrypted block of Phase 1:&quot;</span></span><br><span class="line">	, st-&gt;st_new_iv, st-&gt;st_new_iv_len);</span><br><span class="line"><span class="comment">/*ä¿å­˜ç¬¬ä¸€é˜¶æ®µçš„IVä¿¡æ¯*/</span></span><br><span class="line">    st-&gt;st_ph1_iv_len = st-&gt;st_new_iv_len;</span><br><span class="line">    set_ph1_iv(st, st-&gt;st_new_iv);<span class="comment">/*è®¾ç½®åˆå§‹åŒ–å‘é‡*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It seems as per Cisco implementation, XAUTH and MODECFG</span></span><br><span class="line"><span class="comment">     * are not supposed to be performed again during rekey */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( st-&gt;st_connection-&gt;remotepeertype == CISCO &amp;&amp;</span><br><span class="line">	st-&gt;st_connection-&gt;newest_isakmp_sa != SOS_NOBODY &amp;&amp;</span><br><span class="line">        st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.xauth_client) &#123;</span><br><span class="line">           DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;Skipping XAUTH for rekey for Cisco Peer compatibility.&quot;</span>));</span><br><span class="line">           st-&gt;hidden_variables.st_xauth_client_done = TRUE;</span><br><span class="line">           st-&gt;st_oakley.xauth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.modecfg_client) &#123;</span><br><span class="line">                DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;Skipping ModeCFG for rekey for Cisco Peer compatibility.&quot;</span>));</span><br><span class="line">                st-&gt;hidden_variables.st_modecfg_vars_set = TRUE;</span><br><span class="line">                st-&gt;hidden_variables.st_modecfg_started = TRUE;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ISAKMP_SA_established(st-&gt;st_connection, st-&gt;st_serialno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ??? If st-&gt;st_connectionc-&gt;gw_info != NULL,</span></span><br><span class="line"><span class="comment">     * we should keep the public key -- it tested out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-oakley-id-and-authæºç å­¦ä¹ "><a href="#5-oakley-id-and-authæºç å­¦ä¹ " class="headerlink" title="5. oakley_id_and_authæºç å­¦ä¹ "></a>5. oakley_id_and_authæºç å­¦ä¹ </h3><p><code>oakley_id_and_auth()</code>å‡½æ•°çš„ä½œç”¨æ˜¯å¯¹ç¬¬äº”åŒ…ä¸­çš„èº«ä»½æ ‡è¯†ã€è¯ä¹¦è½½è·ã€è¯ä¹¦è¯·æ±‚è½½è·ç­‰è¿›è¡Œè§£æï¼Œå¹¶æ ¹æ®é…ç½®çš„è®¤è¯æ–¹å¼(<strong>é¢„å…±äº«ç§˜é’¥ã€æ•°å­—è¯ä¹¦</strong>)å®Œæˆå¯¹å¯¹ç«¯çš„è®¤è¯ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">oakley_id_and_auth</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">bool</span> initiator	<span class="comment">/* are we the Initiator? */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">bool</span> aggrmode                <span class="comment">/* aggressive mode? */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">cont_fn_t</span> cont_fn	<span class="comment">/* continuation function */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">const</span> struct key_continuation *kc	<span class="comment">/* current state, can be NULL */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    u_char hash_val[MAX_DIGEST_LEN];</span><br><span class="line">    <span class="keyword">size_t</span> hash_len;</span><br><span class="line">    stf_status r = STF_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;<span class="comment">/*å½“å‰æœ‰æ•°æ®åŒ…æ­£åœ¨å¤„ç†*/</span></span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//1 HDR*, IDii, [ CERT, ] SIG_I </span></span><br><span class="line">    <span class="comment">/* ID Payload in.</span></span><br><span class="line"><span class="comment">     * Note: this may switch the connection being used!</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">/*ä¸»åŠ¨æ¨¡å¼æ—¶ï¼Œéœ€è¦è§£æå¯¹ç«¯æ ‡è¯†ä¿¡æ¯;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!aggrmode &amp;&amp; !decode_peer_id(md, initiator, FALSE))</span><br><span class="line">	<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"><span class="comment">/*å¯¹æŠ¥æ–‡è¿›è¡ŒéªŒç­¾: </span></span><br><span class="line"><span class="comment">	1.è®¡ç®—å¯¹ç«¯IDçš„å“ˆå¸Œå€¼</span></span><br><span class="line"><span class="comment">	2. å¦‚æœä½¿ç”¨çš„å…±äº«ç§˜é’¥ï¼Œåˆ™æŠ¥æ–‡ä¸­ä½¿ç”¨hashç®—æ³•è¿›è¡Œç­¾åï¼Œå› æ­¤ç›´æ¥æ¯”è¾ƒå“ˆå¸Œå€¼æ˜¯å¦ä¸€è‡´å³å¯</span></span><br><span class="line"><span class="comment">	3. å¦‚æœä½¿ç”¨è¯ä¹¦çš„æ–¹å¼ï¼Œåˆ™éœ€è¦ä½¿ç”¨RSA....ç­‰è¿›è¡ŒéªŒç­¾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hash the ID Payload.</span></span><br><span class="line"><span class="comment">     * main_mode_hash requires idpl-&gt;cur to be at end of payload</span></span><br><span class="line"><span class="comment">     * so we temporarily set if so.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *idpl = &amp;md-&gt;chain[ISAKMP_NEXT_ID]-&gt;pbs;</span><br><span class="line">	<span class="keyword">u_int8_t</span> *old_cur = idpl-&gt;cur;</span><br><span class="line"></span><br><span class="line">	idpl-&gt;cur = idpl-&gt;roof;</span><br><span class="line">	hash_len = main_mode_hash(st, hash_val, !initiator, idpl);</span><br><span class="line">	idpl-&gt;cur = old_cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;st_oakley.auth)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OAKLEY_PRESHARED_KEY:<span class="comment">/*å…±äº«ç§˜é’¥è®¤è¯*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    pb_stream *<span class="keyword">const</span> hash_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_HASH]-&gt;pbs;<span class="comment">/*è·å–å“ˆå¸Œè½½è·çš„æ•°æ®éƒ¨åˆ†(å³å“ˆå¸Œå€¼)*/</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (pbs_left(hash_pbs) != hash_len</span><br><span class="line">	    || <span class="built_in">memcmp</span>(hash_pbs-&gt;cur, hash_val, hash_len) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;received HASH:&quot;</span></span><br><span class="line">		    , hash_pbs-&gt;cur, pbs_left(hash_pbs));</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;received Hash Payload does not match computed value&quot;</span>);</span><br><span class="line">		<span class="comment">/* XXX Could send notification back */</span></span><br><span class="line">		r = STF_FAIL + INVALID_HASH_INFORMATION;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OAKLEY_RSA_SIG:<span class="comment">/*æ•°å­—è¯ä¹¦è®¤è¯*/</span></span><br><span class="line">	r = RSA_check_signature(st, hash_val, hash_len</span><br><span class="line">	    , &amp;md-&gt;chain[ISAKMP_NEXT_SIG]-&gt;pbs</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">	    , kc == <span class="literal">NULL</span>? <span class="literal">NULL</span> : kc-&gt;ac.keys_from_dns</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_KEYRR */</span></span></span><br><span class="line">	    , kc == <span class="literal">NULL</span>? <span class="literal">NULL</span> : kc-&gt;ac.gateways_from_dns</span><br><span class="line">	    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r == STF_SUSPEND)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* initiate/resume asynchronous DNS lookup for key */</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">key_continuation</span> *<span class="title">nkc</span></span></span><br><span class="line"><span class="class">		=</span> alloc_thing(struct key_continuation, <span class="string">&quot;key continuation&quot;</span>);</span><br><span class="line">	    <span class="class"><span class="keyword">enum</span> <span class="title">key_oppo_step</span> <span class="title">step_done</span> =</span> kc == <span class="literal">NULL</span>? kos_null : kc-&gt;step;</span><br><span class="line">	    <span class="keyword">err_t</span> ugh;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Record that state is used by a suspended md */</span></span><br><span class="line">	    passert(st-&gt;st_suspended_md == <span class="literal">NULL</span>);</span><br><span class="line">	    set_suspended(st,md);</span><br><span class="line"></span><br><span class="line">	    nkc-&gt;failure_ok = FALSE;</span><br><span class="line">	    nkc-&gt;md = md;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">switch</span> (step_done)</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">case</span> kos_null:</span><br><span class="line">		<span class="comment">/* first try: look for the TXT records */</span></span><br><span class="line">		nkc-&gt;step = kos_his_txt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">		nkc-&gt;failure_ok = TRUE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ugh = start_adns_query(&amp;st-&gt;st_connection-&gt;spd.that.id</span><br><span class="line">				       , &amp;st-&gt;st_connection-&gt;spd.that.id	<span class="comment">/* SG itself */</span></span><br><span class="line">				       , ns_t_txt</span><br><span class="line">				       , cont_fn</span><br><span class="line">				       , &amp;nkc-&gt;ac);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">	    <span class="keyword">case</span> kos_his_txt:</span><br><span class="line">		<span class="comment">/* second try: look for the KEY records */</span></span><br><span class="line">		nkc-&gt;step = kos_his_key;</span><br><span class="line">		ugh = start_adns_query(&amp;st-&gt;st_connection-&gt;spd.that.id</span><br><span class="line">				       , <span class="literal">NULL</span>	<span class="comment">/* no sgw for KEY */</span></span><br><span class="line">				       , ns_t_key</span><br><span class="line">				       , cont_fn</span><br><span class="line">				       , &amp;nkc-&gt;ac);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_KEYRR */</span></span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">		bad_case(step_done);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (ugh != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		report_key_dns_failure(&amp;st-&gt;st_connection-&gt;spd.that.id, ugh);</span><br><span class="line">		set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">		r = STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * since this state is waiting for a DNS query, delete</span></span><br><span class="line"><span class="comment">		 * any events that might kill it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		delete_event(st);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	bad_case(st-&gt;st_oakley.auth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == STF_OK)</span><br><span class="line">	DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;authentication succeeded&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸»æ¨¡å¼ç¬¬å››åŒ…ï¼šmain_inI2_outR2</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%9B%9B%E5%8C%85%EF%BC%9Amain_inI2_outR2/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p><code>main_inI2_outR2()</code>å‡½æ•°æ˜¯ISAKMPåå•†è¿‡ç¨‹ä¸­==ç¬¬å››åŒ…çš„æ ¸å¿ƒå¤„ç†å‡½æ•°çš„å…¥å£==ï¼ŒåŒæ—¶åœ¨æ­¤å¤„ç†æµç¨‹ä¸­å·²ç»è·å–åˆ°è¶³å¤Ÿçš„éš§é“ä¿¡æ¯ï¼Œå¯ä»¥ç”Ÿæˆéœ€è¦çš„å¯†é’¥ä¿¡æ¯ã€‚è¿™é‡Œæˆ‘ä»¬ä¸»è¦è¯´æ˜<code>main_inI2_outR2</code>çš„å‡½æ•°è°ƒç”¨å…³ç³»ã€å¤„ç†æµç¨‹ä»¥åŠå¯¹æºç çš„æ³¨é‡Šåˆ†æï¼Œå…³äº<code>main_inI2_outR2</code>çš„ä¸Šä¸‹æ–‡ç¯å¢ƒæš‚ä¸å™è¿°ï¼Œç•™ç»™åé¢çš„æ–‡ç« è¿›è¡Œæ›´æ–°ã€‚</p>
<span id="more"></span>
<p>ISAKMPåå•†æŠ¥æ–‡çš„å¤„ç†æµç¨‹éƒ½æ¯”è¾ƒå¤æ‚ï¼Œæ­¤å‡½æ•°åœ¨åå•†çš„æŠ¥æ–‡å¤„ç†å‡½æ•°ä¸­æ¯”è¾ƒå¤æ‚çš„ï¼Œå› æ­¤ä¸ªäººå­¦ä¹ æœŸé—´éš¾å…æœ‰é—æ¼å’Œç†è§£é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·å¤§å®¶å¤šå¤šæ‰¹è¯„æŒ‡æ­£ã€‚</p>
<p>å¯¹äºæºç çš„å­¦ä¹ ï¼Œæˆ‘å¹¶æ²¡æœ‰æŠŠæ¯ä¸€è¡Œè¿›è¡Œå¤‡æ³¨ï¼Œè€Œæ˜¯å°†è‡ªå·±è®¤ä¸ºçš„å…³é”®ç‚¹åšäº†æ³¨é‡Šæˆ–è€…æ ‡æ³¨ã€‚</p>
<h3 id="2-å‡½æ•°è°ƒç”¨å…³ç³»"><a href="#2-å‡½æ•°è°ƒç”¨å…³ç³»" class="headerlink" title="2.å‡½æ•°è°ƒç”¨å…³ç³»"></a>2.å‡½æ•°è°ƒç”¨å…³ç³»</h3><p>æš‚ç•¥ã€‚(æ­¤æµç¨‹è°ƒç”¨æ¯”è¾ƒå¤šï¼Œåé¢ä¼šåœ¨è¡¥å……ä¸Š)</p>
<h3 id="3-ç¬¬å››ä¸ªæŠ¥æ–‡æµç¨‹å›¾"><a href="#3-ç¬¬å››ä¸ªæŠ¥æ–‡æµç¨‹å›¾" class="headerlink" title="3. ç¬¬å››ä¸ªæŠ¥æ–‡æµç¨‹å›¾"></a>3. ç¬¬å››ä¸ªæŠ¥æ–‡æµç¨‹å›¾</h3><p>ç¬¬å››ä¸ªæŠ¥æ–‡å¤„ç†æµç¨‹å¤§è‡´å¯ä»¥åˆ’åˆ†ä¸ºå››ç±»åŠŸèƒ½ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> è§£ææ”¶åˆ°çš„ç¬¬ä¸‰ä¸ªæŠ¥æ–‡å†…å®¹</li>
<li><input checked="" disabled="" type="checkbox"> ç”Ÿæˆéšæœºæ•°(æœ¬æ®µçš„KEå’ŒNonceå€¼)</li>
<li><input checked="" disabled="" type="checkbox"> æ„é€ åº”ç­”æŠ¥æ–‡</li>
<li><input checked="" disabled="" type="checkbox"> ä½¿ç”¨DHç®—æ³•åˆ¶ä½œç§˜é’¥(ä¸‰æŠŠé’¥åŒ™)</li>
</ul>
<p>æ•´ç†çš„å¤„ç†æµç¨‹å¦‚ä¸‹ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204827.png" alt="image-20200522000821053"></p>
<p>ä¸ªäººè§‰å¾—è¿™ä¸ªæµç¨‹åšçš„è¿˜æ˜¯å¾ˆæ¸…æ™°å’Œå‡†ç¡®çš„(åŸè°…æˆ‘æ²¡æœ‰ä¸Šè‰²)<img src="" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204834.gif" alt="img"></p>
<h3 id="4-main-inI2-outR2æºç åˆ†æ"><a href="#4-main-inI2-outR2æºç åˆ†æ" class="headerlink" title="4. main_inI2_outR2æºç åˆ†æ"></a>4. main_inI2_outR2æºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    pb_stream *keyex_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_KE]-&gt;pbs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;<span class="comment">/*ä¸ºäº†æ–¹å¼è¯¥æµç¨‹å¤„ç†æ—¶é—´è¿‡é•¿å¯¼è‡´å¯¹ç«¯è¶…æ—¶é‡å‘*/</span></span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE in */</span><span class="comment">/*ä»æŠ¥æ–‡ä¸­è·å–KEè½½è·ï¼Œå¹¶å¡«å……åˆ°st-&gt;st_giä¸Š*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_KE(&amp;st-&gt;st_gi, <span class="string">&quot;Gi&quot;</span></span><br><span class="line">				 , st-&gt;st_oakley.group, keyex_pbs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ni in */</span><span class="comment">/*ä»æŠ¥æ–‡ä¸­è·å–Nonceè½½è·ï¼Œå¹¶å¡«å……åˆ°st-&gt;st_niä¸Š*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_ni, <span class="string">&quot;Ni&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decode certificate requests */</span><span class="comment">/*è§£æè¯ä¹¦è½½è·ï¼Œä»¥é“¾è¡¨çš„æ–¹å¼å­˜å‚¨åœ¨st-&gt;st_connection-&gt;requested_ca*/</span></span><br><span class="line">    ikev1_decode_cr(md, &amp;st-&gt;st_connection-&gt;ikev1_requested_ca_names);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;requested_ca != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	st-&gt;hidden_variables.st_got_certrequest = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT</span><br><span class="line">	, DBG_log(<span class="string">&quot;inI2: checking NAT-T: %d and %d&quot;</span></span><br><span class="line">		  , nat_traversal_enabled</span><br><span class="line">		  , st-&gt;hidden_variables.st_nat_traversal));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">       DBG(DBG_NATT, DBG_log(<span class="string">&quot; NAT_T_WITH_NATD detected&quot;</span>));</span><br><span class="line">       nat_traversal_natd_lookup(md);<span class="comment">/*æ ¹æ®å“ˆå¸Œå€¼ç¡®å®šæ˜¯å¦ç»è¿‡NAT;çŠ¶æ€ä¸Šçš„NAT-Tæ ‡å¿—åœ¨æ­¤å¤„åšçš„ä¿®æ”¹*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal) &#123;<span class="comment">/*æ‰“å°NAT-Tã€ç«¯å£æµ®åŠ¨ç›¸å…³ä¿¡æ¯*/</span></span><br><span class="line">       nat_traversal_show_result(st-&gt;hidden_variables.st_nat_traversal</span><br><span class="line">				 , md-&gt;sender_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_KA) &#123;</span><br><span class="line">       DBG(DBG_NATT, DBG_log(<span class="string">&quot; NAT_T_WITH_KA detected&quot;</span>));</span><br><span class="line">       nat_traversal_new_ka_event();<span class="comment">/*æ·»åŠ NAT-Tçš„ä¿æ´»äº‹ä»¶*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> alloc_thing(struct ke_continuation</span><br><span class="line">					     , <span class="string">&quot;inI2_outR2 KE&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ke-&gt;md = md;</span><br><span class="line">	set_suspended(st, md);</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_sec_in_use == FALSE);</span><br><span class="line">	pcrc_init(&amp;ke-&gt;ke_pcrc);</span><br><span class="line">	ke-&gt;ke_pcrc.pcrc_func = main_inI2_outR2_continue;</span><br><span class="line">	<span class="keyword">return</span> build_ke(&amp;ke-&gt;ke_pcrc, st</span><br><span class="line">			, st-&gt;st_oakley.group, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-nat-traversal-natd-lookupæºç åˆ†æ"><a href="#5-nat-traversal-natd-lookupæºç åˆ†æ" class="headerlink" title="5. nat_traversal_natd_lookupæºç åˆ†æ"></a>5. nat_traversal_natd_lookupæºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*æ£€æŸ¥æ˜¯å¦éœ€è¦ç»è¿‡NAT-T*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nat_traversal_natd_lookup</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash_me[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash_him[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="keyword">bool</span> found_me = FALSE;</span><br><span class="line">	<span class="keyword">bool</span> found_him= FALSE;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	passert(st);</span><br><span class="line">	passert(md-&gt;iface);</span><br><span class="line">	passert(st-&gt;st_oakley.prf_hasher);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Count NAT-D **/</span></span><br><span class="line">	<span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_NATD_RFC], i=<span class="number">0</span>;</span><br><span class="line">	     p != <span class="literal">NULL</span>;</span><br><span class="line">	     p = p-&gt;next, i++);<span class="comment">/*ç»Ÿè®¡NAT-Dçš„æ•°é‡*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * We need at least 2 NAT-D (1 for us, many for peer)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS,</span><br><span class="line">		<span class="string">&quot;NAT-Traversal: Only %d NAT-D - Aborting NAT-Traversal negotiation&quot;</span>, i);</span><br><span class="line">		st-&gt;hidden_variables.st_nat_traversal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * First one with my IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	_natd_hash(st-&gt;st_oakley.prf_hasher, hash_me</span><br><span class="line">		   , st-&gt;st_icookie, st-&gt;st_rcookie</span><br><span class="line">		   , &amp;(md-&gt;iface-&gt;ip_addr)</span><br><span class="line">		   , ntohs(md-&gt;iface-&gt;port));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The others with sender IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	_natd_hash(st-&gt;st_oakley.prf_hasher, hash_him</span><br><span class="line">		   , st-&gt;st_icookie, st-&gt;st_rcookie</span><br><span class="line">		   , &amp;(md-&gt;sender), ntohs(md-&gt;sender_port));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_NATD_RFC], i=<span class="number">0</span>;</span><br><span class="line">	     p != <span class="literal">NULL</span> &amp;&amp; (!found_me || !found_him);</span><br><span class="line">	     p = p-&gt;next)</span><br><span class="line">	  &#123;</span><br><span class="line">	    DBG(DBG_NATT,</span><br><span class="line">		DBG_log(<span class="string">&quot;NAT_TRAVERSAL hash=%d (me:%d) (him:%d)&quot;</span></span><br><span class="line">			, i, found_me, found_him);</span><br><span class="line">		DBG_dump(<span class="string">&quot;expected NAT-D(me):&quot;</span>, hash_me,</span><br><span class="line">			 st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len);</span><br><span class="line">		DBG_dump(<span class="string">&quot;expected NAT-D(him):&quot;</span>, hash_him,</span><br><span class="line">			 st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len);</span><br><span class="line">		DBG_dump(<span class="string">&quot;received NAT-D:&quot;</span>, p-&gt;pbs.cur, pbs_left(&amp;p-&gt;pbs));</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ( (pbs_left(&amp;p-&gt;pbs) == st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)</span><br><span class="line">		 &amp;&amp; (<span class="built_in">memcmp</span>(p-&gt;pbs.cur, hash_me</span><br><span class="line">			    , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)==<span class="number">0</span>))</span><br><span class="line">	      &#123;</span><br><span class="line">		found_me = TRUE;<span class="comment">/*æœ¬ç«¯æœªç»è¿‡NAT*/</span></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ( (pbs_left(&amp;p-&gt;pbs) == st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)</span><br><span class="line">		 &amp;&amp; (<span class="built_in">memcmp</span>(p-&gt;pbs.cur, hash_him</span><br><span class="line">			    , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)==<span class="number">0</span>))</span><br><span class="line">	      &#123;</span><br><span class="line">		found_him = TRUE;<span class="comment">/*å¯¹ç«¯æœªç»è¿‡NAT*/</span></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    i++;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	DBG(DBG_NATT,</span><br><span class="line">	    DBG_log(<span class="string">&quot;NAT_TRAVERSAL hash=%d (me:%d) (him:%d)&quot;</span></span><br><span class="line">		    , i, found_me, found_him));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!found_me) &#123;</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_ME);<span class="comment">/*æœ¬ç«¯ç»è¿‡NAT*/</span></span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;st-&gt;hidden_variables.st_natd,<span class="number">0</span>,<span class="keyword">sizeof</span>(st-&gt;hidden_variables.st_natd));</span><br><span class="line">	anyaddr(AF_INET, &amp;st-&gt;hidden_variables.st_natd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!found_him) &#123;</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_PEER);<span class="comment">/*å¯¹ç«¯ç»è¿‡NAT*/</span></span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;forceencaps) &#123;<span class="comment">/*å¦‚æœéœ€è¦å¼ºåˆ¶ä½¿ç”¨UDPå°è£…åŒæ–¹éƒ½éœ€è¦NAT-D*/</span></span><br><span class="line">	    DBG(DBG_NATT,</span><br><span class="line">		DBG_log(<span class="string">&quot;NAT_TRAVERSAL forceencaps enabled&quot;</span>));</span><br><span class="line"></span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_PEER);</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_ME);</span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-build-keæºç åˆ†æ"><a href="#6-build-keæºç åˆ†æ" class="headerlink" title="6. build_keæºç åˆ†æ"></a>6. build_keæºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status <span class="title">build_ke</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">		    , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">const</span> struct oakley_group_desc *group</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">enum</span> crypto_importance importance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">rd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> *<span class="title">r</span> =</span> &amp;rd;</span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"><span class="comment">/*åˆå§‹åŒ–åŠ å¯†è¯·æ±‚*/</span></span><br><span class="line">    pcr_init(r, pcr_build_kenonce, importance);</span><br><span class="line">    r-&gt;pcr_d.kn.oakley_group   = group-&gt;group;</span><br><span class="line"></span><br><span class="line">    cn-&gt;pcrc_serialno = st-&gt;st_serialno;</span><br><span class="line">	<span class="comment">/*ç”³è¯·åˆ¶ä½œåŠ å¯†ææ–™è¯·æ±‚*/</span></span><br><span class="line">    e= send_crypto_helper_request(r, cn, &amp;toomuch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;<span class="comment">/*åŠ å¯†å¤±è´¥*/</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;<span class="comment">/*åŠ å¯†ä»»åŠ¡ç¹å¿™ï¼Œå…ˆæŒ‚èµ·ç­‰å¾…å†æ¬¡è°ƒåº¦*/</span></span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_v1_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 * ç”±äºæˆ‘ä»¬å·²ç»æ‰‹åŠ¨æ‰§è¡Œäº†main_inR1_outI2_continue(),è¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨åˆ°complete_v1_state_transition</span></span><br><span class="line"><span class="comment">	 * å› æ­¤åœ¨(process_v1_state_xxxæµç¨‹ä¸­ä¸å¿…å†æ­¤æ‰§è¡ŒçŠ¶æ€è½¬æ¢å‡½æ•°ã€‚å› æ­¤è¿”å›STF_INLINEï¼Œå½“å†æ¬¡åˆ°complete_v1_state_transition</span></span><br><span class="line"><span class="comment">	 *åˆ¤æ–­è¿”å›å€¼ä¸ºå®ƒï¼Œåˆ™ä¸å†æ‰§è¡Œæ­¤å‡½æ•°ã€‚)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-main-inI2-outR2-continueæºç åˆ†æ"><a href="#7-main-inI2-outR2-continueæºç åˆ†æ" class="headerlink" title="7. main_inI2_outR2_continueæºç åˆ†æ"></a>7. main_inI2_outR2_continueæºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    stf_status e;</span><br><span class="line">    ... ... </span><br><span class="line">    set_suspended(st, <span class="literal">NULL</span>);	<span class="comment">/* no longer connected or suspended */</span></span><br><span class="line"></span><br><span class="line">    set_cur_state(st);</span><br><span class="line"></span><br><span class="line">    st-&gt;st_calculating = FALSE;</span><br><span class="line">    e = main_inI2_outR2_tail(pcrc, r);<span class="comment">/*æ„é€ åº”ç­”æŠ¥æ–‡*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ke-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        complete_v1_state_transition(&amp;ke-&gt;md, e);<span class="comment">/*å‘é€æŠ¥æ–‡å¹¶å®Œååç»­å¤„ç†å·¥ä½œ*/</span></span><br><span class="line">        <span class="keyword">if</span>(ke-&gt;md) release_md(ke-&gt;md);</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-main-inI2-outR2-tailæºç åˆ†æ"><a href="#8-main-inI2-outR2-tailæºç åˆ†æ" class="headerlink" title="8. main_inI2_outR2_tailæºç åˆ†æ"></a>8. main_inI2_outR2_tailæºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this routine gets called after any DH exponentiation that needs to be done</span></span><br><span class="line"><span class="comment"> * has been done, and we are ready to send our g^y.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send CR if auth is RSA and no preloaded RSA public key exists*/</span></span><br><span class="line">    <span class="keyword">bool</span> send_cr = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build output packet HDR;KE;Nr ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*å¦‚æœä»¥ä¸‹å››ä¸ªæ¡ä»¶åŒæ—¶æ»¡è¶³ï¼Œåˆ™é€šè¿‡éœ€è¦å‘é€è¯ä¹¦ã€‚ã€‚*/</span></span><br><span class="line">    send_cr = !no_cr_send							<span class="comment">/*é…ç½®ä¸­å…è®¸å‘é€è¯ä¹¦*/</span></span><br><span class="line">	&amp;&amp; (st-&gt;st_oakley.auth == OAKLEY_RSA_SIG)		<span class="comment">/*ä½¿ç”¨RSAç­¾å*/</span></span><br><span class="line">	&amp;&amp; !has_preloaded_public_key(st)				<span class="comment">/*æœªåŠ è½½æœªå…±äº«ç§˜é’¥*/</span></span><br><span class="line">	&amp;&amp; st-&gt;st_connection-&gt;spd.that.ca.ptr != <span class="literal">NULL</span>;	<span class="comment">/*å¯¹ç«¯è¯ä¹¦éç©º*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out */</span></span><br><span class="line">    echo_hdr(md, FALSE, ISAKMP_NEXT_KE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE out */</span><span class="comment">/*æ·»åŠ KEè½½è·ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨st-&gt;st_gr*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_KE(st, r, &amp;st-&gt;st_gr</span><br><span class="line">		 , &amp;md-&gt;rbody, ISAKMP_NEXT_NONCE))</span><br><span class="line">	&#123;</span><br><span class="line">	    osw_abort();</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">/* Nr out */</span></span><br><span class="line">    <span class="keyword">int</span> next_payload;</span><br><span class="line">    next_payload = ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur_debugging &amp; IMPAIR_BUST_MR2)</span><br><span class="line">    &#123;</span><br><span class="line">	next_payload = ISAKMP_NEXT_VID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">        next_payload = ISAKMP_NEXT_CR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_nr, r</span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , next_payload</span><br><span class="line">		    , <span class="string">&quot;Nr&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_debugging &amp; IMPAIR_BUST_MR2)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* generate a pointless large VID payload to push message over MTU */</span></span><br><span class="line">	pb_stream vid_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic((send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_NONE,</span><br><span class="line">	    &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody, &amp;vid_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="keyword">if</span> (!out_zero(<span class="number">1500</span> <span class="comment">/*MTU?*/</span>, &amp;vid_pbs, <span class="string">&quot;Filler VID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;vid_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Nr out */</span><span class="comment">/*æ·»åŠ NONCEè½½è·ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨st-&gt;st_nr*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_nr, r</span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , (send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_NONE</span><br><span class="line">		    , <span class="string">&quot;Nr&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CR out */</span><span class="comment">/*å¦‚æœéœ€è¦å‘é€è¯ä¹¦*/</span></span><br><span class="line">    <span class="keyword">if</span> (send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">if</span> (st-&gt;st_connection-&gt;kind == CK_PERMANENT)<span class="comment">/*åŒæ–¹è¿æ¥å›ºå®š,å³ä¸¤ç«¯çš„IPçš„ç¡®å®šçš„*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE <span class="comment">/*æ·»åŠ å¯¹ç«¯è¯ä¹¦è½½è·*/</span></span><br><span class="line">				   , st-&gt;st_connection-&gt;spd.that.ca</span><br><span class="line">				   , &amp;md-&gt;rbody, ISAKMP_NEXT_NONE))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    generalName_t *ca = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*æŸ¥è¯¢å¯ç”¨çš„è¯ä¹¦   ???*/</span></span><br><span class="line">	    <span class="keyword">if</span> (collect_rw_ca_candidates(md, &amp;ca))<span class="comment">/*æ”¶é›†æ‰€æœ‰å¯ç”¨è¯ä¹¦,å¹¶å…¨éƒ¨åŠ è½½åˆ°caé“¾è¡¨ä¸Š*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">		generalName_t *gn;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (gn = ca; gn != <span class="literal">NULL</span>; gn = gn-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE, gn-&gt;name<span class="comment">/*å°†æ‰€æœ‰çš„å¯ç”¨è¯ä¹¦åŠ è½½åˆ°é“¾è¡¨ä¸Š*/</span></span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , gn-&gt;next == <span class="literal">NULL</span> ? ISAKMP_NEXT_NONE : ISAKMP_NEXT_CR))</span><br><span class="line">			<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		free_generalNames(ca, FALSE);<span class="comment">/*é‡Šæ”¾å¯ç”¨è¯ä¹¦é“¾è¡¨*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;<span class="comment">/*ç¡®å®æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„è¯ä¹¦ï¼Œåˆ™å¡«å……ä¸€ä¸ªç©ºçš„è¯ä¹¦è½½è·*/</span></span><br><span class="line">		<span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE, empty_chunk</span><br><span class="line">		, &amp;md-&gt;rbody, ISAKMP_NEXT_NONE))</span><br><span class="line">		    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_add_natd(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, md))<span class="comment">/*æ·»åŠ NAT-Dè½½è·*/</span></span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish message */</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	ä½¿  ç”¨  DH  ç®—  æ³•  å¼€  å§‹  åˆ¶  ä½œ  å¯†  é’¥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * next message will be encrypted, so, we need to have</span></span><br><span class="line"><span class="comment">     * the DH value calculated. We can do this in the background,</span></span><br><span class="line"><span class="comment">     * sending the reply right away. We have to be careful on the next</span></span><br><span class="line"><span class="comment">     * state, since the other end may reply faster than we can calculate</span></span><br><span class="line"><span class="comment">     * things. If it is the case, then the packet is placed in the</span></span><br><span class="line"><span class="comment">     * continuation, and we let the continuation process it. If there</span></span><br><span class="line"><span class="comment">     * is a retransmit, we keep only the last packet.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also, note that this is not a suspended state, since we are</span></span><br><span class="line"><span class="comment">     * actually just doing work in the background.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* Looks like we missed perform_dh() declared at</span></span><br><span class="line"><span class="comment">     * programs/pluto/pluto_crypt.h as external and implemented nowhere.</span></span><br><span class="line"><span class="comment">     * Following code regarding dh_continuation allocation seems useless</span></span><br><span class="line"><span class="comment">     * as it&#x27;s never used. At least, we should free it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> alloc_thing(struct dh_continuation</span><br><span class="line">						 , <span class="string">&quot;main_inI2_outR2_tail&quot;</span>);</span><br><span class="line">	stf_status e;</span><br><span class="line"></span><br><span class="line">	dh-&gt;md = <span class="literal">NULL</span>;</span><br><span class="line">	dh-&gt;serialno = st-&gt;st_serialno;</span><br><span class="line">	pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">	dh-&gt;dh_pcrc.pcrc_func = main_inI2_outR2_calcdone;</span><br><span class="line">	passert(st-&gt;st_suspended_md == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_CONTROLMORE</span><br><span class="line">	    , DBG_log(<span class="string">&quot;main inI2_outR2: starting async DH calculation (group=%d)&quot;</span>, st-&gt;st_oakley.group-&gt;group));</span><br><span class="line"></span><br><span class="line">	e = start_dh_secretiv(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">			      , st-&gt;st_import</span><br><span class="line">			      , RESPONDER</span><br><span class="line">			      , st-&gt;st_oakley.group-&gt;group);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_CONTROLMORE,</span><br><span class="line">	    DBG_log(<span class="string">&quot;started dh_secretiv, returned: stf=%s\n&quot;</span></span><br><span class="line">		    , stf_status_name(e)));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(e == STF_FAIL) &#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;failed to start async DH calculation, stf=%s\n&quot;</span></span><br><span class="line">		   , stf_status_name(e));</span><br><span class="line">	    <span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we are calculating in the background, so it doesn&#x27;t count */</span></span><br><span class="line">	<span class="keyword">if</span>(e == STF_SUSPEND) &#123;</span><br><span class="line">	    st-&gt;st_calculating = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-main-inI2-outR2-calcdoneæºç åˆ†æ"><a href="#9-main-inI2-outR2-calcdoneæºç åˆ†æ" class="headerlink" title="9. main_inI2_outR2_calcdoneæºç åˆ†æ"></a>9. main_inI2_outR2_calcdoneæºç åˆ†æ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_calcdone</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> (struct dh_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROLMORE</span><br><span class="line">	, DBG_log(<span class="string">&quot;main inI2_outR2: calculated DH finished&quot;</span>));</span><br><span class="line"></span><br><span class="line">    st = state_with_serialno(dh-&gt;serialno);</span><br><span class="line">    <span class="keyword">if</span>(st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;state %ld disappeared during crypto\n&quot;</span>, dh-&gt;serialno);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);</span><br><span class="line">    <span class="keyword">if</span>(ugh) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;DH crypto failed: %s\n&quot;</span>, ugh);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*å°†ç”Ÿæˆçš„ä¸‰æŠŠç§˜é’¥ã€DH-IVç­‰ä¿¡æ¯å­˜å‚¨åœ¨çŠ¶æ€ä¸Š*/</span></span><br><span class="line">    finish_dh_secretiv(st, r);</span><br><span class="line">    <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">        loglog(RC_LOG_SERIOUS, <span class="string">&quot;DH crypto failed, invalid keys&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ikev2_validate_key_lengths(st);</span><br><span class="line"></span><br><span class="line">    st-&gt;hidden_variables.st_skeyid_calculated = TRUE;</span><br><span class="line">    update_iv(st);<span class="comment">/*æ›´æ–°IVå€¼*/</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> Do we need to free dh here? If so, how about the other exits?</span></span><br><span class="line"><span class="comment">     * pfree(dh); dh = NULL;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * if there was a packet received while we were calculating, then</span></span><br><span class="line"><span class="comment">     * process it now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*å¦‚æœåœ¨è®¡ç®—ç§˜é’¥çš„è¿‡ç¨‹ä¸­æ”¶åˆ°æ–°çš„æŠ¥æ–‡åˆ™ç°åœ¨å†å¤„ç†è¯¥æŠ¥æ–‡*/</span></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_suspended_md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> st-&gt;st_suspended_md;</span><br><span class="line"></span><br><span class="line">	set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">	process_packet_tail(&amp;md);</span><br><span class="line">	<span class="keyword">if</span>(md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    release_md(md);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













































































]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>å¿«é€Ÿæ¨¡å¼ç¬¬ä¸‰åŒ…ä¹‹quick_inR1_outI2()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85%20quick_inR1_outI2()/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205850.png" alt="image-20200909232524545"></p>
<span id="more"></span>
<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p>åœ¨ä¸Šä¸€ç¯‡ä¸­åšå®¢ä¸­é•¿è¯çŸ­è¯´äº†ç¬¬äºŒåŒ…çš„å¤„ç†æµç¨‹ï¼Œå‰ä¸¤ä¸ªæŠ¥æ–‡çš„äº¤äº’æ˜¯å¿«é€Ÿæ¨¡å¼çš„å…³é”®äº¤äº’ï¼Œç”¨æ¥åå•†ä¼šè¯å‚æ•°(åŠ è§£å¯†ç®—æ³•ã€ä¼šè¯ç§˜é’¥ç­‰)ï¼Œè€Œç¬¬ä¸‰åŒ…åˆ™æ˜¯å¯¹å‰ä¸¤ä¸ªæŠ¥æ–‡çš„è®¤è¯ï¼Œæµç¨‹ä¸Šç®€å•äº†å¾ˆå¤š ã€‚<code>quick_inR1_outI2()</code>å¤„ç†æµç¨‹å®ç°çš„åŠŸèƒ½å¦‚ä¸‹ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>è§£æSAè½½è·</strong>(å¯¹ç«¯é€‰æ‹©çš„åŠ è§£å¯†ç®—æ³•ä¿¡æ¯)ã€<strong>KEè½½è·</strong>(pfs)ã€<strong>Nonceè½½è·</strong>ã€‚</li>
<li><input checked="" disabled="" type="checkbox"> æ„é€ ç¬¬ä¸‰ä¸ªæŠ¥æ–‡</li>
<li><input checked="" disabled="" type="checkbox"> <strong>ç”Ÿæˆå¯†é’¥ç”Ÿæˆææ–™keymats</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>å»ºç«‹å®Œæ•´çš„IPsec SA</strong><ul>
<li><input checked="" disabled="" type="checkbox"> å‘èµ·ç«¯å»ºç«‹çš„ä¸ºå®Œæ•´IPSec SA,åŒ…æ‹¬å…¥SAå’Œå‡ºSAï¼Œå“åº”ç«¯æœ‰æ‰€ä¸åŒã€‚</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>å¯åŠ¨DPDæ£€æµ‹</strong></li>
</ul>
<h3 id="2-quick-inR1-outI2-çš„å¤„ç†æµç¨‹"><a href="#2-quick-inR1-outI2-çš„å¤„ç†æµç¨‹" class="headerlink" title="2. quick_inR1_outI2()çš„å¤„ç†æµç¨‹"></a>2. quick_inR1_outI2()çš„å¤„ç†æµç¨‹</h3><p>ç¬¬ä¸‰ä¸ªæŠ¥æ–‡çš„å®Œæ•´å¤„ç†æµç¨‹å¦‚ä¸‹ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205853.png" alt="image-20200913094835778"></p>
<h3 id="3-å¿«é€Ÿæ¨¡å¼ç¬¬â‘¢åŒ…æŠ¥æ–‡æ ¼å¼"><a href="#3-å¿«é€Ÿæ¨¡å¼ç¬¬â‘¢åŒ…æŠ¥æ–‡æ ¼å¼" class="headerlink" title="3. å¿«é€Ÿæ¨¡å¼ç¬¬â‘¢åŒ…æŠ¥æ–‡æ ¼å¼"></a>3. å¿«é€Ÿæ¨¡å¼ç¬¬â‘¢åŒ…æŠ¥æ–‡æ ¼å¼</h3><p> è¯¥æŠ¥æ–‡ä¸­çš„æ‚å‡‘è½½è·æ˜¯å¯¹å‰é¢äº¤æ¢çš„è®¤è¯ã€‚ç¬¬â‘¢åŒ…ä»…æœ‰ISAKMPå¤´éƒ¨å’Œæ‚å‡‘è½½è·æ„æˆï¼Œæ‚å‡‘è½½è·çš„æ¶ˆæ¯æ‘˜è¦æ˜¯ä»¥==ä¸€ä¸ª0å­—èŠ‚çš„MsgIDã€å»æ‰è½½è·å¤´çš„å‘èµ·è€…Nonceä»¥åŠå»æ‰äº†è½½è·å¤´çš„å“åº”è€…Nonce==ä¸ºè¾“å…¥å‚æ•°ç”Ÿæˆçš„ï¼Œè®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š<br>$$<br>HASH(3) = PRF(SKEY-a,  0|MsgID|Ni_b|Nr_b)<br>$$</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205858.png" alt="å›¾ç‰‡1"></p>
<h3 id="4-quick-inR1-outI2-æºç åˆ†æ"><a href="#4-quick-inR1-outI2-æºç åˆ†æ" class="headerlink" title="4. quick_inR1_outI2()æºç åˆ†æ"></a>4. quick_inR1_outI2()æºç åˆ†æ</h3><p>æ¥å£<code>quick_inR1_outI2()</code>çš„ä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> ==éªŒè¯æŠ¥æ–‡çš„å®Œæ•´æ€§==</li>
<li><input checked="" disabled="" type="checkbox"> ==è§£æå“åº”ç«¯é€‰æ‹©çš„SAè½½è·==<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>åŠ è§£å¯†ç®—æ³•(ESPåè®®ã€AHåè®®ï¼Œâ€¦)</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>è®¤è¯ç®—æ³•</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>å°è£…æ¨¡å¼ï¼ˆéš§é“æ¨¡å¼ ï¼Ÿä¼ è¾“æ¨¡å¼ï¼‰</strong></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> ==è§£æNonceè½½è·==</li>
<li><input checked="" disabled="" type="checkbox"> å¦‚æœå¯ç”¨PFS<ul>
<li><input disabled="" type="checkbox"> è§£æKEè½½è·</li>
<li><input disabled="" type="checkbox"> å†æ¬¡è®¡ç®—DHäº¤æ¢å€¼</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inR1_outI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(2) in */</span><span class="comment">/*éªŒè¯æŠ¥æ–‡çš„å“ˆå¸Œè½½è·*/</span></span><br><span class="line">    CHECK_QUICK_HASH(md</span><br><span class="line">	, quick_mode_hash12(hash_val, hash_pbs-&gt;roof, md-&gt;message_pbs.roof</span><br><span class="line">	    , st, &amp;st-&gt;st_msgid, TRUE)</span><br><span class="line">	, <span class="string">&quot;HASH(2)&quot;</span>, <span class="string">&quot;Quick R1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA in */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sa_pd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*è§£æå¯¹ç«¯é€‰æ‹©çš„SAè½½è·*/</span></span><br><span class="line">	RETURN_STF_FAILURE(parse_ipsec_sa_body(&amp;sa_pd-&gt;pbs</span><br><span class="line">	    , &amp;sa_pd-&gt;payload.sa, <span class="literal">NULL</span>, TRUE, st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nr in */</span><span class="comment">/*è§£æå¯¹ç«¯Nonceè½½è·*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_nr, <span class="string">&quot;Nr&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [ KE ] in (for PFS) */</span><span class="comment">/*æ ¹æ®é…ç½®ç­–ç•¥è§£æå¯¹ç«¯KEè½½è·*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_PFS_KE(md, &amp;st-&gt;st_gr, <span class="string">&quot;Gr&quot;</span>, <span class="string">&quot;Quick Mode R1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_pfs_group) &#123;<span class="comment">/*å¦‚æœæ”¯æŒPFSåŠŸèƒ½ï¼Œåˆ™éœ€è¦è¿›è¡ŒDHç®—æ³•è®¡ç®—*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> alloc_thing(struct dh_continuation</span><br><span class="line">							 , <span class="string">&quot;quick outI2 DH&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* set up DH calculation */</span></span><br><span class="line">		dh-&gt;md = md;</span><br><span class="line">		passert(st != <span class="literal">NULL</span>);</span><br><span class="line">		set_suspended(st, md);</span><br><span class="line">		pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">		dh-&gt;dh_pcrc.pcrc_func = quick_inR1_outI2_continue;</span><br><span class="line">		<span class="keyword">return</span> start_dh_secret(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">				       , st-&gt;st_import</span><br><span class="line">				       , INITIATOR</span><br><span class="line">				       , st-&gt;st_pfs_group-&gt;group);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* just call the tail function */</span></span><br><span class="line">		struct dh_continuation dh;</span><br><span class="line"></span><br><span class="line">		dh.md=md;</span><br><span class="line">		<span class="keyword">return</span> quick_inR1_outI2_cryptotail(&amp;dh, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-quick-inR1-outI2-cryptotail-æºç åˆ†æ"><a href="#4-quick-inR1-outI2-cryptotail-æºç åˆ†æ" class="headerlink" title="4. quick_inR1_outI2_cryptotail()æºç åˆ†æ"></a>4. quick_inR1_outI2_cryptotail()æºç åˆ†æ</h3><p>æ¥å£<code>quick_inR1_outI2_cryptotail()</code>çš„ä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  ==æ£€éªŒIDè½½è·æ”¶å‘æ˜¯å¦ä¸€è‡´==</p>
<p>è¿™é‡Œæ˜¯é€šè¿‡IDè½½è·æ¥åå•†IPSecéš§é“çš„ä¿æŠ¤å­ç½‘ä¿¡æ¯</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  NAT-Tç›¸å…³å¤„ç†</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  æ„é€ åº”ç­”æŠ¥æ–‡</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==è®¡ç®—keymatså€¼==</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==å»ºç«‹IPSecSA==</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==åˆå§‹åŒ–æœ¬éš§é“çš„DPDå®šæ—¶å™¨==</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inR1_outI2_cryptotail</span><span class="params">(struct dh_continuation *dh</span></span></span><br><span class="line"><span class="params"><span class="function">			    , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> dh-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span> =</span> st-&gt;st_connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_pfs_group != <span class="literal">NULL</span> &amp;&amp; r!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">	finish_dh_secret(st, r);<span class="comment">/*è·å–å¯†é’¥ä¿¡æ¯*/</span></span><br><span class="line">        <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [ IDci, IDcr ] in; these must match what we sent */</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">IDci</span> =</span> md-&gt;chain[ISAKMP_NEXT_ID];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">IDcr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IDci != <span class="literal">NULL</span>)<span class="comment">/*åº”ç­”æŠ¥æ–‡ä¸­åŒ…å«IDè½½è·*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* ??? we are assuming IPSEC_DOI */</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* IDci (we are initiator) */</span><span class="comment">/*ç¡®å®šæ”¶å‘IDè½½è·æ˜¯å¦ä¸€è‡´*/</span></span><br><span class="line">	    <span class="keyword">if</span> (!check_net_id(&amp;IDci-&gt;payload.ipsec_id, &amp;IDci-&gt;pbs</span><br><span class="line">			      , &amp;st-&gt;st_myuserprotoid, &amp;st-&gt;st_myuserport</span><br><span class="line">			      , &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span></span><br><span class="line">                              , &amp;st-&gt;st_localaddr</span><br><span class="line">			      , <span class="string">&quot;our client&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* we checked elsewhere that we got two of them */</span></span><br><span class="line">	    IDcr = IDci-&gt;next;<span class="comment">/*å“åº”ç«¯IDè½½è·æ˜¯å¦åŒ¹é…*/</span></span><br><span class="line">	    passert(IDcr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* IDcr (responder is peer) */</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!check_net_id(&amp;IDcr-&gt;payload.ipsec_id, &amp;IDcr-&gt;pbs</span><br><span class="line">			      , &amp;st-&gt;st_peeruserprotoid, &amp;st-&gt;st_peeruserport</span><br><span class="line">			      , &amp;st-&gt;st_connection-&gt;spd.that</span><br><span class="line">                              , &amp;st-&gt;st_remoteaddr</span><br><span class="line">			      , <span class="string">&quot;peer client&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	     * if there is a NATOA payload, then use it as</span></span><br><span class="line"><span class="comment">	     *    &amp;st-&gt;st_connection-&gt;spd.that.client, if the type</span></span><br><span class="line"><span class="comment">	     * of the ID was FQDN</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">	... ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* no IDci, IDcr: we must check that the defaults match our proposal */</span></span><br><span class="line">	    <span class="keyword">if</span> (!subnetisaddr(&amp;c-&gt;spd.<span class="keyword">this</span>.client, &amp;c-&gt;spd.<span class="keyword">this</span>.host_addr)<span class="comment">/*ä¸¤ä¸ªåœ°å€ä¸€æ ·å³å¯*/</span></span><br><span class="line">		|| !subnetisaddr(&amp;c-&gt;spd.that.client, &amp;c-&gt;spd.that.host_addr))</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;IDci, IDcr payloads missing in message&quot;</span></span><br><span class="line">		    <span class="string">&quot; but default does not match proposal&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build reply packet HDR*, HASH(3) ****************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out done ISAKMPå¤´éƒ¨å·²ç»å¡«å……å®Œæ¯•*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(3) out -- sometimes, we add more content */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char	<span class="comment">/* set by START_HASH_PAYLOAD: */</span></span><br><span class="line">	    *r_hashval,	<span class="comment">/* where in reply to jam hash value */</span></span><br><span class="line">	    *r_hash_start;      <span class="comment">/* start of what is to be hashed */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*å¡«å……hashè½½è·*/</span></span><br><span class="line">	START_HASH_PAYLOAD(md-&gt;rbody, ISAKMP_NEXT_NONE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*è®¡ç®—å“ˆå¸Œè½½è·å€¼ï¼Œç”¨äºå¯¹ç«¯æ£€æµ‹æŠ¥æ–‡çš„å®Œæ•´æ€§*/</span></span><br><span class="line">	(<span class="keyword">void</span>)quick_mode_hash3(r_hashval, st);</span><br><span class="line">        r_hash_start = r_hash_start;   <span class="comment">/* otherwise complaint about never used */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Derive new keying material */</span><span class="comment">/*è®¡ç®—å¯†é’¥ç”Ÿæˆææ–™*/</span></span><br><span class="line">    compute_keymats(st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tell the kernel to establish the inbound, outbound, and routing part</span></span><br><span class="line"><span class="comment">     * of the new SA (unless the commit bit is set -- which we don&#x27;t support).</span></span><br><span class="line"><span class="comment">     * We do this before any state updating so that</span></span><br><span class="line"><span class="comment">     * failure won&#x27;t look like success.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!install_ipsec_sa(md-&gt;pst, st, TRUE))<span class="comment">/*å»ºç«‹IPsecSA*/</span></span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line">	<span class="comment">/*åŠ å¯†*/</span></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">    &#123;</span><br><span class="line">        delete_ipsec_sa(st, FALSE);</span><br><span class="line">        <span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_connection-&gt;newest_ipsec_sa = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note (presumed) success */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;gw_info != <span class="literal">NULL</span>)</span><br><span class="line">	c-&gt;gw_info-&gt;key-&gt;last_worked_time = now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have dpd delay and dpdtimeout set, then we are doing DPD</span></span><br><span class="line"><span class="comment">	on this conn, so initialize it */</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_connection-&gt;dpd_delay &amp;&amp; st-&gt;st_connection-&gt;dpd_timeout) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dpd_init(st) != STF_OK) &#123;<span class="comment">/*å¯åŠ¨DPDå®šæ—¶å™¨*/</span></span><br><span class="line">            delete_ipsec_sa(st, FALSE);</span><br><span class="line">            <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-compute-keymats-æºç åˆ†æ"><a href="#4-compute-keymats-æºç åˆ†æ" class="headerlink" title="4. compute_keymats()æºç åˆ†æ"></a>4. compute_keymats()æºç åˆ†æ</h3><p><code>compute_keymats()</code>æ˜¯ä¸€ä¸ªå¾ˆé‡çš„å‡½æ•°ï¼ŒåŠŸèƒ½æ˜¯ç¬¬äºŒé˜¶æ®µè®¡ç®—ç”Ÿæˆå¯†é’¥ææ–™ï¼Œå®ƒçš„è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> å¦‚æœå¯ç”¨PFSåŠŸèƒ½ï¼š</li>
</ul>
<p>$$<br>KEYMATS = PRF(SKEYSTR-d, g^{xy} | protocol | SPI | Ni-b |Nr-b   )<br>$$</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> æœªç”¨PFSåŠŸèƒ½ï¼š</li>
</ul>
<p>$$<br>KEYMATS = PRF(SKEYSTR-d, protocol | SPI | Ni-b |Nr-b   )<br>$$</p>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼š</p>
<ul>
<li>$g^{xy}$æ˜¯ç¬¬äºŒé˜¶æ®µé€šè¿‡é¢å¤–çš„DHäº¤æ¢è®¡ç®—å¾—åˆ°çš„(==DHè®¡ç®—å‡ºçš„å…±äº«ç§˜é’¥==)ï¼Œå­˜å‚¨åœ¨<code>st-&gt;st_shared</code>ä¸­ã€‚æ­¤å˜é‡è™½ç„¶åœ¨ç¬¬ä¸€é˜¶æ®µæ—¶ä¹Ÿæœ‰ç”Ÿæˆï¼Œä½†æ˜¯ç¬¬äºŒé˜¶æ®µä½¿ç”¨äº†ç¬¬ä¸€é˜¶æ®µå¤åˆ¶çš„stateçŠ¶æ€ï¼Œå¹¶æœªä½¿ç”¨ç¬¬ä¸€é˜¶æ®µä¸­çš„<code>st_shared</code>çš„å€¼ï¼Œå› æ­¤ç¬¬äºŒé˜¶æ®µçš„<code>st-&gt;st_shared</code>åªæœ‰åœ¨è¿›è¡Œé¢å¤–çš„DHäº¤æ¢åæ‰ä¼šç”Ÿæˆï¼Œä¸”ä¸ä¼šä½¿ç”¨ç¬¬ä¸€é˜¶æ®µçš„å…±äº«å¯†é’¥çš„å€¼ã€‚</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">compute_keymats</span><span class="params">(struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_ah.present)</span><br><span class="line">	compute_proto_keymat(st, PROTO_IPSEC_AH, &amp;st-&gt;st_ah, <span class="string">&quot;AH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_esp.present)</span><br><span class="line">	compute_proto_keymat(st, PROTO_IPSEC_ESP, &amp;st-&gt;st_esp, <span class="string">&quot;ESP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Produce the new key material of Quick Mode.</span></span><br><span class="line"><span class="comment"> * RFC 2409 &quot;IKE&quot; section 5.5</span></span><br><span class="line"><span class="comment"> * specifies how this is to be done.</span></span><br><span class="line"><span class="comment"> *###############################################</span></span><br><span class="line"><span class="comment"> *	compute_proto_keymatéå¸¸é‡è¦çš„å¯†é’¥åå•†å‡½æ•°</span></span><br><span class="line"><span class="comment"> *###############################################</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">compute_proto_keymat</span><span class="params">(struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">u_int8_t</span> protoid</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct ipsec_proto_info *pi</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">const</span> <span class="keyword">char</span> *satypename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> needed_len = <span class="number">0</span>; <span class="comment">/* bytes of keying material needed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add up the requirements for keying material</span></span><br><span class="line"><span class="comment">     * (It probably doesn&#x27;t matter if we produce too much!)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (protoid)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PROTO_IPSEC_ESP:</span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.encrypt)<span class="comment">/*åŠ å¯†ç®—æ³•*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	    <span class="keyword">case</span> ESP_NULL:</span><br><span class="line">			needed_len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_DES:</span><br><span class="line">			needed_len = DES_CBC_BLOCK_SIZE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_3DES:</span><br><span class="line">			needed_len = DES_CBC_BLOCK_SIZE * <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_AES:</span><br><span class="line">			needed_len = AES_CBC_BLOCK_SIZE;</span><br><span class="line">			<span class="comment">/* if an attribute is set, then use that! */</span></span><br><span class="line">			<span class="keyword">if</span>(st-&gt;st_esp.attrs.transattrs.enckeylen) &#123;<span class="comment">/*å¦‚æœå±æ€§è½½è·è®¾ç½®äº†æ­¤å‚æ•°ï¼Œåˆ™ä½¿ç”¨æ­¤å‚æ•°çš„å€¼*/</span></span><br><span class="line">			    needed_len = st-&gt;st_esp.attrs.transattrs.enckeylen/<span class="number">8</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">			<span class="keyword">if</span>((needed_len=kernel_alg_esp_enc_keylen(pi-&gt;attrs.transattrs.encrypt))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">/* <span class="doctag">XXX:</span> check key_len &quot;coupling with kernel.c&#x27;s */</span></span><br><span class="line">				<span class="keyword">if</span> (pi-&gt;attrs.transattrs.enckeylen) &#123;</span><br><span class="line">					needed_len=pi-&gt;attrs.transattrs.enckeylen/<span class="number">8</span>;</span><br><span class="line">					DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">							<span class="string">&quot;key_len=%d from peer&quot;</span>,</span><br><span class="line">							(<span class="keyword">int</span>)needed_len));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.encrypt);</span><br><span class="line">	    &#125;</span><br><span class="line">	    DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">				     <span class="string">&quot;needed_len (after ESP enc)=%d&quot;</span>,</span><br><span class="line">				     (<span class="keyword">int</span>)needed_len));</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.integ_hash)<span class="comment">/*å“ˆå¸Œç®—æ³•*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_NONE:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_HMAC_MD5:</span><br><span class="line">			needed_len += HMAC_MD5_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_HMAC_SHA1:</span><br><span class="line">			needed_len += HMAC_SHA1_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">		      <span class="keyword">if</span> (kernel_alg_esp_auth_ok(pi-&gt;attrs.transattrs.integ_hash, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			  needed_len += kernel_alg_esp_auth_keylen(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">		      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_DES_MAC:</span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	    DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">				    <span class="string">&quot;needed_len (after ESP auth)=%d&quot;</span>,</span><br><span class="line">				    (<span class="keyword">int</span>)needed_len));</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PROTO_IPSEC_AH:</span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.encrypt)</span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="keyword">case</span> AH_MD5:</span><br><span class="line">			needed_len = HMAC_MD5_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AH_SHA:</span><br><span class="line">			needed_len = HMAC_SHA1_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">			<span class="keyword">if</span> (kernel_alg_ah_auth_ok(pi-&gt;attrs.transattrs.integ_hash, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			    needed_len += kernel_alg_ah_auth_keylen(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.encrypt);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	bad_case(protoid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*å°†æ‰€æœ‰ç®—æ³•éœ€è¦çš„å¯†é’¥é•¿åº¦å…¨éƒ¨ç›¸åŠ ï¼Œä»è€Œç”Ÿæˆæ‰€éœ€é•¿åº¦çš„å¯†é’¥ææ–™*/</span></span><br><span class="line"></span><br><span class="line">    pi-&gt;keymat_len = needed_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate space for the keying material.</span></span><br><span class="line"><span class="comment">     * Although only needed_len bytes are desired, we</span></span><br><span class="line"><span class="comment">     * must round up to a multiple of ctx.hmac_digest_len</span></span><br><span class="line"><span class="comment">     * so that our buffer isn&#x27;t overrun.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx_me</span>, <span class="title">ctx_peer</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> needed_space;	<span class="comment">/* space needed for keying material (rounded up) */</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">	hmac_init_chunk(&amp;ctx_me, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_d);</span><br><span class="line"></span><br><span class="line">	ctx_peer = ctx_me;	<span class="comment">/* duplicate initial conditions */</span></span><br><span class="line">	needed_space = needed_len + pad_up(needed_len, ctx_me.hmac_digest_len);</span><br><span class="line">	replace(pi-&gt;our_keymat, alloc_bytes(needed_space, <span class="string">&quot;keymat in compute_keymat()&quot;</span>));</span><br><span class="line">	replace(pi-&gt;peer_keymat, alloc_bytes(needed_space, <span class="string">&quot;peer_keymat in quick_inI1_outR1()&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* å‡†å¤‡è®¡ç®—ç§˜é’¥æ‰€éœ€çš„æ‰€æœ‰ææ–™</span></span><br><span class="line"><span class="comment">*	1. DHäº¤æ¢ç”Ÿæˆçš„å…±äº«ç§˜é’¥</span></span><br><span class="line"><span class="comment">*	2. åè®®protocol</span></span><br><span class="line"><span class="comment">*	3. SPI</span></span><br><span class="line"><span class="comment">*	4. Ni_b</span></span><br><span class="line"><span class="comment">*	5. Nr_b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;; )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*1. DHäº¤æ¢ç”Ÿæˆçš„å…±äº«ç§˜é’¥*/</span></span><br><span class="line">	    <span class="keyword">if</span> (st-&gt;st_shared.ptr != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">            <span class="comment">/* PFS: include the g^xy */</span></span><br><span class="line">            hmac_update_chunk(&amp;ctx_me, st-&gt;st_shared);</span><br><span class="line">            hmac_update_chunk(&amp;ctx_peer, st-&gt;st_shared);</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="comment">/*2. åè®®protocol*/</span></span><br><span class="line">	    hmac_update(&amp;ctx_me, &amp;protoid, <span class="keyword">sizeof</span>(protoid));</span><br><span class="line">	    hmac_update(&amp;ctx_peer, &amp;protoid, <span class="keyword">sizeof</span>(protoid));</span><br><span class="line">		<span class="comment">/*3. SPI*/</span></span><br><span class="line">	    hmac_update(&amp;ctx_me, (u_char *)&amp;pi-&gt;our_spi, <span class="keyword">sizeof</span>(pi-&gt;our_spi));</span><br><span class="line">	    hmac_update(&amp;ctx_peer, (u_char *)&amp;pi-&gt;attrs.spi, <span class="keyword">sizeof</span>(pi-&gt;attrs.spi));</span><br><span class="line">		<span class="comment">/*4. Ni_b*/</span></span><br><span class="line">	    hmac_update_chunk(&amp;ctx_me, st-&gt;st_ni);</span><br><span class="line">	    hmac_update_chunk(&amp;ctx_peer, st-&gt;st_ni);</span><br><span class="line">		<span class="comment">/*5. Nr_b*/</span></span><br><span class="line">	    hmac_update_chunk(&amp;ctx_me, st-&gt;st_nr);</span><br><span class="line">	    hmac_update_chunk(&amp;ctx_peer, st-&gt;st_nr);</span><br><span class="line"></span><br><span class="line">	    hmac_final(pi-&gt;our_keymat + i, &amp;ctx_me);</span><br><span class="line">	    hmac_final(pi-&gt;peer_keymat + i, &amp;ctx_peer);</span><br><span class="line"></span><br><span class="line">	    i += ctx_me.hmac_digest_len;</span><br><span class="line">	    <span class="keyword">if</span> (i &gt;= needed_space)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* more keying material needed: prepare to go around again */</span></span><br><span class="line">	    hmac_reinit(&amp;ctx_me);</span><br><span class="line">	    hmac_reinit(&amp;ctx_peer);</span><br><span class="line"></span><br><span class="line">	    hmac_update(&amp;ctx_me, pi-&gt;our_keymat + i - ctx_me.hmac_digest_len, ctx_me.hmac_digest_len);</span><br><span class="line">	    hmac_update(&amp;ctx_peer, pi-&gt;peer_keymat + i - ctx_peer.hmac_digest_len, ctx_peer.hmac_digest_len);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*åŒæ–¹èƒ½è®¡ç®—å‡ºå¯¹ç«¯çš„å¯†é’¥ææ–™ä¿¡æ¯???*/</span></span><br><span class="line">    DBG(DBG_CRYPT,</span><br><span class="line">	DBG_log(<span class="string">&quot;%s KEYMAT\n&quot;</span>,satypename);</span><br><span class="line">	DBG_dump(<span class="string">&quot;  KEYMAT computed:\n&quot;</span>, pi-&gt;our_keymat, pi-&gt;keymat_len);</span><br><span class="line">	DBG_dump(<span class="string">&quot;  Peer KEYMAT computed:\n&quot;</span>, pi-&gt;peer_keymat, pi-&gt;keymat_len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-dpd-init-æºç åˆ†æ"><a href="#5-dpd-init-æºç åˆ†æ" class="headerlink" title="5. dpd_init()æºç åˆ†æ"></a>5. dpd_init()æºç åˆ†æ</h3><p>DPDåŠŸèƒ½å¯¹åº”æœ‰ä¸¤ä¸ªäº‹ä»¶ï¼š</p>
<ul>
<li><p><strong>EVENT_DPD_TIMEOUT</strong></p>
<p>ç¬¬ä¸€é˜¶æ®µçš„å®šæ—¶å™¨ï¼Œåœ¨ç¬¬äºŒé˜¶æ®µå·²ç»æ–­å¼€çš„æƒ…å†µä¸‹ï¼Œç”¨æ¥æ£€æµ‹ç¬¬ä¸€é˜¶æ®µæ˜¯å¦è¶…æ—¶</p>
</li>
<li><p><strong>DPD_EVENT</strong></p>
<p>ç¬¬äºŒé˜¶æ®µçš„å®šæ—¶å™¨ï¼Œé•¿æ—¶é—´æœªé€šè®¯æ—¶æ–­å¼€è¿æ¥ï¼Œå¹¶å¯åŠ¨ç¬¬ä¸€é˜¶æ®µçš„å®šæ—¶å™¨</p>
</li>
</ul>
<p>è¿™ä¸ªå®šæ—¶å™¨æœºåˆ¶å®é™…ä½¿ç”¨æ—¶ä¼šå¤æ‚ä¸€ç‚¹ã€‚å¯ä»¥å‚è€ƒæ³¨é‡Šè¯´æ˜ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize RFC 3706 Dead Peer Detection</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param st An initialized state structure</span></span><br><span class="line"><span class="comment"> * @return void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * How DPD works.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are two kinds of events that can be scheduled.</span></span><br><span class="line"><span class="comment"> * At most one of them is schedule at any given time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The EVENT_DPD_TIMEOUT event, if it ever goes off, means that</span></span><br><span class="line"><span class="comment"> * neither the ISAKMP SA nor the IPsec SA has *RECEIVED* any DPD</span></span><br><span class="line"><span class="comment"> * events lately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0) So, every time we receive a DPD (R_U_THERE or R_U_ACK), then</span></span><br><span class="line"><span class="comment"> *    we delete any DPD event (EVENT_DPD or EVENT_DPD_TIMEOUT), and</span></span><br><span class="line"><span class="comment"> *    we schedule a new DPD_EVENT (sending) for &quot;delay&quot; in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) When the DPD_EVENT goes off, we check the phase 2 (if there is one)</span></span><br><span class="line"><span class="comment"> *    SA to see if there was incoming traffic. If there was, then we are happy,</span></span><br><span class="line"><span class="comment"> *    we set a new DPD_EVENT, and we are done.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2) If there was no phase 2 activity, we check if there was a recent enough</span></span><br><span class="line"><span class="comment"> *    DPD activity (st-&gt;st_last_dpd). If so, we just reschedule, and do</span></span><br><span class="line"><span class="comment"> *    nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3) Otherwise, we send a DPD R_U_THERE message, and set the</span></span><br><span class="line"><span class="comment"> *    EVENT_DPD_TIMEOUT on the phase 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * One thing to realize when looking at &quot;ipsec whack --listevents&quot; output,</span></span><br><span class="line"><span class="comment"> * is there there will only be DPD_EVENT_TIMEOUT events if there are</span></span><br><span class="line"><span class="comment"> * outstanding R_U_THERE messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above is the basic idea, but things are a bit more complicated because</span></span><br><span class="line"><span class="comment"> * multiple phase 2s can share the same phase 1 ISAKMP SA. Each phase 2 state</span></span><br><span class="line"><span class="comment"> * has its own DPD_EVENT. Further, we start a DPD_EVENT for phase 1 when it</span></span><br><span class="line"><span class="comment"> * gets established. This is because the phase 2 may never actually succeed</span></span><br><span class="line"><span class="comment"> * (usually due to authorization issues, which may be DNS or otherwise related)</span></span><br><span class="line"><span class="comment"> * and if the responding end dies (gets restarted, or the conn gets reloaded</span></span><br><span class="line"><span class="comment"> * with the right policy), then we may have a bum phase 1 SA, and we can not</span></span><br><span class="line"><span class="comment"> * re-negotiate. (This happens WAY too often)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The phase 2 dpd_init() will attempt to kill the phase 1 DPD_EVENT, if it</span></span><br><span class="line"><span class="comment"> * can, to reduce the amount of work.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The st_last_dpd member which is used is always the one from the phase 1.</span></span><br><span class="line"><span class="comment"> * So, if there are multiple phase 2s, then if any of them receive DPD data</span></span><br><span class="line"><span class="comment"> * they will update the st_last_dpd, so the test in #2 will avoid the traffic</span></span><br><span class="line"><span class="comment"> * for all by one phase 2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the EVENT_DPD are attached to phase 2s (typically), while the</span></span><br><span class="line"><span class="comment"> * EVENT_DPD_TIMEOUT are attached to phase 1s only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally, if the connection is using NAT-T, then we ignore the phase 2</span></span><br><span class="line"><span class="comment"> * activity check, because in the case of a unidirectional stream (VoIP for</span></span><br><span class="line"><span class="comment"> * a conference call, for instance), we may not send enough traffic to keep</span></span><br><span class="line"><span class="comment"> * the NAT port mapping valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">dpd_init</span><span class="params">(struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used to store the 1st state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;loopback) &#123;</span><br><span class="line">            openswan_log(<span class="string">&quot;dpd is not required for ipsec connections over loopback&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> STF_OK;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">p1st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find the related Phase 1 state */</span></span><br><span class="line">    p1st = find_state_ikev1(st-&gt;st_icookie, st-&gt;st_rcookie,</span><br><span class="line">		      &amp;st-&gt;st_connection-&gt;spd.that.host_addr, <span class="number">0</span>);<span class="comment">/*ç¬¬ä¸€é˜¶æ®µçš„msgidä¸º0*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        loglog(RC_LOG_SERIOUS, <span class="string">&quot;could not find phase 1 state for DPD&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if the phase 1 state has gone away, it really should have</span></span><br><span class="line"><span class="comment">	 * deleted all of its children.</span></span><br><span class="line"><span class="comment">	 * Why would this happen? because a quick mode SA can take</span></span><br><span class="line"><span class="comment">	 * some time to create (DNS lookups for instance), and the phase 1</span></span><br><span class="line"><span class="comment">	 * might have been taken down for some reason in the meantime.</span></span><br><span class="line"><span class="comment">	 * We really can not do anything here --- attempting to invoke</span></span><br><span class="line"><span class="comment">	 * the DPD action would be a good idea, but we really should</span></span><br><span class="line"><span class="comment">	 * do that outside this function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it was enabled, and we haven&#x27;t turned it on already */</span></span><br><span class="line">    <span class="keyword">if</span> (p1st-&gt;hidden_variables.st_dpd) &#123;</span><br><span class="line">	<span class="keyword">time_t</span> n = now();</span><br><span class="line">	openswan_log(<span class="string">&quot;Dead Peer Detection (RFC 3706): enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_dpd_event == <span class="literal">NULL</span> || (st-&gt;st_connection-&gt;dpd_delay + n) &lt; st-&gt;st_dpd_event-&gt;ev_time) &#123;</span><br><span class="line">	    delete_dpd_event(st);</span><br><span class="line">	    event_schedule(EVENT_DPD, st-&gt;st_connection-&gt;dpd_delay, st);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      openswan_log(<span class="string">&quot;Dead Peer Detection (RFC 3706): not enabled because peer did not advertise it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1st != st) &#123;<span class="comment">/*ç¬¬ä¸€é˜¶æ®µçš„DPD_EVENTäº‹ä»¶å·²ç»æ²¡æœ‰å¿…è¦ï¼Œå¯ä»¥è¿›è¡Œåˆ é™¤äº†ï¼Œç¬¬äºŒé˜¶æ®µä¼šæœ‰è‡ªå·±çš„DPD_EVENT*/</span></span><br><span class="line">	<span class="comment">/* st was not a phase 1 SA, so kill the DPD_EVENT on the phase 1 */</span></span><br><span class="line">	<span class="keyword">if</span>(p1st-&gt;st_dpd_event != <span class="literal">NULL</span></span><br><span class="line">	   &amp;&amp; p1st-&gt;st_dpd_event-&gt;ev_type == EVENT_DPD) &#123;</span><br><span class="line">	    delete_dpd_event(p1st);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-install-ipsec-sa-æºç åˆ†æ"><a href="#6-install-ipsec-sa-æºç åˆ†æ" class="headerlink" title="6. install_ipsec_sa()æºç åˆ†æ"></a>6. install_ipsec_sa()æºç åˆ†æ</h3><p>ç•¥ã€‚<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205907.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>å¿«é€Ÿæ¨¡å¼ç¬¬ä¸€åŒ…ä¹‹quick_outI1()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1/</url>
    <content><![CDATA[<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p>openswanæºç ä¸­æœ‰å…³éš§é“åå•†çš„æ–‡ç« å·²ç»æ¯”è¾ƒä¹…æ²¡æœ‰æ›´æ–°äº†ï¼Œé‚£ä¹ˆä»è¿™ç¯‡å¼€å§‹å†é‡æ–°å›åˆ°æ›´æ–°æµç¨‹ä¸Šã€‚è¿™ä¸­é—´åœäº†å°†è¿‘2ä¸ªæœˆï¼Œç¬¬ä¸€ä¸ªæœˆå‡ ä¹æ²¡æœ‰æ›´æ–°ä»»ä½•åšå®¢ï¼Œè€Œç¬¬äºŒä¸ªæœˆä¸»è¦æ•´ç†ç¿»è¯‘QATç›¸å…³çš„æ–‡ç« ï¼Œæ¥ä¸‹æ¥æˆ‘å°†ç»§ç»­æ›´æ–°openswanæºç ç›¸å…³çš„å†…å®¹ã€‚</p>
<p>ä¸‹é¢å¼€å§‹ä»‹ç»IPSec å¿«é€Ÿæ¨¡å¼åå•†æµç¨‹ä¸­çš„ç¬¬â‘ åŒ…ï¼Œä¸»è¦å‡½æ•°çš„å…¥å£ä¸º**quick_outI1()**ï¼š</p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205311.png" alt="image-20200826002057928"></p>
<h3 id="2-quick-outI1-æµç¨‹å›¾"><a href="#2-quick-outI1-æµç¨‹å›¾" class="headerlink" title="2. quick_outI1()æµç¨‹å›¾"></a>2. quick_outI1()æµç¨‹å›¾</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205313.png" alt="image-20200826003329910"></p>
<h3 id="3-quick-outI1-æºç åˆ†æ"><a href="#3-quick-outI1-æºç åˆ†æ" class="headerlink" title="3. quick_outI1()æºç åˆ†æ"></a>3. quick_outI1()æºç åˆ†æ</h3><p><code>quick_outI1()</code>æ¥å£æ˜¯ç¬¬äºŒé˜¶æ®µå¿«é€Ÿæ¨¡å¼ç¬¬ä¸€åŒ…çš„å…¥å£å‡½æ•°ï¼Œå®ƒæœ€ä¸»è¦çš„å·¥ä½œå°±æ˜¯å°†==ç¬¬ä¸€é˜¶æ®µåå•†çš„ipsecsaçŠ¶æ€ä¿¡æ¯è½¬æ¢ä¸ºç¬¬äºŒé˜¶æ®µçš„çŠ¶æ€ä¿¡æ¯==ã€‚é€šè¿‡<code>duplicate_state</code>å®ç°çŠ¶æ€çš„æ‹·è´ï¼Œç„¶åå°†æ–°çš„çŠ¶æ€æ’å…¥åˆ°å…¨å±€çš„çŠ¶æ€è¡¨ä¸­ã€‚ä¹‹åå°±æ˜¯æ ¹æ®éš§é“çš„é…ç½®ä¿¡æ¯(PFS, ç®—æ³•ä¿¡æ¯)ç­‰åšç§˜é’¥ç”³è¯·ç­‰å‡†å¤‡å·¥ä½œã€‚</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>å¤åˆ¶ç¬¬ä¸€é˜¶æ®µipsecsaçŠ¶æ€ï¼Œå¹¶å°†å…¶æ’å…¥å…¨å±€çŠ¶æ€è¡¨ä¸­</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>æ˜¾ç¤ºç¬¬äºŒé˜¶æ®µç®—æ³•ç›¸å…³çš„debugä¿¡æ¯</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>æ ¹æ®é…ç½®åšç§˜é’¥ç”³è¯·</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_outI1</span><span class="params">(<span class="keyword">int</span> whack_sock</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct state *isakmp_sa</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct connection *c</span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">lset_t</span> policy</span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">try</span></span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">so_serial_t</span> replacing</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct xfrm_user_sec_ctx_ike * uctx UNUSED</span></span></span><br><span class="line"><span class="params"><span class="function">	    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> duplicate_state(isakmp_sa);<span class="comment">/*å¤åˆ¶ç¬¬ä¸€é˜¶æ®µçš„çŠ¶æ€,åŒ…æ‹¬äº†æ‰€æœ‰çš„åŸºæœ¬ä¿¡æ¯*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span>;</span></span><br><span class="line">    stf_status e;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pfsgroupname;</span><br><span class="line">    <span class="keyword">char</span> p2alg[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    st-&gt;st_whack_sock = whack_sock;</span><br><span class="line">    st-&gt;st_connection = c;<span class="comment">/*ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¯ä¸€ä¸ªè¿æ¥cå¯å¯¹åº”å¤šä¸ªstateç»“æ„ï¼Œæ¯”å¦‚ä¸€ä¸ªphase1,ä¸€ä¸ªphase2.å› æ­¤åœ¨éš§é“çŠ¶æ€æ—¶éœ€è¦ç‰¹åˆ«æ³¨æ„*/</span></span><br><span class="line">    passert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_calculating) &#123;</span><br><span class="line">	<span class="keyword">return</span> STF_IGNORE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* we must reset before exit */</span></span><br><span class="line">    st-&gt;st_policy = policy;</span><br><span class="line">    st-&gt;st_try = <span class="keyword">try</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">    st-&gt;sec_ctx=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(uctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    st-&gt;sec_ctx = clone_thing(*uctx, <span class="string">&quot;sec ctx structure&quot;</span>);</span><br><span class="line">    DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;pending phase 2 with security context %s, %d&quot;</span>, st-&gt;sec_ctx-&gt;sec_ctx_value, st-&gt;sec_ctx-&gt;ctx_len));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*æœ¬ç«¯åè®®ã€å¯¹ç«¯åè®®ã€æœ¬ç«¯ç«¯å£ã€å¯¹ç«¯ç«¯å£*/</span></span><br><span class="line">    st-&gt;st_myuserprotoid   = c-&gt;spd.<span class="keyword">this</span>.protocol;</span><br><span class="line">    st-&gt;st_peeruserprotoid = c-&gt;spd.that.protocol;</span><br><span class="line">    st-&gt;st_myuserport       = c-&gt;spd.<span class="keyword">this</span>.port;</span><br><span class="line">    st-&gt;st_peeruserport     = c-&gt;spd.that.port;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_msgid = generate_msgid(isakmp_sa);<span class="comment">/*éšæœºç”Ÿæˆå”¯ä¸€çš„msgid*/</span></span><br><span class="line">    change_state(st, STATE_QUICK_I1);<span class="comment">/*è®¾ç½®å½“å‰çŠ¶æ€ä¸ºSTATE_QUICK_I1*/</span></span><br><span class="line"></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(p2alg, <span class="string">&quot;defaults&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;alg_info_esp) &#123;<span class="comment">/*å°†alg_info_espä¸­çš„ç®—æ³•(ç¬¬äºŒé˜¶æ®µç®—æ³•ä¿¡æ¯)è§£æè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨p2alg*/</span></span><br><span class="line">	alg_info_snprint_phase2(p2alg, <span class="keyword">sizeof</span>(p2alg)<span class="comment">/*åªæ˜¯ä¸ºäº†æ˜¾ç¤ºä½¿ç”¨*/</span></span><br><span class="line">				, (struct alg_info_esp *)st-&gt;st_connection-&gt;alg_info_esp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pfsgroupname=<span class="string">&quot;no-pfs&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * See if pfs_group has been specified for this conn,</span></span><br><span class="line"><span class="comment">     * if not, fallback to old use-same-as-P1 behaviour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_connection) &#123;<span class="comment">/*è·å–pfsç»„*/</span></span><br><span class="line">	st-&gt;st_pfs_group = ike_alg_pfsgroup(st-&gt;st_connection</span><br><span class="line">					    , st-&gt;st_policy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If PFS specified, use the same group as during Phase 1:</span></span><br><span class="line"><span class="comment">     * since no negotiation is possible, we pick one that is</span></span><br><span class="line"><span class="comment">     * very likely supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!st-&gt;st_pfs_group)</span><br><span class="line">	    st-&gt;st_pfs_group = policy &amp; POLICY_PFS? isakmp_sa-&gt;st_oakley.group : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(policy &amp; POLICY_PFS &amp;&amp; st-&gt;st_pfs_group) &#123;</span><br><span class="line">	pfsgroupname = enum_name(&amp;oakley_group_names, st-&gt;st_pfs_group-&gt;group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> replacestr[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	replacestr[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(replacing != SOS_NOBODY)</span><br><span class="line">	    <span class="built_in">snprintf</span>(replacestr, <span class="number">32</span>, <span class="string">&quot; to replace #%lu&quot;</span>, replacing);</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Quick Mode %s%s &#123;using isakmp#%lu msgid:%08x proposal=%s pfsgroup=%s&#125;&quot;</span></span><br><span class="line">		     , prettypolicy(policy)</span><br><span class="line">		     , replacestr</span><br><span class="line">		     , isakmp_sa-&gt;st_serialno, st-&gt;st_msgid, p2alg, pfsgroupname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qke = alloc_thing(struct qke_continuation , <span class="string">&quot;quick_outI1 KE&quot;</span>);</span><br><span class="line">    qke-&gt;replacing = replacing;</span><br><span class="line">    pcrc_init(&amp;qke-&gt;qke_pcrc);</span><br><span class="line">    qke-&gt;qke_pcrc.pcrc_func = quick_outI1_continue;<span class="comment">/*å¯¹äºKEè½½è·ã€NONCEè½½è·çš„å¡«å……æ˜¯åœ¨æ­¤å›è°ƒå‡½æ•°ä¸­å®ç°çš„*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(policy &amp; POLICY_PFS) &#123;<span class="comment">/*ç”ŸæˆKEè½½è·*/</span></span><br><span class="line">	e=build_ke(&amp;qke-&gt;qke_pcrc, st, st-&gt;st_pfs_group, st-&gt;st_import);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/*ç”ŸæˆNONCEè½½è·*/</span></span><br><span class="line">	e=build_nonce(&amp;qke-&gt;qke_pcrc, st, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset_globals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™ä¸ªå‡½æ•°ä¸­åº”è¯¥æ³¨æ„åˆ°ä¸€ç‚¹ï¼šå°±æ˜¯<strong>ä¸€ä¸ªconnection(éš§é“)å¯ä»¥å¯¹åº”å¤šä¸ªstateç»“æ„</strong>ã€‚è¿™æœ‰ä»€ä¹ˆå½±å“å‘¢ï¼Ÿ</p>
<p>æˆ‘ä»¬åœ¨æŸ¥è¯¢éš§é“çŠ¶æ€æ—¶ï¼Œæ˜¯é€šè¿‡æŸ¥è¯¢è¯¥éš§é“(connection)å¯¹åº”çš„stateæ¥è·å–åˆ°åå•†çš„é˜¶æ®µï¼Œä½†æ˜¯æˆ‘ä»¬åœ¨éå†å…¨å±€stateè¡¨æ—¶åªæœ‰å…¨éƒ¨éå†ä¸€éæ‰èƒ½æŸ¥åˆ°æœ€æ–°çš„åå•†é˜¶æ®µï¼Œå¦åˆ™å¯èƒ½åªæ˜¯æŸ¥è¯¢å…¶ä¸­çš„ä¸€ä¸ªstate,è¿™ä¸ªå¯èƒ½ä¸æ˜¯æœ€æ–°çš„stateã€‚è¿™æ ·çš„è¯å¦‚æœä¸é‡‡ç”¨æ•ˆç‡é«˜çš„æ•°æ®ç»“æ„å­˜å‚¨çŠ¶æ€ï¼Œéšç€stateå¢å¤šï¼Œéå†çš„æ•ˆç‡ä¼šå¾ˆä½ã€‚</p>
<p><strong>PFSï¼ˆPerfect Forward Secrecyï¼Œå®Œå–„çš„å‰å‘å®‰å…¨æ€§ï¼‰</strong>æ˜¯ä¸€ç§å®‰å…¨ç‰¹æ€§ï¼ŒæŒ‡ä¸€ä¸ªå¯†é’¥è¢«ç ´è§£(ä¾‹å¦‚è¯´åå•†çš„ç¬¬ä¸€é˜¶æ®µç§˜é’¥è¢«ç ´è§£)ï¼Œå¹¶ä¸å½±å“ç¬¬äºŒé˜¶æ®µå¯†é’¥çš„å®‰å…¨æ€§ï¼Œå› ä¸ºè¿™äº›å¯†é’¥é—´æ²¡æœ‰æ´¾ç”Ÿå…³ç³»ã€‚æ­¤ç‰¹æ€§æ˜¯é€šè¿‡åœ¨IKEç¬¬äºŒé˜¶æ®µçš„åå•†ä¸­å¢åŠ å¯†é’¥äº¤æ¢æ¥å®ç°çš„ï¼Œå› æ­¤æºç å®ç°ä¸­ï¼Œå¦‚æœç­–ç•¥å¯åŠ¨äº†PFSï¼Œåˆ™å†æ¬¡å¢åŠ ä¸€ä¸ªKEè½½è·è¿›è¡Œç§˜é’¥äº¤æ¢ã€‚</p>
<h3 id="4-quick-outI1-continue-æºç åˆ†æ"><a href="#4-quick-outI1-continue-æºç åˆ†æ" class="headerlink" title="4. quick_outI1_continue()æºç åˆ†æ"></a>4. quick_outI1_continue()æºç åˆ†æ</h3><p>è¿™ä¸ªcontinueå‡½æ•°ä¸ä¹‹å‰çš„å‡½æ•°åŠŸèƒ½åŸºæœ¬ä¸€è‡´ï¼Œé€šè¿‡pcrcä¸­çš„çŠ¶æ€åºå·è·å–åˆ°ç›¸åº”çš„çŠ¶æ€ï¼Œç„¶åè°ƒç”¨åç»­çš„å‡½æ•°è¿›è¡ŒæŠ¥æ–‡å°è£…æ“ä½œã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">quick_outI1_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span> =</span> (struct qke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> state_with_serialno(qke-&gt;qke_pcrc.pcrc_serialno);<span class="comment">/*ä¸€ä¸ªæ•ˆç‡æ¯”è¾ƒä½çš„æ¥å£*/</span></span><br><span class="line">    stf_status e;</span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROLMORE</span><br><span class="line">	, DBG_log(<span class="string">&quot;quick outI1: calculated ke+nonce, sending I1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: Request was disconnected from state&quot;</span>,</span><br><span class="line">		__FUNCTION__);</span><br><span class="line">	<span class="keyword">if</span> (qke-&gt;md)</span><br><span class="line">	    release_md(qke-&gt;md);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_calculating = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX should check out ugh */</span></span><br><span class="line">    passert(ugh == <span class="literal">NULL</span>);</span><br><span class="line">    passert(cur_state == <span class="literal">NULL</span>);</span><br><span class="line">    passert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* we must reset before exit */</span></span><br><span class="line">    set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">    e = quick_outI1_tail(pcrc, r, st);</span><br><span class="line">    <span class="keyword">if</span> (e == STF_INTERNAL_ERROR)</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: quick_outI1_tail() failed with STF_INTERNAL_ERROR&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    reset_globals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>è¿™ä¸ªæœ‰ä¸€ä¸ªéœ€è¦è¯´æ˜çš„åœ°æ–¹ï¼Œ<code>state_with_serialno</code>å‡½æ•°éœ€è¦éå†å…¨å±€stateå“ˆå¸Œè¡¨ï¼Œè™½ç„¶O(n)çš„æ—¶é—´å¤æ‚åº¦ï¼Œä½†æ˜¯å¦‚æœstateç»“æ„éå¸¸å¤šçš„æƒ…å†µä¸‹ï¼Œæ•ˆç‡å¾ˆä½ã€‚å› æ­¤å¦‚æœåº”ç”¨åœºæ™¯ä¸­å¯æ·»åŠ çš„éš§é“æ¯”è¾ƒå¤š(æˆç™¾ä¸Šåƒæ¡)ï¼Œé‚£ä¹ˆéœ€è¦å¯¹è¯¥æ¥å£è¿›è¡Œä¼˜åŒ–ã€‚</p>
<p><code>state_with_serialno()</code>æºç å®ç°å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the state object with this serial number.</span></span><br><span class="line"><span class="comment"> * This allows state object references that don&#x27;t turn into dangerous</span></span><br><span class="line"><span class="comment"> * dangling pointers: reference a state by its serial number.</span></span><br><span class="line"><span class="comment"> * Returns NULL if there is no such state.</span></span><br><span class="line"><span class="comment"> * If this turns out to be a significant CPU hog, it could be</span></span><br><span class="line"><span class="comment"> * improved to use a hash table rather than sequential seartch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct state *</span></span><br><span class="line"><span class="function"><span class="title">state_with_serialno</span><span class="params">(<span class="keyword">so_serial_t</span> sn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sn &gt;= SOS_FIRST)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; STATE_TABLE_SIZE; i++)</span><br><span class="line">	    <span class="keyword">for</span> (st = statetable[i]; st != <span class="literal">NULL</span>; st = st-&gt;st_hashchain_next)</span><br><span class="line">		<span class="keyword">if</span> (st-&gt;st_serialno == sn)</span><br><span class="line">		    <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-quick-outI1-tail-æºç åˆ†æ"><a href="#5-quick-outI1-tail-æºç åˆ†æ" class="headerlink" title="5. quick_outI1_tail()æºç åˆ†æ"></a>5. quick_outI1_tail()æºç åˆ†æ</h3><p>quick_outI1_tail()å‡½æ•°çš„ä½œç”¨ï¼šæ„é€ ç¬¬äºŒé˜¶æ®µé¦–åŒ…æŠ¥æ–‡ï¼Œä»–åŒ…æ‹¬ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> ç¬¬äºŒé˜¶æ®µçš„åŠ è§£å¯†ç®—æ³•ã€å“ˆå¸Œ(è®¤è¯)ç®—æ³•ã€PFSç­‰ç­–ç•¥ä¿¡æ¯<ul>
<li><input disabled="" type="checkbox"> <strong>æ„é€ SAå»ºè®®è½½è·out_sa()</strong></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> å¦‚æœå¯åŠ¨PFSï¼Œåˆ™é‡æ–°è¿›è¡Œç§˜é’¥äº¤æ¢ï¼Œç”ŸæˆKEè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> ç”ŸæˆNonceè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> æ„é€ æœ¬ç«¯æ ‡è¯†å’Œå¯¹ç«¯æ ‡è¯†è½½è·</li>
<li><input checked="" disabled="" type="checkbox"> NATç©¿è¶Šä¸­çš„ OAè½½è·</li>
<li><input checked="" disabled="" type="checkbox"> ==è®¡ç®—æŠ¥æ–‡çš„å®Œæ•´æ€§(å“ˆå¸Œç®—æ³•)==</li>
<li><input checked="" disabled="" type="checkbox"> ==å¯¹æŠ¥æ–‡è¿›è¡ŒåŠ å¯†==</li>
</ul>
<p>æºç å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_outI1_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">		 , struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span> =</span> (struct qke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">isakmp_sa</span> =</span> state_with_serialno(st-&gt;st_clonedfrom);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span> =</span> st-&gt;st_connection;</span><br><span class="line">    pb_stream rbody;</span><br><span class="line">    u_char	<span class="comment">/* set by START_HASH_PAYLOAD: */</span></span><br><span class="line">	*r_hashval,	<span class="comment">/* where in reply to jam hash value */</span></span><br><span class="line">	*r_hash_start;	<span class="comment">/* start of what is to be hashed */</span><span class="comment">/*ç”¨æ¥è®°å½•éœ€è¦è®¡ç®—hashçš„èµ·å§‹ä½ç½®*/</span></span><br><span class="line">    <span class="keyword">bool</span> has_client = c-&gt;spd.<span class="keyword">this</span>.has_client || c-&gt;spd.that.has_client ||</span><br><span class="line">		      	     c-&gt;spd.<span class="keyword">this</span>.protocol    || c-&gt;spd.that.protocol   ||</span><br><span class="line">		            c-&gt;spd.<span class="keyword">this</span>.port         || c-&gt;spd.that.port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isakmp_sa == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* phase1 state got deleted while cryptohelper was working */</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS,<span class="string">&quot;phase2 initiation failed because parent ISAKMP #%lu is gone&quot;</span>, st-&gt;st_clonedfrom);</span><br><span class="line">	<span class="keyword">return</span> STF_FATAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (isakmp_sa-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_DETECTED) &#123;<span class="comment">/*ç¬¬ä¸€é˜¶æ®µåå•†è¿‡ç¨‹ä¸­å‘ç°å­˜åœ¨NATè®¾å¤‡*/</span></span><br><span class="line">       <span class="comment">/* Duplicate nat_traversal status in new state */</span><span class="comment">/*å°†NATä¿¡æ¯å­˜å‚¨åœ¨æ–°çš„stateä¸Š*/</span></span><br><span class="line">       st-&gt;hidden_variables.st_nat_traversal = isakmp_sa-&gt;hidden_variables.st_nat_traversal;</span><br><span class="line">       <span class="keyword">if</span> (isakmp_sa-&gt;hidden_variables.st_nat_traversal &amp; LELEM(NAT_TRAVERSAL_NAT_BHND_ME)) &#123;<span class="comment">/*æœ¬ç«¯ä½äºNATä¹‹å*/</span></span><br><span class="line"> 	  has_client = TRUE;</span><br><span class="line">       &#125;<span class="comment">/*ç¡®å®šç«¯å£æµ®åŠ¨åçš„å‡ºæ¥å£*/</span></span><br><span class="line">       nat_traversal_change_port_lookup(<span class="literal">NULL</span>, st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       st-&gt;hidden_variables.st_nat_traversal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set up reply */</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out */</span><span class="comment">/*å¡«å……ç¬¬äºŒé˜¶æ®µçš„ISAKMPçš„å¤´éƒ¨*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	hdr.isa_version = ISAKMP_MAJOR_VERSION &lt;&lt; ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION;</span><br><span class="line">	hdr.isa_np = ISAKMP_NEXT_HASH;</span><br><span class="line">	hdr.isa_xchg = ISAKMP_XCHG_QUICK;</span><br><span class="line">	hdr.isa_msgid = st-&gt;st_msgid;</span><br><span class="line">	hdr.isa_flags = ISAKMP_FLAG_ENCRYPTION;</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_icookie, st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_rcookie, st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;rbody))<span class="comment">/*å¡«å……åˆ°æŠ¥æ–‡ä¸­*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*å¡«å……hashè½½è·å¤´éƒ¨ï¼Œæ•°æ®éƒ¨åˆ†å…¨é›¶ï¼Œå¹¶è®°å½•ä¸‹è¦å¡«å……hashçš„ä½ç½®ï¼Œæœ€åå¡«å……*/</span></span><br><span class="line">    <span class="comment">/* HASH(1) -- create and note space to be filled later */</span></span><br><span class="line">    START_HASH_PAYLOAD(rbody, ISAKMP_NEXT_SA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA out */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Emit SA payload based on a subset of the policy bits.</span></span><br><span class="line"><span class="comment">     * POLICY_COMPRESS is considered iff we can do IPcomp.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lset_t</span> pm = POLICY_ENCRYPT | POLICY_AUTHENTICATE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_do_IPcomp)</span><br><span class="line">            pm |= POLICY_COMPRESS;</span><br><span class="line">    <span class="comment">/*å¡«å……saè½½è·: ESP AH IPCom*/</span></span><br><span class="line">        <span class="keyword">if</span> (!out_sa(&amp;rbody</span><br><span class="line">                , &amp;ipsec_sadb[(st-&gt;st_policy &amp; pm) &gt;&gt; POLICY_IPSEC_SHIFT]</span><br><span class="line">                , st, FALSE, FALSE, ISAKMP_NEXT_NONCE))</span><br><span class="line">        &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> np;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st-&gt;st_policy &amp; POLICY_PFS) &#123;<span class="comment">/*å¦‚æœä½¿ç”¨PFS,åˆ™éœ€è¦å†æ¬¡DHåå•†*/</span></span><br><span class="line">            np = ISAKMP_NEXT_KE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(has_client) &#123;</span><br><span class="line">            np = ISAKMP_NEXT_ID;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            np = ISAKMP_NEXT_NONE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ni out */</span><span class="comment">/*å¡«å……Nonceè½½è·ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨st_niä¸­*/</span></span><br><span class="line">        <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;rbody</span><br><span class="line">                , np</span><br><span class="line">                , <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [ KE ] out (for PFS) */</span><span class="comment">/*å¡«å……KEè½½è·ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨st_gi*/</span></span><br><span class="line">        <span class="keyword">if</span> (st-&gt;st_pfs_group != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ship_KE(st, r, &amp;st-&gt;st_gi</span><br><span class="line">                     , &amp;rbody</span><br><span class="line">                     , has_client? ISAKMP_NEXT_ID : ISAKMP_NEXT_NONE))</span><br><span class="line">            &#123;</span><br><span class="line">                reset_cur_state();</span><br><span class="line">                <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [ IDci, IDcr ] out */</span></span><br><span class="line">        <span class="keyword">if</span> (has_client)<span class="comment">/*å¡«å……çš„å­ç½‘ID*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* IDci (we are initiator), then IDcr (peer is responder) */</span></span><br><span class="line">            <span class="keyword">if</span> (!emit_subnet_id(&amp;c-&gt;spd.<span class="keyword">this</span><span class="comment">/*æœ¬ç«¯èº«ä»½æ ‡è¯†*/</span></span><br><span class="line">                        , ISAKMP_NEXT_ID</span><br><span class="line">                                    , st-&gt;st_localaddr</span><br><span class="line">                        , st-&gt;st_myuserprotoid</span><br><span class="line">                        , st-&gt;st_myuserport, &amp;rbody)</span><br><span class="line">                || !emit_subnet_id(&amp;c-&gt;spd.that<span class="comment">/*å¯¹ç«¯èº«ä»½æ ‡è¯†*/</span></span><br><span class="line">                           , ISAKMP_NEXT_NONE</span><br><span class="line">                                       , st-&gt;st_remoteaddr</span><br><span class="line">                           , st-&gt;st_peeruserprotoid</span><br><span class="line">                           , st-&gt;st_peeruserport, &amp;rbody))</span><br><span class="line">            &#123;</span><br><span class="line">                reset_cur_state();</span><br><span class="line">                <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> ((st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATOA)</span><br><span class="line">	&amp;&amp; (!(st-&gt;st_policy &amp; POLICY_TUNNEL))<span class="comment">/*åªæœ‰ä¼ è¾“æ¨¡å¼æ‰éœ€è¦OAè½½è·????*/</span></span><br><span class="line">	&amp;&amp; (st-&gt;hidden_variables.st_nat_traversal &amp; LELEM(NAT_TRAVERSAL_NAT_BHND_ME))) &#123;</span><br><span class="line">    <span class="comment">/** Send NAT-OA if our address is NATed */</span><span class="comment">/*å¡«å……OAè½½è·ï¼Œè¿™é‡Œéœ€è¦ä¿®æ”¹ä¸Šä¸€ä¸ªè½½è·çš„NP*/</span></span><br><span class="line">        <span class="keyword">if</span> (!nat_traversal_add_natoa(ISAKMP_NEXT_NONE, &amp;rbody, st, TRUE <span class="comment">/* initiator */</span>)) &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>,st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line">	r_hashval = tpm_relocateHash(pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish computing  HASH(1), inserting it in output */</span><span class="comment">/*è®¡ç®—æ•´ä¸ªè½½è·çš„å“ˆå¸Œå€¼*/</span></span><br><span class="line">    (<span class="keyword">void</span>) quick_mode_hash12(r_hashval, r_hash_start, rbody.cur</span><br><span class="line">	, st, &amp;st-&gt;st_msgid, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line"><span class="comment">/*è®¾ç½®ç¬¬äºŒé˜¶æ®µçš„IVå€¼*/</span></span><br><span class="line">	</span><br><span class="line">    init_phase2_iv(isakmp_sa, &amp;st-&gt;st_msgid);</span><br><span class="line">    st-&gt;st_new_iv_len = isakmp_sa-&gt;st_new_iv_len;</span><br><span class="line">    set_new_iv(st, isakmp_sa-&gt;st_new_iv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;rbody, st))<span class="comment">/*åŠ å¯†é™¤æŠ¥æ–‡å¤´éƒ¨ä»¥å¤–çš„æ‰€æœ‰è½½è·*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	reset_cur_state();</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save packet, now that we know its size ä¿ç•™æ•°æ®åŒ…ï¼Œè¶…æ—¶é‡ä¼ ä¼šä½¿ç”¨åˆ°*/</span></span><br><span class="line">    clonetochunk(st-&gt;st_tpacket, reply_stream.start, pbs_offset(&amp;reply_stream)</span><br><span class="line">	, <span class="string">&quot;reply packet from quick_outI1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send the packet */</span></span><br><span class="line">    <span class="comment">/*å‘é€æŠ¥æ–‡ï¼Œå¦‚æœä½¿ç”¨äº†NAT-T,åˆ™ä¼šæ·»åŠ Non-ESPçš„å°è£…*/</span></span><br><span class="line">    send_packet(st, <span class="string">&quot;quick_outI1&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">    delete_event(st);<span class="comment">/*è®¾ç½®è¶…æ—¶é‡ä¼ äº‹ä»¶*/</span></span><br><span class="line">    event_schedule(EVENT_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qke-&gt;replacing == SOS_NOBODY)</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_QUICK_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_QUICK_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate to replace #%lu&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state)</span><br><span class="line">	    , qke-&gt;replacing);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>ä¸‹é¢å¯¹<code>quick_outI1_tail()</code>ä¸­çš„å‡ ä¸ªé‡è¦å‡½æ•°åšä¸ªç®€å•è¯´æ˜ï¼š</p>
<h4 id="5-1-out-sa"><a href="#5-1-out-sa" class="headerlink" title="5.1 out_sa()"></a>5.1 out_sa()</h4><p>è¿™ä¸ªå‡½æ•°åœ¨ç¬¬ä¸€é˜¶æ®µçš„å‰ä¸¤ä¸ªæŠ¥æ–‡ä¸­ä½¿ç”¨è¿‡ï¼Œå½“æ—¶ä½¿ç”¨çš„ç¬¬ä¸€é˜¶æ®µçš„SAè½½è·ï¼Œç°åœ¨ä½¿ç”¨ç¬¬äºŒé˜¶æ®µçš„SAè½½è·ï¼›<code>out_sa</code>åŒæ—¶å®ç°äº†ç¬¬ä¸€é˜¶æ®µå’Œç¬¬äºŒé˜¶æ®µSAè½½è·å°è£…çš„åŠŸèƒ½ï¼Œå®ƒé€šè¿‡<code>bool oakley_mode</code>å‚æ•°æ¥ç¡®å®šä½¿ç”¨ç¬¬ä¸€é˜¶æ®µè¿˜æ˜¯ç¬¬äºŒé˜¶æ®µçš„å°è£…æµç¨‹ã€‚å¦‚æœè¯´<code>out_struct</code>ç­‰å°è£…æ¥å£å·²ç»æ¯”è¾ƒç†Ÿçš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°å¯èƒ½ä¼šæ¯”è¾ƒå®¹æ˜“ï¼Œå¦åˆ™åŸºæœ¬æµç¨‹çœ‹èµ·æ¥è¿˜æ˜¯æœ‰ç‚¹åƒåŠ›ã€‚è¿™é‡Œåªç®€å•è¯´æ˜<code>out_struct</code>å„ä¸ªå‚æ•°çš„ä½œç”¨ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">å°†struct_ptræŒ‰ç…§sdçš„æè¿°æ–¹å¼æ‹·è´åˆ°outsä¸­ã€‚åŒæ—¶å¦‚æœobj_pbså­˜åœ¨ï¼Œ</span></span><br><span class="line"><span class="comment">åˆ™ä½¿obj_pbsæŒ‡å‘outsæ•°æ®éƒ¨åˆ†ï¼Œå¹¶æ›´æ–°obj_pbsçš„curæŒ‡é’ˆåˆ°æ–°å¡«å……çš„ä½ç½®ï¼Œ</span></span><br><span class="line"><span class="comment">ç„¶åå°†outsçš„curè®¾ç½®åˆ°æœ€å¤§ï¼Œå…¶ä»–å‡½æ•°ä¸å¾—å†æ“ä½œouts,é™¤éä½¿ç”¨close_output_pbsæ›´æ–°æ‰è¡Œ</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_struct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *struct_ptr, struct_desc *sd, pb_stream *outs, pb_stream *obj_pbs)</span></span></span><br></pre></td></tr></table></figure>

<p>openswanæºç åœ¨å¯¹é½ä¸Šåšçš„ä¸æ•¢æ­ç»´ï¼Œè€Œä»£ç æ˜¯ä¸å¿å’è¯»(çœ‹ä¸æ‡‚<img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1.assets%5C433F992D.gif" alt="img">)ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_sa</span><span class="params">(pb_stream *outs</span></span></span><br><span class="line"><span class="params"><span class="function">       , struct db_sa *sadb</span></span></span><br><span class="line"><span class="params"><span class="function">       , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">bool</span> oakley_mode</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">bool</span> aggressive_mode UNUSED</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">u_int8_t</span> np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pb_stream sa_pbs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pcn;</span><br><span class="line">    <span class="keyword">bool</span> ret = FALSE;</span><br><span class="line">    <span class="keyword">bool</span> ah_spi_generated = FALSE</span><br><span class="line">          , esp_spi_generated = FALSE</span><br><span class="line">          , ipcomp_cpi_generated = FALSE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">revised_sadb</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oakley_mode) &#123;</span><br><span class="line"><span class="comment">/* Aggr-Mode - Max transforms == 2 - Multiple transforms, 1 DH group */</span></span><br><span class="line"><span class="comment">/*æ ¹æ®é…ç½®çš„ç§˜é’¥ç®—æ³•ä¿¡æ¯é‡æ–°ç”Ÿæˆä¸€ä¸ªsadbä¿¡æ¯*/</span></span><br><span class="line"><span class="comment">/*ä¼ å…¥çš„sadbåº”è¯¥ä¸ºå›ºå®šçš„ç§˜é’¥ç®—æ³•ä¿¡æ¯ï¼Œå› æ­¤éœ€è¦æ ¹æ®ç­–ç•¥æ¥é‡æ–°ç”Ÿæˆä¸€ä¸ªæ–°çš„sadb*/</span></span><br><span class="line">      revised_sadb = oakley_alg_makedb(st-&gt;st_connection-&gt;alg_info_ike<span class="comment">/*ç¬¬ä¸€é˜¶æ®µç®—æ³•*/</span></span><br><span class="line">                                               , sadb</span><br><span class="line">                                               , aggressive_mode ? <span class="number">2</span> : <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/*æ ¹æ®é…ç½®ç”Ÿæˆç¬¬äºŒé˜¶æ®µçš„ç®—æ³•ä¿¡æ¯*/</span></span><br><span class="line">      revised_sad = kernel_alg_makedb(st-&gt;st_connection-&gt;policy</span><br><span class="line">                   , st-&gt;st_connection-&gt;alg_info_esp<span class="comment">/*ç¬¬äºŒé˜¶æ®µç®—æ³•*/</span></span><br><span class="line">                   , TRUE);</span><br><span class="line">		<span class="comment">/*IPCompä»£ç ç•¥*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* more sanity */</span></span><br><span class="line">    <span class="keyword">if</span>(revised_sadb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          sadb = revised_sadb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA header out */</span></span><br><span class="line">    &#123;<span class="comment">/*æ·»åŠ SAå¤´éƒ¨*/</span></span><br><span class="line"><span class="comment">/*                      1                   2                   3</span></span><br><span class="line"><span class="comment"> *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * ! Next Payload  !   RESERVED    !         Payload Length        !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * !              Domain of Interpretation  (DOI)                  !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * !                                                               !</span></span><br><span class="line"><span class="comment"> * ~                           Situation                           ~</span></span><br><span class="line"><span class="comment"> * !                                                               !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_sa</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">          sa.isasa_np = np;</span><br><span class="line">          st-&gt;st_doi = sa.isasa_doi = ISAKMP_DOI_IPSEC; <span class="comment">/* all we know */</span></span><br><span class="line">          <span class="keyword">if</span> (!out_struct(&amp;sa, &amp;isakmp_sa_desc, outs, &amp;sa_pbs))</span><br><span class="line">              return_on(ret, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* within SA: situation out */</span><span class="comment">/*å¡«å……ä¸Šå›¾ä¸­çš„Situationå­—æ®µ*/</span></span><br><span class="line">    st-&gt;st_situation = SIT_IDENTITY_ONLY;</span><br><span class="line">    <span class="keyword">if</span> (!out_struct(&amp;st-&gt;st_situation, &amp;ipsec_sit_desc, &amp;sa_pbs, <span class="literal">NULL</span>))</span><br><span class="line">          return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* within SA: Proposal Payloads   å»ºè®®è½½è·</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Multiple Proposals with the same number are simultaneous</span></span><br><span class="line"><span class="comment">     * (conjuncts) and must deal with different protocols (AH or ESP).</span></span><br><span class="line"><span class="comment">     * Proposals with different numbers are alternatives (disjuncts),</span></span><br><span class="line"><span class="comment">     * in preference order.</span></span><br><span class="line"><span class="comment">     * Proposal numbers must be monotonic.</span></span><br><span class="line"><span class="comment">     * See RFC 2408 &quot;ISAKMP&quot; 4.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pcn = <span class="number">0</span>; pcn &lt; sadb-&gt;prop_conj_cnt; pcn++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">db_prop_conj</span> *<span class="title">pc</span>;</span></span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> pn;</span><br><span class="line">          <span class="keyword">int</span> valid_prop_cnt;</span><br><span class="line"></span><br><span class="line">          pc = &amp;sadb-&gt;prop_conjs[pcn];<span class="comment">/*éå†å»ºè®®è½½è·*/</span></span><br><span class="line">          valid_prop_cnt = pc-&gt;prop_cnt;</span><br><span class="line">          DBG(DBG_EMITTING,</span><br><span class="line">              DBG_log(<span class="string">&quot;out_sa pcn: %d has %d valid proposals&quot;</span>,</span><br><span class="line">                        pcn, valid_prop_cnt));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (pn = <span class="number">0</span>; pn &lt; pc-&gt;prop_cnt; pn++)<span class="comment">/*éå†å»ºè®®è½½è·*/</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="class"><span class="keyword">struct</span> <span class="title">db_prop</span> *<span class="title">p</span>;</span></span><br><span class="line">              pb_stream proposal_pbs;</span><br><span class="line">              <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_proposal</span> <span class="title">proposal</span>;</span></span><br><span class="line">              struct_desc *trans_desc;</span><br><span class="line">              struct_desc *attr_desc;</span><br><span class="line">              enum_names **attr_val_descs;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> tn;</span><br><span class="line">              <span class="keyword">bool</span> tunnel_mode;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * set the tunnel_mode bit on the last proposal only, and</span></span><br><span class="line"><span class="comment">               * only if we are trying to negotiate tunnel mode in the first</span></span><br><span class="line"><span class="comment">               * place.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              tunnel_mode = (valid_prop_cnt == <span class="number">1</span>)</span><br><span class="line">                    &amp;&amp; (st-&gt;st_policy &amp; POLICY_TUNNEL);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * pick the part of the proposal we are trying to work on</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		 <span class="comment">/*                      1                   2                   3</span></span><br><span class="line"><span class="comment">		 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * ! Next Payload  !   RESERVED    !         Payload Length        !</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * !  Proposal #   !  Protocol-Id  !    SPI Size   !# of Transforms!</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * !                        SPI (variable)                         !</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">			  </span><br><span class="line">              p = &amp;pc-&gt;props[pn];</span><br><span class="line"></span><br><span class="line">              proposal.isap_proposal = pcn;</span><br><span class="line">              proposal.isap_protoid = p-&gt;protoid;</span><br><span class="line">              proposal.isap_spisize = oakley_mode ? <span class="number">0</span></span><br><span class="line">                    : p-&gt;protoid == PROTO_IPCOMP ? IPCOMP_CPI_SIZE</span><br><span class="line">                    : IPSEC_DOI_SPI_SIZE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* but, skip things if the transform count is zero */</span></span><br><span class="line">              <span class="keyword">if</span>(p-&gt;trans_cnt == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Proposal header */</span></span><br><span class="line">              <span class="keyword">if</span>(--valid_prop_cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    proposal.isap_np = ISAKMP_NEXT_P;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    proposal.isap_np = ISAKMP_NEXT_NONE;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              proposal.isap_notrans = p-&gt;trans_cnt;<span class="comment">/*å˜æ¢è½½è·çš„ä¸ªæ•°*/</span></span><br><span class="line">              <span class="keyword">if</span> (!out_struct(&amp;proposal, &amp;isakmp_proposal_desc</span><br><span class="line">                                  , &amp;sa_pbs, &amp;proposal_pbs))</span><br><span class="line">                    return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Per-protocols stuff:</span></span><br><span class="line"><span class="comment">       * Set trans_desc.</span></span><br><span class="line"><span class="comment">       * Set attr_desc.</span></span><br><span class="line"><span class="comment">       * Set attr_val_descs.</span></span><br><span class="line"><span class="comment">       * If not oakley_mode, emit SPI.</span></span><br><span class="line"><span class="comment">       * We allocate SPIs on demand.</span></span><br><span class="line"><span class="comment">       * All ESPs in an SA will share a single SPI.</span></span><br><span class="line"><span class="comment">       * All AHs in an SAwill share a single SPI.</span></span><br><span class="line"><span class="comment">       * AHs&#x27; SPI will be distinct from ESPs&#x27;.</span></span><br><span class="line"><span class="comment">       * This latter is needed because KLIPS doesn&#x27;t</span></span><br><span class="line"><span class="comment">       * use the protocol when looking up a (dest, protocol, spi).</span></span><br><span class="line"><span class="comment">       * ??? If multiple ESPs are composed, how should their SPIs</span></span><br><span class="line"><span class="comment">       * be allocated?</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       &#123;</span><br><span class="line">		  <span class="class"><span class="keyword">struct</span> <span class="title">ipsec_proto_info</span> *<span class="title">pi</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		  <span class="keyword">int</span> proto = <span class="number">0</span>;</span><br><span class="line">		  <span class="keyword">bool</span> *spi_generated;</span><br><span class="line"></span><br><span class="line">                    spi_generated = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> (p-&gt;protoid)</span><br><span class="line">                    &#123;</span><br><span class="line">	                    <span class="keyword">case</span> PROTO_ISAKMP:</span><br><span class="line">	                        passert(oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_isakmp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_oakley_attribute_desc;</span><br><span class="line">	                        attr_val_descs = oakley_attr_val_descs;</span><br><span class="line">	                        <span class="comment">/* no SPI needed */</span></span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/*ç¬¬äºŒé˜¶æ®µæ—¶ï¼Œåœ¨kernel_alg_db_newä¸­æ ¹æ®ç­–ç•¥é…ç½®é€‰æ‹©é‡‡ç”¨çš„å°è£…æ–¹å¼*/</span></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPSEC_AH:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_ah_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line">				pi = &amp;st-&gt;st_ah;</span><br><span class="line">	                        spi_generated = &amp;ah_spi_generated;</span><br><span class="line">	                        proto = IPPROTO_AH;</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPSEC_ESP:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_esp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line">				pi = &amp;st-&gt;st_esp;</span><br><span class="line">	                        spi_generated = &amp;esp_spi_generated;</span><br><span class="line">	                        proto = IPPROTO_ESP;</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPCOMP:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_ipcomp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line"></span><br><span class="line">	                        <span class="comment">/* a CPI isn&#x27;t quite the same as an SPI</span></span><br><span class="line"><span class="comment">	                         * so we use specialized code to emit it.</span></span><br><span class="line"><span class="comment">	                         */</span></span><br><span class="line">	                        <span class="keyword">if</span> (!ipcomp_cpi_generated)</span><br><span class="line">	                        &#123;</span><br><span class="line">	                              st-&gt;st_ipcomp.our_spi = get_my_cpi(st, tunnel_mode);</span><br><span class="line">	                              <span class="keyword">if</span> (st-&gt;st_ipcomp.our_spi == <span class="number">0</span>)</span><br><span class="line">	                                  return_on(ret, FALSE);          <span class="comment">/* problem generating CPI */</span></span><br><span class="line"></span><br><span class="line">	                              ipcomp_cpi_generated = TRUE;</span><br><span class="line">	                        &#125;</span><br><span class="line">	                        <span class="comment">/* CPI is stored in network low order end of an</span></span><br><span class="line"><span class="comment">	                         * ipsec_spi_t.  So we start a couple of bytes in.</span></span><br><span class="line"><span class="comment">	                         */</span></span><br><span class="line">	                        <span class="keyword">if</span> (!out_raw((u_char *)&amp;st-&gt;st_ipcomp.our_spi</span><br><span class="line">	                         + IPSEC_DOI_SPI_SIZE - IPCOMP_CPI_SIZE</span><br><span class="line">	                        , IPCOMP_CPI_SIZE</span><br><span class="line">	                        , &amp;proposal_pbs, <span class="string">&quot;CPI&quot;</span>))</span><br><span class="line">	                              return_on(ret, FALSE);</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">default</span>:</span><br><span class="line">	                        bad_case(p-&gt;protoid);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pi != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">	                        <span class="keyword">if</span> (spi_generated != <span class="literal">NULL</span> &amp;&amp; !*spi_generated)</span><br><span class="line">	                        &#123;</span><br><span class="line">					    <span class="keyword">if</span> (!get_ipsec_spi(pi</span><br><span class="line">							       , proto</span><br><span class="line">							       , st</span><br><span class="line">							       , tunnel_mode)) &#123;</span><br><span class="line">						<span class="keyword">return</span> FALSE;</span><br><span class="line">					    &#125;</span><br><span class="line">					    *spi_generated = TRUE;</span><br><span class="line">	                        &#125;</span><br><span class="line">	                        <span class="keyword">if</span> (!out_raw((u_char *)&amp;pi-&gt;our_spi, IPSEC_DOI_SPI_SIZE</span><br><span class="line">					     , &amp;proposal_pbs, <span class="string">&quot;SPI&quot;</span>))</span><br><span class="line">				    	return_on(ret, FALSE);</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* å¡«å……å˜æ¢è½½è· within proposal: Transform Payloads */</span></span><br><span class="line">              <span class="keyword">for</span> (tn = <span class="number">0</span>; tn != p-&gt;trans_cnt; tn++)</span><br><span class="line">              &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">db_trans</span> *<span class="title">t</span> =</span> &amp;p-&gt;trans[tn];</span><br><span class="line">                    pb_stream trans_pbs;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_transform</span> <span class="title">trans</span>;</span></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> an;</span><br><span class="line"></span><br><span class="line">                    trans.isat_np = (tn == p-&gt;trans_cnt - <span class="number">1</span>)</span><br><span class="line">                        ? ISAKMP_NEXT_NONE : ISAKMP_NEXT_T;</span><br><span class="line">                    trans.isat_transnum = tn;</span><br><span class="line">                    trans.isat_transid = t-&gt;transid;</span><br><span class="line">                    <span class="keyword">if</span> (!out_struct(&amp;trans, trans_desc, &amp;proposal_pbs, &amp;trans_pbs))</span><br><span class="line">                        return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Within tranform: Attributes. */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* For Phase 2 / Quick Mode, GROUP_DESCRIPTION is</span></span><br><span class="line"><span class="comment">                     * automatically generated because it must be the same</span></span><br><span class="line"><span class="comment">                     * in every transform.  Except IPCOMP.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;protoid != PROTO_IPCOMP</span><br><span class="line">                    &amp;&amp; st-&gt;st_pfs_group != <span class="literal">NULL</span>)<span class="comment">/*æ·»åŠ PFSç»„å±æ€§ä¿¡æ¯*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        passert(!oakley_mode);</span><br><span class="line">                        passert(st-&gt;st_pfs_group != &amp;unset_group);</span><br><span class="line">                        out_attr(GROUP_DESCRIPTION, st-&gt;st_pfs_group-&gt;group</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* automatically generate duration</span></span><br><span class="line"><span class="comment">                     * and, for Phase 2 / Quick Mode, encapsulation.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (oakley_mode)<span class="comment">/*ç¬¬ä¸€é˜¶æ®µ*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        out_attr(OAKLEY_LIFE_TYPE, OAKLEY_LIFE_SECONDS</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                        out_attr(OAKLEY_LIFE_DURATION</span><br><span class="line">                              , st-&gt;st_connection-&gt;sa_ike_life_seconds</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">/*ç¬¬äºŒé˜¶æ®µ*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* RFC 2407 (IPSEC DOI) 4.5 specifies that</span></span><br><span class="line"><span class="comment">                         * the default is &quot;unspecified (host-dependent)&quot;.</span></span><br><span class="line"><span class="comment">                         * This makes little sense, so we always specify it.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * Unlike other IPSEC transforms, IPCOMP defaults</span></span><br><span class="line"><span class="comment">                         * to Transport Mode, so we can exploit the default</span></span><br><span class="line"><span class="comment">                         * (draft-shacham-ippcp-rfc2393bis-05.txt 4.1).</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;protoid != PROTO_IPCOMP</span><br><span class="line">                        || st-&gt;st_policy &amp; POLICY_TUNNEL)</span><br><span class="line">                        &#123;</span><br><span class="line">							<span class="comment">/*éš§é“æ¨¡å¼? ä¼ è¾“æ¨¡å¼*/</span></span><br><span class="line">                            out_attr(ENCAPSULATION_MODE</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> I_KNOW_TRANSPORT_MODE_HAS_SECURITY_CONCERN_BUT_I_WANT_IT</span></span><br><span class="line">                                  , NAT_T_ENCAPSULATION_MODE(st,st-&gt;st_policy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                          <span class="comment">/* If NAT-T is detected, use UDP_TUNNEL as long as Transport</span></span><br><span class="line"><span class="comment">                           * Mode has security concerns.</span></span><br><span class="line"><span class="comment">                           *</span></span><br><span class="line"><span class="comment">                           * User has been informed of that</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line">                                  , NAT_T_ENCAPSULATION_MODE(st,POLICY_TUNNEL)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ! NAT_TRAVERSAL */</span></span></span><br><span class="line">                                  , st-&gt;st_policy &amp; POLICY_TUNNEL</span><br><span class="line">                                    ? ENCAPSULATION_MODE_TUNNEL : 			ENCAPSULATION_MODE_TRANSPORT</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                                  , attr_desc, attr_val_descs</span><br><span class="line">                                  , &amp;trans_pbs);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out_attr(SA_LIFE_TYPE, SA_LIFE_TYPE_SECONDS <span class="comment">/*å•ä½:ç§’*/</span> </span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                        out_attr(SA_LIFE_DURATION</span><br><span class="line">                              , st-&gt;st_connection-&gt;sa_ipsec_life_seconds <span class="comment">/*ç”Ÿå­˜æ—¶é—´ä»è¿æ¥ä¸Šè·å–*/</span></span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* spit out attributes from table */</span></span><br><span class="line">                    <span class="keyword">for</span> (an = <span class="number">0</span>; an != t-&gt;attr_cnt; an++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">db_attr</span> *<span class="title">a</span> =</span> &amp;t-&gt;attrs[an];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(oakley_mode) &#123;</span><br><span class="line">                              out_attr(a-&gt;type.oakley, a-&gt;val</span><br><span class="line">                                         , attr_desc, attr_val_descs</span><br><span class="line">                                         , &amp;trans_pbs);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           out_attr(a-&gt;type.ipsec,  a-&gt;val , attr_desc, attr_val_descs , &amp;trans_pbs);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    close_output_pbs(&amp;trans_pbs);</span><br><span class="line">              &#125;</span><br><span class="line">              close_output_pbs(&amp;proposal_pbs);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* end of a conjunction of proposals */</span></span><br><span class="line">    &#125;</span><br><span class="line">    close_output_pbs(&amp;sa_pbs);</span><br><span class="line">    ret = TRUE;</span><br><span class="line"></span><br><span class="line">return_out:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(KERNEL_ALG) || defined(IKE_ALG)</span></span><br><span class="line">    <span class="keyword">if</span> (revised_sadb)</span><br><span class="line">          free_sa(revised_sadb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ä¸€èˆ¬è€Œè¨€ï¼Œæ¯”è¾ƒå…³å¿ƒæˆ‘ä»¬é…ç½®çš„å‚æ•°åœ¨å“ªé‡Œç”Ÿæ•ˆï¼Ÿ ä¾‹å¦‚åŠ å¯†ç®—æ³•ã€è®¤è¯ç®—æ³•ã€éš§é“æ¨¡å¼orä¼ è¾“æ¨¡å¼éƒ½æ˜¯åœ¨<code>out_sa()</code>ä¸­é€šè¿‡å±æ€§è½½è·å°è£…åœ¨æŠ¥æ–‡ä¸­çš„ã€‚ä¸‹å›¾ä¸ºå±æ€§è½½è·ç»“æ„ï¼š</p>
<p><img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1.assets%5Cimage-20200827002952001.png" alt="image-20200827002952001"></p>
<p>å±æ€§ç±»å‹çš„æœ€é«˜æ¯”ç‰¹ä½AFæŒ‡å®šæ•°æ®ä¸ºå®šé•¿è¿˜æ˜¯å˜é•¿ï¼Œå¦‚æœä¸º0è¡¨ç¤ºå®šé•¿ï¼›å¦‚æœä¸º1è¡¨ç¤ºå˜é•¿ã€‚</p>
<p>å…·ä½“å±æ€§ç±»å‹æœ‰ä»¥ä¸‹å‡ ç§ï¼ˆå…¨æ˜¯å®šé•¿ç±»å‹ï¼‰ï¼š</p>
<table>
<thead>
<tr>
<th>å±æ€§ç±»å‹</th>
<th>å±æ€§ç±»å‹å–å€¼</th>
<th>å±æ€§å€¼è¯´æ˜</th>
</tr>
</thead>
<tbody><tr>
<td>SAç”Ÿå­˜å‘¨æœŸ</td>
<td>1</td>
<td>0: ä¿ç•™    1:ç§’    2:åƒå­—èŠ‚</td>
</tr>
<tr>
<td>SAç”Ÿå­˜æœŸ</td>
<td>2</td>
<td>0: ä¿ç•™    1:ç§’    2:åƒå­—èŠ‚</td>
</tr>
<tr>
<td>ç»„æè¿°</td>
<td>3</td>
<td>ç•¥</td>
</tr>
<tr>
<td><strong>å°è£…æ¨¡å¼</strong></td>
<td>4</td>
<td>0ï¼šä¿ç•™     1ï¼šéš§é“æ¨¡å¼      2ï¼šä¼ è¾“æ¨¡å¼</td>
</tr>
<tr>
<td><strong>è®¤è¯ç®—æ³•</strong></td>
<td>5</td>
<td>0ï¼šRESERVED    1ï¼šHMAC-MD5      2:HMAC-SHA   â€¦.</td>
</tr>
<tr>
<td>å¯†é’¥é•¿åº¦</td>
<td>6</td>
<td>ç•¥</td>
</tr>
<tr>
<td>å¯†é’¥è½®æ•°</td>
<td>7</td>
<td>ç•¥</td>
</tr>
<tr>
<td>å‹ç¼©å­—å…¸é•¿åº¦</td>
<td>8</td>
<td>ç•¥</td>
</tr>
<tr>
<td>ç§æœ‰å‹ç¼©ç®—æ³•</td>
<td>9</td>
<td>ç•¥</td>
</tr>
</tbody></table>
<p>æ³¨ï¼šåŠ å¯†ç®—æ³•ä¸é€‚ç”¨å±æ€§è½½è·è¿›è¡Œå°è£…ã€‚</p>
<h4 id="5-2-emit-subnet-id"><a href="#5-2-emit-subnet-id" class="headerlink" title="5.2 emit_subnet_id()"></a>5.2 emit_subnet_id()</h4><p>ç¬¬äºŒé˜¶æ®µé™¤äº†åå•†åŠ è§£å¯†ç®—æ³•ä¿¡æ¯ï¼Œè¿˜ä¼šå¯¹åŒæ–¹çš„ä¿æŠ¤å­ç½‘è¿›è¡ŒåŒ¹é…ã€‚è€Œä¿æŠ¤å­ç½‘æ˜¯é€šè¿‡IDè½½è·æ¥ä¼ è¾“çš„ã€‚åœ¨ç¬¬ä¸€é˜¶æ®µä¸­ä½¿ç”¨<code>build_id_payload()</code>æ¥å£å°†æˆ‘ä»¬åœ¨é…ç½®éš§é“çš„â€œ<strong>èº«ä»½æ ‡è¯†</strong>â€å‘é€å¯¹æ–¹ä»¥ä¾›åŒæ–¹è®¤è¯ï¼Œç¬¬äºŒé˜¶æ®µä½¿ç”¨<code>emit_subnet_id()</code>æ¥åå•†ä¸¤ç«¯çš„ä¿æŠ¤å­ç½‘ä¿¡æ¯ã€‚</p>
<p>æ¯ä¸€æ¡éš§é“æœ‰æœ¬ç«¯å’Œå¯¹ç«¯ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ç”¨<code>struct end</code>ç»“æ„æè¿°ï¼Œè€Œä¸¤ç«¯çš„ä¿æŠ¤å­ç½‘ä½¿ç”¨<code>struct end</code>ä¸­çš„<code>ip_subnet client;</code>æè¿°ï¼Œ<code>ip_subnet</code>ç»“æ„å¦‚ä¸‹ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ip_address addr;</span><br><span class="line">	<span class="keyword">int</span> maskbits;</span><br><span class="line">&#125; ip_subnet;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initiate quick mode.</span></span><br><span class="line"><span class="comment"> * --&gt; HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5)</span></span><br><span class="line"><span class="comment"> * Note: this is not called from demux.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*å¡«å……çš„æ˜¯éš§é“ç«¯å£IPè¿˜æ˜¯å­ç½‘çš„ä¿¡æ¯? </span></span><br><span class="line"><span class="comment">*ä¿æŠ¤å­ç½‘æ˜¯å¦‚ä½•åå•†çš„???</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">emit_subnet_id</span><span class="params">(struct end *e</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int8_t</span> np</span></span></span><br><span class="line"><span class="params"><span class="function">               , ip_address endpoint</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int8_t</span> protoid</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int16_t</span> port</span></span></span><br><span class="line"><span class="params"><span class="function">	       , pb_stream *outs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id</span>;</span></span><br><span class="line">    pb_stream id_pbs;</span><br><span class="line">    ip_address ta;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbp;</span><br><span class="line">    <span class="keyword">size_t</span> tal;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">af_info</span> *<span class="title">ai</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> usehost = FALSE;</span><br><span class="line">    ip_subnet clientnet;</span><br><span class="line"></span><br><span class="line">    clientnet = e-&gt;client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!e-&gt;has_client) &#123;</span><br><span class="line">        <span class="comment">/* we propose the IP address of the interface that we are using. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could instead propose 0.0.0.0-&gt;255.255.255.255 and let the other</span></span><br><span class="line"><span class="comment">     * end narrow the TS, but if one wants that, it is easy to just specify</span></span><br><span class="line"><span class="comment">     * in the configuration file: rightsubnet=0.0.0.0/0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When there is NAT involved, we may really want a tunnel to the</span></span><br><span class="line"><span class="comment">     * address that this end point thinks it is.  That works only when</span></span><br><span class="line"><span class="comment">     * virtual_ip includes the IP involved.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        addrtosubnet(&amp;endpoint, &amp;clientnet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ai = aftoinfo(subnettypeof(&amp;clientnet));</span><br><span class="line">    passert(ai != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    id.isaiid_np = np;</span><br><span class="line">    id.isaiid_idtype = (usehost ? ai-&gt;id_addr : ai-&gt;id_subnet);<span class="comment">/*ç¡®å®šä½¿ç”¨ä¸»æœºIDè¿˜æ˜¯å­ç½‘IDï¼›ç”±äºusehost===FALSE,å› æ­¤è¿™é‡Œä½¿ç”¨å­ç½‘ID*/</span></span><br><span class="line">    id.isaiid_protoid = protoid;</span><br><span class="line">    id.isaiid_port = port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out_struct(&amp;id, &amp;isakmp_ipsec_identification_desc, outs, &amp;id_pbs))</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    networkof(&amp;clientnet, &amp;ta);<span class="comment">/*è·å–ä¿æŠ¤å­ç½‘*/</span></span><br><span class="line">    tal = addrbytesptr(&amp;ta, &amp;tbp);</span><br><span class="line">    <span class="keyword">if</span> (!out_raw(tbp, tal, &amp;id_pbs, <span class="string">&quot;client network&quot;</span>))<span class="comment">/*å¡«å……ä¿æŠ¤å­ç½‘ä¿¡æ¯*/</span></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!usehost)</span><br><span class="line">    &#123;</span><br><span class="line">	maskof(&amp;clientnet, &amp;ta);<span class="comment">/*è·å–ä¿æŠ¤å­ç½‘æ©ç */</span></span><br><span class="line">	tal = addrbytesptr(&amp;ta, &amp;tbp);</span><br><span class="line">	<span class="keyword">if</span> (!out_raw(tbp, tal, &amp;id_pbs, <span class="string">&quot;client mask&quot;</span>))<span class="comment">/*å¡«å……ä¿æŠ¤å­ç½‘æ©ç ä¿¡æ¯*/</span></span><br><span class="line">	    <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close_output_pbs(&amp;id_pbs);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IDè½½è·(æ ‡è¯†è½½è·)åŒ…å«ä»¥ä¸‹å‡ ç§ç±»å‹ï¼š</p>
<table>
<thead>
<tr>
<th>IDç±»å‹</th>
<th>æè¿°</th>
<th>å–å€¼</th>
</tr>
</thead>
<tbody><tr>
<td>ID_NONE</td>
<td>æœªä½¿ç”¨</td>
<td>0</td>
</tr>
<tr>
<td><strong>ID_IPV4_ADDR</strong></td>
<td>å•ç‹¬çš„ä¸€ä¸ªIPv4åœ°å€</td>
<td>1</td>
</tr>
<tr>
<td><strong>ID_FQDN</strong></td>
<td>å…¨åŸŸåå­—ç¬¦ä¸²ï¼Œå¦‚topsec.com.cn</td>
<td>2</td>
</tr>
<tr>
<td><strong>ID_USER_FQDN</strong></td>
<td>ç”¨æˆ·åå­—ç¬¦ä¸²ï¼Œå¦‚<a href="mailto:&#108;&#105;&#95;&#x73;&#x69;&#x40;&#116;&#x6f;&#112;&#x73;&#x65;&#99;&#46;&#99;&#x6f;&#x6d;&#46;&#x63;&#x6e;">&#108;&#105;&#95;&#x73;&#x69;&#x40;&#116;&#x6f;&#112;&#x73;&#x65;&#99;&#46;&#99;&#x6f;&#x6d;&#46;&#x63;&#x6e;</a></td>
<td>3</td>
</tr>
<tr>
<td>ID_RFC822_ADDR</td>
<td>åŒID_USER_FQDN</td>
<td>ID_USER_FQDN</td>
</tr>
<tr>
<td><strong>ID_IPV4_ADDR_SUBNET</strong></td>
<td>IPv4ç±»å­ç½‘åœ°å€ï¼Œå¦‚192.168.1.1 255.255.255.0</td>
<td>4</td>
</tr>
<tr>
<td>ID_IPV6_ADDR</td>
<td>å•ç‹¬IPv6åœ°å€</td>
<td>5</td>
</tr>
<tr>
<td>ID_IPV6_ADDR_SUBNET</td>
<td>IPv6å­ç½‘åœ°å€</td>
<td>6</td>
</tr>
<tr>
<td>ID_IPV4_ADDR_RANGE</td>
<td>IPv4åœ°å€èŒƒå›´åŒºé—´, å¦‚192.168.2.3 192.168.2.200</td>
<td>7</td>
</tr>
<tr>
<td>ID_IPV6_ADDR_RANGE</td>
<td>IPv6åœ°å€èŒƒå›´åŒºé—´</td>
<td>8</td>
</tr>
<tr>
<td>ID_DER_ASN1_DN</td>
<td>x.500ç¼–ç æ ¼å¼</td>
<td>9</td>
</tr>
<tr>
<td>ID_DER_ASN1_GN</td>
<td>x.500ç¼–ç æ ¼å¼</td>
<td>10</td>
</tr>
<tr>
<td>ID_KEY_ID</td>
<td>ä¼ é€’ç‰¹å®šå‚å•†ä¿¡æ¯çš„å­—èŠ‚æµ</td>
<td>11</td>
</tr>
</tbody></table>
<h4 id="5-3-encrypt-message"><a href="#5-3-encrypt-message" class="headerlink" title="5.3 encrypt_message()"></a>5.3 encrypt_message()</h4><p>æŠ¥æ–‡çš„åŠ å¯†èŒƒå›´ï¼šé™¤äº†ISAKMPå¤´éƒ¨ä¹‹å¤–éƒ½éœ€è¦è¿›è¡ŒåŠ å¯†ã€‚åŠ å¯†ä½¿ç”¨ç¬¬ä¸€é˜¶æ®µåå•†çš„åŠ å¯†ç§˜é’¥ï¼ˆæŠ¥æ–‡è®¤è¯æ—¶åŒæ—¶ä¹Ÿä¼šç”¨åˆ°è®¤è¯å¯†é’¥ï¼‰ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* encrypt message, sans fixed part of header</span></span><br><span class="line"><span class="comment"> * IV is fetched from st-&gt;st_new_iv and stored into st-&gt;st_iv.</span></span><br><span class="line"><span class="comment"> * The theory is that there will be no &quot;backing out&quot;, so we commit to IV.</span></span><br><span class="line"><span class="comment"> * We also close the pbs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">encrypt_message</span><span class="params">(pb_stream *pbs, struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">encrypt_desc</span> *<span class="title">e</span> =</span> st-&gt;st_oakley.encrypter;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *enc_start = pbs-&gt;start + <span class="keyword">sizeof</span>(struct isakmp_hdr);<span class="comment">/*åŠ å¯†çš„å†…å®¹ä¸ºISAKMPå¤´éƒ¨ä¹‹å*/</span></span><br><span class="line">    <span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);<span class="comment">/*åŠ å¯†å†…å®¹çš„é•¿åº¦*/</span></span><br><span class="line"></span><br><span class="line">    DBG_cond_dump(DBG_CRYPT | DBG_RAW, <span class="string">&quot;encrypting:\n&quot;</span>, enc_start, enc_len);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT | DBG_RAW, <span class="string">&quot;IV:\n&quot;</span></span><br><span class="line">		  , st-&gt;st_new_iv</span><br><span class="line">		  , st-&gt;st_new_iv_len);</span><br><span class="line">    DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;unpadded size is: %u&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)enc_len));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad up to multiple of encryption blocksize.</span></span><br><span class="line"><span class="comment">     * See the description associated with the definition of</span></span><br><span class="line"><span class="comment">     * struct isakmp_hdr in packet.h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*ç¡®å®šéœ€è¦å¡«å……çš„é•¿åº¦*/</span></span><br><span class="line">	<span class="keyword">size_t</span> padding = pad_up(enc_len, e-&gt;enc_blocksize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (padding != <span class="number">0</span>)<span class="comment">/*å¦‚æœå¡«å……çš„é•¿åº¦ä¸ä¸º0,åˆ™éœ€è¦è¿›è¡Œå¡«å……æ•°æ®*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!out_zero(padding, pbs, <span class="string">&quot;encryption padding&quot;</span>))<span class="comment">/*åœ¨è¾“å‡ºæµä¸Šè¿›è¡ŒæŠ¥æ–‡å¡«å……*/</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	    enc_len += padding;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DBG(DBG_CRYPT</span><br><span class="line">	, DBG_log(<span class="string">&quot;encrypting %d using %s&quot;</span></span><br><span class="line">		  , (<span class="keyword">unsigned</span> <span class="keyword">int</span>)enc_len</span><br><span class="line">		  , enum_show(&amp;oakley_enc_names, st-&gt;st_oakley.encrypt)));</span><br><span class="line"></span><br><span class="line">    TCLCALLOUT_crypt(<span class="string">&quot;preEncrypt&quot;</span>, st, pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);<span class="comment">/*éTPMæœªåšä»»ä½•å¤„ç†*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* e-&gt;crypt(TRUE, enc_start, enc_len, st); */</span></span><br><span class="line">    crypto_cbc_encrypt(e, TRUE, enc_start, enc_len, st);<span class="comment">/*ä½¿ç”¨CBCç®—æ³•è¿›è¡ŒåŠ å¯†:ä½¿ç”¨è¿æ¥ä¸Šç¬¬ä¸€é˜¶æ®µåå•†çš„åŠ å¯†ç®—æ³•å’ŒåŠ å¯†å¯†é’¥ä¿¡æ¯*/</span></span><br><span class="line"></span><br><span class="line">    TCLCALLOUT_crypt(<span class="string">&quot;postEncrypt&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">    update_iv(st);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;next IV:&quot;</span>, st-&gt;st_iv, st-&gt;st_iv_len);</span><br><span class="line">    close_message(pbs);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-out-modify-previous-np"><a href="#5-4-out-modify-previous-np" class="headerlink" title="5.4 out_modify_previous_np()"></a>5.4 out_modify_previous_np()</h4><p>æ­¤å‡½æ•°çš„ä½œç”¨åœ¨äºä¿®æ”¹å‰ä¸€ä¸ªè½½è·å¤´éƒ¨ä¸­çš„ä¸‹ä¸€ä¸ªè½½è·å­—æ®µã€‚å®ƒåœ¨å¡«å……NAT-Tç›¸å…³çš„OAè½½è·æ—¶ç”¨åˆ°ã€‚åŸºæœ¬åŸç†æ˜¯ä»å¤´éƒ¨å¼€å§‹å‘åéå†æ¯ä¸€ä¸ªè½½è·ï¼Œç›´åˆ°æ‰¾åˆ°æœ€åä¸€ä¸ªè½½è·çš„å¤´éƒ¨(å°šæœªå¡«å……æ–°çš„è½½è·ï¼Œå› æ­¤å®ƒè¿˜æ˜¯æœ€åä¸€ä¸ªè½½è·)ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_modify_previous_np</span><span class="params">(<span class="keyword">u_int8_t</span> np, pb_stream *outs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *pl = outs-&gt;start;</span><br><span class="line">    <span class="keyword">size_t</span> left = outs-&gt;cur - outs-&gt;start;</span><br><span class="line"></span><br><span class="line">    passert(left &gt;= NSIZEOF_isakmp_hdr);    <span class="comment">/* not even room for isakmp_hdr! */</span></span><br><span class="line">    <span class="keyword">if</span> (left == NSIZEOF_isakmp_hdr) &#123;</span><br><span class="line">	<span class="comment">/* no payloads, just the isakmp_hdr: insert np here */</span></span><br><span class="line">	passert(pl[NOFFSETOF_isa_np] == ISAKMP_NEXT_NONE ||</span><br><span class="line">		pl[NOFFSETOF_isa_np] == ISAKMP_NEXT_HASH);</span><br><span class="line">	pl[NOFFSETOF_isa_np] = np;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	pl += NSIZEOF_isakmp_hdr;       <span class="comment">/* skip over isakmp_hdr */</span></span><br><span class="line">	left -= NSIZEOF_isakmp_hdr;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> pllen;</span><br><span class="line"></span><br><span class="line">		passert(left &gt;= NSIZEOF_isakmp_generic);</span><br><span class="line">		pllen = (pl[NOFFSETOF_isag_length] &lt;&lt; <span class="number">8</span>)<span class="comment">/*payload ä¸€èˆ¬ä¸ºä¸¤ä¸ªå­—èŠ‚*/</span></span><br><span class="line">			| pl[NOFFSETOF_isag_length + <span class="number">1</span>];</span><br><span class="line">		passert(left &gt;= pllen);</span><br><span class="line">		<span class="keyword">if</span> (left == pllen) &#123;<span class="comment">/*å½“å‰è½½è·é•¿åº¦å’Œå‰©ä½™é•¿åº¦ç›¸åŒæ—¶ï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°ä¸Šä¸€ä¸ªè½½è·*/</span></span><br><span class="line">			<span class="comment">/* found last top-level payload */</span></span><br><span class="line">			pl[NOFFSETOF_isag_np] = np;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">/* done */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* this payload is not the last: scan forward */</span></span><br><span class="line">			pl += pllen;</span><br><span class="line">			left -= pllen;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-å°ç»“"><a href="#6-å°ç»“" class="headerlink" title="6. å°ç»“"></a>6. å°ç»“</h3><p>ç•¥</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>å¿«é€Ÿæ¨¡å¼ç¬¬ä¸‰åŒ…æ”¶å°¾ä¹‹quick_inI2()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85-2%20quick_inI2()/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205321.png" alt="image-20200913162318278"></p>
<span id="more"></span>
<h3 id="1-åºè¨€"><a href="#1-åºè¨€" class="headerlink" title="1. åºè¨€"></a>1. åºè¨€</h3><p>å¿«é€Ÿæ¨¡å¼æœ‰ä¸‰ä¸ªæŠ¥æ–‡äº¤æ¢ï¼Œå››ä¸ªæ ¸å¿ƒå‡½æ•°å…¥å£ã€‚æˆ‘ä»¬å·²ç»å¯¹å‰ä¸‰ä¸ªå‡½æ•°å¤„ç†æµç¨‹å¯¹äº†ä¸€ä¸ªç®€å•çš„å­¦ä¹ å’Œè¿™é‡Œï¼Œä¸‹é¢å¯¹ç¬¬å››ä¸ªå‡½æ•°å…¥å£<code>quick_inI2()</code>çš„å¤„ç†æµç¨‹åšä¸€ä¸ªç®€å•çš„ä»‹ç»ã€‚</p>
<p>é¦–å…ˆéœ€è¦è¯´æ˜çš„æ˜¯å¿«é€Ÿæ¨¡å¼çš„å‰ä¸¤ä¸ªæŠ¥æ–‡æ˜¯ä¸ºäº†åå•†æ„Ÿå…´è¶£æµçš„ç›¸å…³å‚æ•°(å¦‚ä½¿ç”¨çš„åŠ å¯†ç®—æ³•ã€è®¤è¯ç®—æ³•ã€å°è£…æ–¹å¼ã€æ„Ÿå…´è¶£æµä»¥åŠç”Ÿæˆç›¸å…³çš„å¯†é’¥ä¿¡æ¯ç­‰)ï¼Œè€Œç¬¬ä¸‰ä¸ªæŠ¥æ–‡åˆ™ç®€å•äº†å¾ˆå¤šï¼šåªæ˜¯ä¸ºäº†å¯¹å‰ä¸¤ä¸ªæŠ¥æ–‡åšè®¤è¯ã€‚é‚£ä¹ˆè‡ªç„¶è€Œç„¶å¼•å‡ºä¸€ä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆéœ€è¦ç¬¬ä¸‰ä¸ªæŠ¥æ–‡å‘¢ï¼Ÿå‰ä¸¤ä¸ªæŠ¥æ–‡ä¸æ˜¯å·²ç»åŒ…å«HASHæ‚å‡‘è½½è·å—ï¼Ÿ ä¾›å¤§å®¶æ€è€ƒå§ã€‚</p>
<h3 id="2-quick-inI2-å¤„ç†æµç¨‹å›¾"><a href="#2-quick-inI2-å¤„ç†æµç¨‹å›¾" class="headerlink" title="2.  quick_inI2()å¤„ç†æµç¨‹å›¾"></a>2.  quick_inI2()å¤„ç†æµç¨‹å›¾</h3><p><code>quick_inI2()</code>çš„å¤„ç†æµç¨‹å¾ˆç®€å•ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„ä¾¿æ˜¯å»ºç«‹å‡ºç«™IPsecSAã€‚ï¼ˆå¦‚æœIPsecå¤„ç†æµç¨‹éƒ½æ˜¯è¿™ç§ç²¾ç®€çš„ï¼Œè¯¥å¤šå¥½å‘€:) :) ï¼‰</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205604.png" alt="image-20200913164700196"></p>
<h3 id="3-æŠ¥æ–‡æ ¼å¼"><a href="#3-æŠ¥æ–‡æ ¼å¼" class="headerlink" title="3.  æŠ¥æ–‡æ ¼å¼"></a>3.  æŠ¥æ–‡æ ¼å¼</h3><p><code>quick_inR1_outI2()</code>å’Œ<code>quick_inI2()</code>éƒ½æ˜¯ç”¨æ¥å¤„ç†å¿«é€Ÿæ¨¡å¼æœ€åä¸€ä¸ªåŒ…çš„ï¼ŒæŠ¥æ–‡æ ¼å¼å®Œå…¨ä¸€è‡´ã€‚ï¼Œ<code>quick_inR1_outI2()</code>åŒ…æ‹¬å‘é€å¤„ç†æµç¨‹ï¼Œè€Œ<code>quick_inI2()</code>åˆ™åªä¸ºå¤„ç†æ¥æ”¶æµç¨‹ã€‚</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205602.png" alt="å›¾ç‰‡1"></p>
<h3 id="4-quick-inI2-æºç "><a href="#4-quick-inI2-æºç " class="headerlink" title="4.  quick_inI2()æºç "></a>4.  quick_inI2()æºç </h3><p>è¿™ä¸ªæºç ä¸»è¦æµç¨‹å¾ˆæ¸…æ™°ï¼ˆé™¤äº†å»ºç«‹IPsecSAï¼‰ï¼Œä»£ç ä¹Ÿå¾ˆå°‘ã€‚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle last message of Quick Mode.</span></span><br><span class="line"><span class="comment"> * HDR*, HASH(3) -&gt; done</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5)</span></span><br><span class="line"><span class="comment"> * Installs outbound IPsec SAs, routing, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(3) in */</span><span class="comment">/*éªŒè¯å“ˆå¸ŒæŠ¥æ–‡å®Œæ•´æ€§*/</span></span><br><span class="line">    CHECK_QUICK_HASH(md, quick_mode_hash3(hash_val, st)</span><br><span class="line">	, <span class="string">&quot;HASH(3)&quot;</span>, <span class="string">&quot;Quick I2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tell the kernel to establish the outbound and routing part of the new SA</span></span><br><span class="line"><span class="comment">     * (the previous state established inbound)</span></span><br><span class="line"><span class="comment">     * (unless the commit bit is set -- which we don&#x27;t support).</span></span><br><span class="line"><span class="comment">     * We do this before any state updating so that</span></span><br><span class="line"><span class="comment">     * failure won&#x27;t look like success.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!install_ipsec_sa(md-&gt;pst, st, FALSE))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      DBG(DBG_CONTROLMORE, DBG_log(<span class="string">&quot;inI2: instance %s[%ld], setting newest_ipsec_sa to #%ld (was #%ld) (spd.eroute=#%ld)&quot;</span></span><br><span class="line">			       , st-&gt;st_connection-&gt;name</span><br><span class="line">			       , st-&gt;st_connection-&gt;instance_serial</span><br><span class="line">			       , st-&gt;st_serialno</span><br><span class="line">			       , st-&gt;st_connection-&gt;newest_ipsec_sa</span><br><span class="line">			       , st-&gt;st_connection-&gt;spd.eroute_owner));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_connection-&gt;newest_ipsec_sa = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    update_iv(st);	<span class="comment">/* not actually used, but tidy */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note (presumed) success */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gw_info</span> *<span class="title">gw</span> =</span> st-&gt;st_connection-&gt;gw_info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gw != <span class="literal">NULL</span>)</span><br><span class="line">	    gw-&gt;key-&gt;last_worked_time = now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have dpd delay and dpdtimeout set, then we are doing DPD</span></span><br><span class="line"><span class="comment">	on this conn, so initialize it */</span></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;dpd_delay &amp;&amp; st-&gt;st_connection-&gt;dpd_timeout) &#123;</span><br><span class="line">	<span class="keyword">if</span>(dpd_init(st) != STF_OK) &#123;</span><br><span class="line">	    delete_ipsec_sa(st, FALSE);</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-å…¶ä»–æ¥å£è¯´æ˜"><a href="#4-å…¶ä»–æ¥å£è¯´æ˜" class="headerlink" title="4.  å…¶ä»–æ¥å£è¯´æ˜"></a>4.  å…¶ä»–æ¥å£è¯´æ˜</h3><h4 id="4-1-hashè½½è·è®¡ç®—æ–¹å¼"><a href="#4-1-hashè½½è·è®¡ç®—æ–¹å¼" class="headerlink" title="4.1  hashè½½è·è®¡ç®—æ–¹å¼"></a>4.1  hashè½½è·è®¡ç®—æ–¹å¼</h4><p>å¿«é€Ÿæ¨¡å¼è™½ç„¶ä»…æœ‰ä¸‰ä¸ªæŠ¥æ–‡äº¤äº’ï¼Œä½†æ˜¯å®ƒä»¬çš„hashæ‚å‡‘è½½è·çš„è®¡ç®—æ–¹å¼å´ä¸ç›¸åŒï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> ç¬¬â‘ åŒ…è®¡ç®—æ–¹å¼ï¼š<br>$$<br>HASH(1) = PRF(SKEYID-a, MsgID | SA | Ni | [| IDi | IDr ])<br>$$</li>
<li><input checked="" disabled="" type="checkbox"> ç¬¬â‘¡åŒ…è®¡ç®—æ–¹å¼ï¼š<br>$$<br>HASH(2) = PRF(SKEYID-a, MsgID | Ni | SA | Nr |      [| IDi | IDr ])<br>$$</li>
<li><input checked="" disabled="" type="checkbox"> ç¬¬â‘¢åŒ…è®¡ç®—æ–¹å¼ï¼š</li>
</ul>
<p>$$<br>HASH(3) = PRF(SKEYID-a, 0 | MsgID | Ni | Nr)<br>$$</p>
<hr>
<ul>
<li><p>ç¬¬â‘ åŒ…å®ç°æ–¹å¼å’Œç¬¬â‘¡åŒ…å®ç°æ–¹å¼ä¸ºåŒä¸€ä¸ªå‡½æ•°ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute HASH(1), HASH(2) of Quick Mode.</span></span><br><span class="line"><span class="comment"> * HASH(1) is part of Quick I1 message.</span></span><br><span class="line"><span class="comment"> * HASH(2) is part of Quick R1 message.</span></span><br><span class="line"><span class="comment"> * Used by: quick_outI1, quick_inI1_outR1 (twice), quick_inR1_outI2</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5, pg. 18 or draft-ietf-ipsec-ike-01.txt 6.2 pg 25)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span></span></span><br><span class="line"><span class="function"><span class="title">quick_mode_hash12</span><span class="params">(u_char *dest, <span class="keyword">const</span> u_char *start, <span class="keyword">const</span> u_char *roof</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">const</span> struct state *st, <span class="keyword">const</span> <span class="keyword">msgid_t</span> *msgid, <span class="keyword">bool</span> hash2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    hmac_init_chunk(&amp;ctx, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_a);<span class="comment">/*PRFç®—æ³• + è®¤è¯ç§˜é’¥*/</span></span><br><span class="line">    </span><br><span class="line">    hmac_update(&amp;ctx, (<span class="keyword">const</span> <span class="keyword">void</span> *) msgid, <span class="keyword">sizeof</span>(<span class="keyword">msgid_t</span>));<span class="comment">/*å¡«å……msgidï¼Œç”±äºè®¤è¯éœ€è¦msgidï¼Œè€Œå®ƒå”¯ä¸€*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hash2)</span><br><span class="line">		hmac_update_chunk(&amp;ctx, st-&gt;st_ni);	<span class="comment">/* include Ni_b in the hash */</span></span><br><span class="line">    </span><br><span class="line">    hmac_update(&amp;ctx, start, roof-start);<span class="comment">/*æ•°æ®èµ·å§‹ä½ç½®å’Œç»ˆæ­¢ä½ç½®*/</span></span><br><span class="line">    hmac_final(dest, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx.hmac_digest_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ç¬¬â‘¢åŒ…å®ç°æ–¹å¼ï¼š</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute HASH(3) in Quick Mode (part of Quick I2 message).</span></span><br><span class="line"><span class="comment"> * Used by: quick_inR1_outI2, quick_inI2</span></span><br><span class="line"><span class="comment"> * See RFC2409 &quot;The Internet Key Exchange (IKE)&quot; 5.5.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this hash (unlike HASH(1) and HASH(2)) ONLY covers the</span></span><br><span class="line"><span class="comment"> * Message ID and Nonces.  This is a mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span></span></span><br><span class="line"><span class="function"><span class="title">quick_mode_hash3</span><span class="params">(u_char *dest, struct state *st)</span><span class="comment">/*ç¬¬äºŒé˜¶æ®µçš„ä¸‰ä¸ªæŠ¥æ–‡hashå€¼ç®—æ³•æ–¹å¼å„ä¸ç›¸åŒ*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    hmac_init_chunk(&amp;ctx, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_a);</span><br><span class="line">    hmac_update(&amp;ctx, (<span class="keyword">const</span> u_char *)<span class="string">&quot;\0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    hmac_update(&amp;ctx, (u_char *) &amp;st-&gt;st_msgid, <span class="keyword">sizeof</span>(st-&gt;st_msgid));</span><br><span class="line">    hmac_update_chunk(&amp;ctx, st-&gt;st_ni);</span><br><span class="line">    hmac_update_chunk(&amp;ctx, st-&gt;st_nr);</span><br><span class="line">    hmac_final(dest, &amp;ctx);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;HASH(3) computed:&quot;</span>, dest, ctx.hmac_digest_len);</span><br><span class="line">    <span class="keyword">return</span> ctx.hmac_digest_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-install-ipsec-sa"><a href="#4-2-install-ipsec-sa" class="headerlink" title="4.2  install_ipsec_sa"></a>4.2  install_ipsec_sa</h4><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205609.gif" alt="timg22" style="zoom:50%;" />

<h3 id="5-å°ç»“"><a href="#5-å°ç»“" class="headerlink" title="5. å°ç»“"></a>5. å°ç»“</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205624.jpg" alt="img"></p>
<p>IPsecåå•†æµç¨‹ä¹‹ä¸»æ¨¡å¼+å¿«é€Ÿæ¨¡å¼å­¦ä¹ è·¨åº¦æ¯”è¾ƒä¹…ï¼ˆ3ä¸ªæœˆå¤šï¼‰ï¼Œåå•†æµç¨‹å´æ˜¯å¾ˆå¤æ‚ï¼Œè€Œä¸”åªæ˜¯çœ‹åŸç†æ€§çŸ¥è¯†ï¼Œå¾ˆå¤šåŠŸèƒ½éƒ½æ²¡æœ‰æ•¢å»æ¶‰åŠï¼Œå¦‚è¯ä¹¦è®¤è¯ã€out_saã€ DPDã€å»ºç«‹IPsecSAã€NAT-Tç­‰ç­‰ã€‚å­¦ä¹ æœŸé—´æœ€ä¸»è¦çš„ä½“ä¼šæ˜¯ï¼šopenswanå°è£…äº†å¾ˆå¤šå¾ˆå¤šæ¥å£ï¼Œå¸¸ç”¨æ¥å£éœ€è¦å¥½å¥½å­¦ä¹ ï¼Œå¦åˆ™åœ¨çœ‹ä»£ç æ—¶å¾ˆå›°éš¾ã€‚å°±æ‹¿<code>out_sa</code> ã€<code>out_struct</code>ã€<code>out_generic</code>ç­‰ç³»åˆ—ï¼Œèƒ½æ¶å¿ƒæ­»äººï¼Œå…¨æ–‡åŸºæœ¬éƒ½ç”¨è¿™å‡ ä¸ªæ¥å£åœ¨å°è£…æŠ¥æ–‡å’Œè§£å°è£…æŠ¥æ–‡ï¼Œå¯ä»¥è¯´è¿™äº›åŸºæœ¬å‡½æ•°æ˜¯çœ‹openswanæºç çš„æ¥å£ã€‚</p>
<p>åé¢è®¡åˆ’ç»§ç»­æ›´æ–°å‡ ä¸ªå‡½æ•°æ¥å£å®ç°ï¼Œä¹Ÿæ˜¯ä»¥å‰å­¦ä¹ æ•´ç†è¿‡ç¨‹ä¸­é—ç•™çš„å‘ï¼Œå…ˆå¡«å‡ ä¸ªç„¶ååœ¨æ›´æ–°å­¦ä¹ å…¶ä»–æµç¨‹ã€‚</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>ğŸ‘‰ğŸ‘‰RCUé”åŸç†æ·±åº¦æ€è€ƒ</title>
    <url>/blogs/2021/11/20/RCU%E9%94%81%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="RCUç»å…¸æ–‡çŒ®"><a href="#RCUç»å…¸æ–‡çŒ®" class="headerlink" title="RCUç»å…¸æ–‡çŒ®"></a>RCUç»å…¸æ–‡çŒ®</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/264090/">RCU part 3: the RCU API</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Kernel/Index/">linux kernel</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://www.rdrop.com/users/paulmck/RCU/">RCUä½œè€…çš„ä¸»é¡µä»‹ç»</a></li>
</ul>
<span id="more"></span>

<p>è¿™å‡ ä¸ªè¿æ¥ç®€ç›´å°±æ˜¯ä¸€ä¸ªå®è—ï¼Œé‡Œé¢çš„å¹²æ´»å¾ˆå¤šå¾ˆå¤šï¼ï¼ï¼æœ‰æ—¶é—´ä¸€å®šè¦å¤šçœ‹çœ‹ã€‚ä¸‹æ–‡ä¸­çš„å†…å®¹æ˜¯çœ‹ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªé“¾æ¥çš„ç¬”è®°å’Œæ•´ç†ã€‚ç›´æ¥è§‚çœ‹åŸæ–‡ï¼Œæ•ˆæœæ›´ä½³ã€‚</p>
<p><img src="https://static.lwn.net/images/logo/barepenguin-70.png" alt="LWN.net Logo"></p>
<h2 id="RCUé”ç‰¹ç‚¹ä»‹ç»"><a href="#RCUé”ç‰¹ç‚¹ä»‹ç»" class="headerlink" title="RCUé”ç‰¹ç‚¹ä»‹ç»"></a>RCUé”ç‰¹ç‚¹ä»‹ç»</h2><p>Read-copy_update(ç®€ç§°RCU)æŠ€æœ¯æ˜¯ä¸€ç§æ•°æ®åŒæ­¥æœºåˆ¶ã€‚å¸¸è§çš„æ•°æ®åŒæ­¥æœºåˆ¶æœ‰ï¼šäº’æ–¥é”ï¼Œè‡ªæ—‹é”ï¼Œè¯»å†™é”ï¼Œé¡ºåºé”ï¼Œä¿¡å·é‡ç­‰æ‰‹æ®µã€‚è€ŒRCUé”æ˜¯ä¸€ç§æ¯”è¾ƒé«˜æ•ˆçš„å¹¶å‘ç¼–ç¨‹æŠ€æœ¯ï¼Œå®ƒä¸2002å¹´10æœˆè¢«æ·»åŠ åˆ°Linuxå†…æ ¸ä¸­ï¼Œåœ¨å¾ˆå¤šåœºæ™¯ä¸­å®ƒæ˜¯ç”¨æ¥æ›¿ä»£è¯»å†™é”çš„ã€‚</p>
<p>RCUé”çš„ç‰¹ç‚¹æœ‰ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>å…è®¸è¯»å†™åŒæ—¶è¿›è¡Œ</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>ä»»æ„è¯»ï¼›å†™æ“ä½œæ—¶å…ˆæ‹·è´ä¸€ä¸ªå‰¯æœ¬ï¼Œåœ¨å‰¯æœ¬ä¸Šè¿›è¡Œä¿®æ”¹ã€å‘å¸ƒï¼Œå¹¶åœ¨åˆé€‚æ—¶é—´é‡Šæ”¾åŸæ¥çš„æ—§æ•°æ®</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>è¯»ç«¯ä¸å­˜åœ¨ç¡çœ ã€é˜»å¡ã€è½®è¯¢ï¼Œä¸ä¼šå½¢æˆæ­»é”ï¼Œç›¸æ¯”è¯»å†™é”æ•ˆç‡æ›´é«˜ã€‚</strong></li>
</ul>
<p>RCUä¹Ÿæœ‰è‡ªå·±çš„ç¼ºç‚¹ï¼š</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>ä½ä¼˜å…ˆçº§çš„è¯»æ“ä½œå¯é˜»å¡é«˜ä¼˜å…ˆçº§çš„å†™æ“ä½œ</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>å®½é™æœŸå¯èƒ½æ¯”è¾ƒé•¿</strong></li>
</ul>
<p>è¿™æ˜¯ç”±äºRCU å†™æ“ä½œå®Œæ¯•åï¼Œä¼šç­‰å¾…è¯»ç«¯çš„å®Œæ¯•ï¼Œç­‰æ‰€æœ‰çš„è¯»æ“ä½œå®Œæ¯•åï¼Œå®½é™æœŸç»“æŸï¼Œæ­¤æ—¶å†™ç«¯æ‰ä¼šå°†èµ„æºé‡Šæ”¾ã€‚è¿™é‡Œæ²¡æœ‰åŒºåˆ†ä¼˜å…ˆçº§ï¼Œå› æ­¤ä½ä¼˜å…ˆçº§çš„è¯»æ“ä½œå¯èƒ½ä¼šå½±å“åˆ°é«˜ä¼˜å…ˆçº§çš„å†™æ“ä½œã€‚</p>
<p>å…¶å®ï¼ŒRCUæŠ€æœ¯çš„ç‰¹ç‚¹è¿˜ä¸ä»…å¦‚æ­¤ï¼Œè€Œæœ‰ä¸€ä¸ªæ›´é‡è¦çš„ç‰¹ç‚¹ï¼š<strong>å¤šæ ¸æ‰©å±•æ€§</strong>ã€‚RCUè™½ç„¶æˆ‘ä»¬å°†å…¶ç§°ä¹‹ä¸ºRCUé”ï¼Œä½†å®ƒå¹¶æ²¡æœ‰é‡‡ç”¨é”æŠ€æœ¯ï¼Œè€Œè¯»å†™é”åˆ™æ˜¯ä¸€ä¸ªçœŸæ­£çš„é”ï¼Œåœ¨æ‰©å±•æ€§ä¸Šå¾ˆå·®ï¼Œè®¾å¤‡CPUæ ¸è¶Šå¤šï¼Œé”çš„ç«äº‰ä¼šè¶Šæ¿€çƒˆï¼Œæ•ˆç‡ä¼šè¶Šä½ã€‚å› æ­¤åœ¨ç°åœ¨å¾ˆå¤šçš„å®ç°ä¸­ï¼Œè¶Šæ¥è¶Šæ³¨é‡<strong>æ— é”æŠ€æœ¯</strong>çš„å®ç°ã€‚ ä¸‹å›¾æ˜¯åœ¨æ–‡ç« <a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>ä¸­çš„ä¸€å¼ RCUå’Œrwlockåœ¨å¤šæ ¸æ‰©å±•æ€§ä¸Šå¯¹æ¯”å›¾ç‰‡ï¼š</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191148.jpg" alt="Graph showing RCU read-side primitives running multiple orders of magnitude faster than those of rwlock."></p>
<h2 id="RCUä¸­å¸¸è§é—®é¢˜"><a href="#RCUä¸­å¸¸è§é—®é¢˜" class="headerlink" title="RCUä¸­å¸¸è§é—®é¢˜"></a>RCUä¸­å¸¸è§é—®é¢˜</h2><h3 id="1-æœ‰æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°"><a href="#1-æœ‰æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°" class="headerlink" title="1. æœ‰æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°"></a>1. æœ‰æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°</h3><p>å…³äºRCUå®ç°åŸç†è¿˜æœ‰ä¸€ä¸ªè¯¯è§£ï¼š<strong>RCUé‡‡ç”¨äº†å¼•ç”¨è®¡æ•°çš„æ–¹å¼ç¡®å®šæ˜¯å¦å­˜åœ¨è¯»è€…ã€‚</strong> è¿™ä¸ªè§‚ç‚¹ä¹Ÿæ˜¯é”™çš„ã€‚é¦–å…ˆRCUå¹¶æ²¡æœ‰é‡‡ç”¨å¼•ç”¨è®¡æ•°çš„æœºåˆ¶ï¼Œè€Œæ˜¯é‡‡ç”¨äº†ä¸€ç§éå¸¸ç®€å•çš„æŠ€æœ¯æ¥å®ç°ï¼›å…¶æ¬¡å¦‚æœéè¦æ·±ç©¶åˆ°åº•æœ‰æ²¡æœ‰å¼•ç”¨è®¡æ•°ï¼ŒæŒ‰ç…§<a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>ä¸­çš„è¯´æ³•æ˜¯â€œRCU is a Restricted Reference-Counting Mechanismâ€ï¼Œä½†<strong>æœ¬è´¨ä¸Šæ˜¯æ²¡æœ‰é‡‡ç”¨å¼•ç”¨è®¡æ•°çš„æœºåˆ¶</strong>ã€‚å®ƒçš„è§£é‡Šå¦‚ä¸‹ï¼š</p>
<p>â€œrcu_read_lock() è¯­å¥å¯ä»¥è¢«è®¤ä¸ºæ˜¯è·å–å¯¹ p çš„å¼•ç”¨ï¼Œç›¸å½“äºä¸€ä¸ªå¼•ç”¨è®¡æ•°ã€‚å› ä¸ºåœ¨ rcu_dereference() åˆ†é…ç»™ p ä¹‹åå¼€å§‹çš„å®½é™æœŸä¸å¯èƒ½åœ¨æˆ‘ä»¬åˆ°è¾¾åŒ¹é…çš„ rcu_read_unlock() ä¹‹å‰ç»“æŸã€‚ è¿™ç§å¼•ç”¨è®¡æ•°æ–¹æ¡ˆå—åˆ°é™åˆ¶ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å…è®¸åœ¨ RCU è¯»ç«¯ä¸´ç•ŒåŒºä¸­é˜»å¡ï¼Œä¹Ÿä¸å…è®¸æˆ‘ä»¬å°† RCU è¯»ç«¯ä¸´ç•ŒåŒºä»ä¸€ä¸ªä»»åŠ¡åˆ‡æ¢åˆ°å¦ä¸€ä¸ªä»»åŠ¡â€œã€‚ <strong>è™½ç„¶æœ‰ç‚¹åƒå¼•ç”¨è®¡æ•°ï¼Œä½†ç»å¯¹ä¸æ˜¯</strong>ã€‚</p>
 <img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191142.png" alt="image-20211016165636411" style="zoom:80%;" />

<p>è‡³äºå®ƒæ€ä¹ˆå®ç°ï¼šæ£€æµ‹æ˜¯å¦æœ‰äººåœ¨å¼•ç”¨å½“å‰å˜é‡å‘¢ï¼Ÿ æˆ‘åœ¨ä¸‹é¢ä»‹ç»ä¸‹ </p>
<h3 id="2-RCUæ—¢ç„¶æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼Œé‚£åˆæ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨è¯»è€…å¼•ç”¨ä¹‹ï¼Ÿ"><a href="#2-RCUæ—¢ç„¶æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼Œé‚£åˆæ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨è¯»è€…å¼•ç”¨ä¹‹ï¼Ÿ" class="headerlink" title="2. RCUæ—¢ç„¶æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼Œé‚£åˆæ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨è¯»è€…å¼•ç”¨ä¹‹ï¼Ÿ"></a>2. RCUæ—¢ç„¶æ²¡æœ‰ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼Œé‚£åˆæ˜¯ç¡®å®šæ˜¯å¦å­˜åœ¨è¯»è€…å¼•ç”¨ä¹‹ï¼Ÿ</h3><p>RCU è¯»é”åŠ é”å’Œå»é”æœ€åŸºæœ¬çš„å‡½æ•°æ˜¯ï¼š</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_lock()		preempt_disable()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_unlock()	preempt_enable()</span></span><br></pre></td></tr></table></figure>

<p>åŠ é”å®é™…ä¸Šæ˜¯ç¦æ­¢ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼›è€Œè§£é”æ˜¯å…è®¸ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚<strong>å®ƒä»¬æ˜¯ä¸€ä¸ªå…¨å±€è®¾ç½®ï¼Œä¸ä¸ä»»ä½•ä¸€é¡¹é”ç»‘å®š</strong>ã€‚è¿™ä¹Ÿæ˜¯ä¸ºå•¥RCUè¯»é”ä¸éœ€è¦ä»»ä½•å‚æ•°çš„åŸå› ã€‚</p>
<p><strong>åŸºäºæ­¤ï¼Œä¾¿å¯ä»¥é€šè¿‡è®©CPUè¿›è¡Œä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢æ¥å®ç°æ£€æµ‹è¯»ç«¯æ˜¯å¦å®Œæˆï¼Œè€Œä¸å¿…è·Ÿè¸ªæ¯ä¸€ä¸ªå¼•ç”¨çš„è¿›ç¨‹ã€‚</strong> è¿™æ˜¯ä¸€ä¸ªRCUéå¸¸é‡è¦çš„ç‰¹ç‚¹.</p>
<p>è¿›è¡Œè¿™ä¸ªæ“ä½œæ˜¯ï¼š<code>synchronize_rcu()</code>, è¿™ä¸ªå‡½æ•°åœ¨å†…æ ¸ä¸­å®ç°æœ‰ç‚¹å¤æ‚ï¼Œå®ƒæ¯•ç«Ÿè¿˜éœ€è¦è€ƒè™‘ä¸­æ–­ï¼Œçƒ­æ’æ‹”ç­‰å› ç´ ã€‚å¦‚æœåªè€ƒè™‘RCUéƒ¨åˆ†ï¼Œå®ƒçš„åŠŸèƒ½å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191154.png" alt="image-20211016173620773" style="zoom:80%;" />

<p>ç¬¬ä¸€ä¸ªå‡½æ•°ç”¨æ¥éå†æ‰€æœ‰çš„CPUï¼›ç¬¬äºŒè¡Œrun_on()å‡½æ•°ç”¨æ¥å°†å½“å‰çº¿ç¨‹åˆ‡æ¢åˆ°æŒ‡å®šçš„CPUä¸Šã€‚å¦‚æœè¿™ä¸ªä»»åŠ¡é¡ºåˆ©å®Œæˆï¼Œåˆ™è¯´æ˜æ‰€æœ‰çš„æ ¸å·²ç»ç»å†è¿‡ä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæ­¤åˆ»å¿…å®šè¯»ç«¯å·²ç»ç»“æŸï¼Œå¦åˆ™æ— æ³•è§¦å‘åˆ‡æ¢ã€‚</p>
<p>å…³äºè¿™é‡Œï¼Œæˆ‘æ›¾ç»æœ‰ä¸€ä¸ªç–‘é—®ï¼š<strong>å‡å¦‚æœ€åˆCPU1è¯»ç«¯ç»“æŸï¼Œæ‰§è¡Œäº†ä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼›ç„¶ååœ¨ç­‰å¾…å…¶ä»–CPUè¿‡ç¨‹ä¸­ï¼Œåˆå†æ¬¡è¿›å…¥RCUè¯»ä¸´ç•ŒåŒºï¼Œå¦‚æœæ­¤æ—¶é‡Šæ”¾ï¼Œä¼šå¯¼è‡´ä¸¥é‡åæœå—ï¼Ÿ</strong> æœ‰ç‚¹ç±»ä¼¼äºä¸‹å›¾(é»„è‰²éƒ¨åˆ†è¡¨ç¤ºå¯ä»¥è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢)</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191157.png" alt="image-20211016174842445" style="zoom: 80%;" />

<p>ä¸è¿‡åæ¥æƒ³æ˜ç™½äº†ã€‚ä»¥æ›¿æ¢ä¸€ä¸ªèŠ‚ç‚¹ä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼š</p>
<ul>
<li><font color="#0000ff"><b>é“¾è¡¨æœ€åˆçŠ¶æ€å¦‚ä¸‹ï¼š</b></font></li>
</ul>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191202.png" alt="image-20211016175959004" style="zoom:80%;" />



<ul>
<li><p><font color="#0000ff"><b>æ’å…¥ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå…ˆå¤åˆ¶ä¸€ä¸ªå‰¯æœ¬ï¼Œå†æ¬¡åŸºç¡€ä¸Šä¿®æ”¹ï¼Œç„¶åå®Œæˆå‘å¸ƒ</b></font></p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191203.png" alt="image-20211016180113839" style="zoom:80%;" />

<p>ä»æ­¤åˆ»å¼€å§‹ï¼Œrcuå®½é™æœŸä¹Ÿå¼€å§‹ã€‚åœ¨å‘å¸ƒä¹‹å‰çš„RCUè¯»ç«¯è®¿é—®çš„æ˜¯2å·èŠ‚ç‚¹(å¦‚æœæœ‰çš„è¯)ï¼Œå‘å¸ƒä¹‹åï¼Œæ–°æ¥çš„RCUè¯»ç«¯è¯»å–çš„æ˜¯2_newæ–°èŠ‚ç‚¹ã€‚è¿™æ˜¯RCUçš„ä¸€ä¸ªé‡è¦ç‰¹ç‚¹ï¼Œ<strong>å®æ—¶æ€§å¾ˆå¥½</strong>ã€‚</p>
<p>è¿™é‡Œè¿˜æ²¡æœ‰å®Œï¼Œæ—§çš„2å·èŠ‚ç‚¹è¿˜æ²¡æœ‰è¢«é‡Šæ”¾ã€‚</p>
</li>
<li><p><font color="#0000ff"><b>æ›´æ–°æ“ä½œï¼ˆèµ„æºå›æ”¶ï¼‰</b></font></p>
</li>
</ul>
<p><font color="#ff0000"><b>é‚£ä¹ˆä»€ä¹ˆæ—¶å€™é‡Šæ”¾å‘¢ï¼Ÿ</b></font> <strong>å½“ç„¶æ˜¯æ‰€æœ‰ä½¿ç”¨2å·èŠ‚ç‚¹çš„è¯»ç«¯éƒ½å®Œæˆäº†å†é‡Šæ”¾</strong>ã€‚</p>
<p><font color="#ff0000"><b>é‚£ä¹ˆä»€ä¹ˆæ—¶å€™æ‰€æœ‰çš„è¯»ç«¯å®Œæˆå‘¢ï¼Ÿ</b></font>å°±æ˜¯åˆšæ‰æåˆ°çš„ï¼Œ**<code>synchronize_rcu()</code>å‡½æ•°çš„ä»»åŠ¡**ã€‚æ­¤å‡½æ•°è¿”å›åæˆ‘ä»¬å°±å¯ä»¥é‡Šæ”¾äº†ï¼ˆå¼‚æ­¥é‡Šæ”¾ä¹Ÿå·®ä¸å¤šï¼Œåªä¸è¿‡é€šè¿‡å›è°ƒå‡½æ•°æ¥å®Œæˆæ­¤é¡¹æ“ä½œï¼‰</p>
<p>å†å›åˆ°åˆšæ‰çš„é—®é¢˜ï¼š<font color="#ff00f0"><b>å¦‚æœCPUéƒ½å·²ç»å®Œæˆäº†ä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå‡†å¤‡è¿›è¡Œèµ„æºé‡Šæ”¾æ—¶(ä¾‹å¦‚å°†ä¸Šé¢çš„2èŠ‚ç‚¹é‡Šæ”¾)ï¼Œå…¶ä»–CPUåˆé‡æ–°è¿›å…¥ä¸´ç•ŒåŒºæ€ä¹ˆåŠï¼Ÿ  </b></font></p>
<p>ç­”æ¡ˆæ˜¯ï¼š<font color="#0000ff"><b>å†æ¬¡è¿›å…¥ä¸´ç•ŒåŒºçš„è¯»ç«¯è·å–çš„æ˜¯æ–°çš„èŠ‚ç‚¹2_new, åŸæ¥çš„èŠ‚ç‚¹2å·²ç»ä¸èƒ½å†è¢«æ–°çš„è¯»è€…è®¿é—®åˆ°äº†ã€‚</b></font></p>
<blockquote>
<p>è¿™ç§æ£€æŸ¥åŸç†ä¸Šç®€å•äº†å¾ˆå¤šï¼Œ<strong>ä½†ä¹Ÿå¯¼è‡´äº†rcuå®½é™æœŸæ¯”è¾ƒé•¿</strong>ã€‚æ¯•ç«Ÿè¿™ä¸ªä¸Šä¸‹æ–‡åˆ‡æ¢æ˜¯ä¸ªå…¨å±€è®¾ç½®ï¼Œå¾—ç…§é¡¾åˆ°æ‰€æœ‰çš„CPUã€‚</p>
</blockquote>
<h3 id="3-RCU-è¯»ç«¯å’Œå†™ç«¯åŒæ—¶æ“ä½œï¼Œä¸ä¼šè§¦å‘æ®µé”™è¯¯å—ï¼Ÿ"><a href="#3-RCU-è¯»ç«¯å’Œå†™ç«¯åŒæ—¶æ“ä½œï¼Œä¸ä¼šè§¦å‘æ®µé”™è¯¯å—ï¼Ÿ" class="headerlink" title="3.  RCU è¯»ç«¯å’Œå†™ç«¯åŒæ—¶æ“ä½œï¼Œä¸ä¼šè§¦å‘æ®µé”™è¯¯å—ï¼Ÿ"></a>3.  RCU è¯»ç«¯å’Œå†™ç«¯åŒæ—¶æ“ä½œï¼Œä¸ä¼šè§¦å‘æ®µé”™è¯¯å—ï¼Ÿ</h3><p>è¿™ä¸ªé—®é¢˜ä¹Ÿæ˜¯æˆ‘å½“åˆç™¾æ€ä¸å¾—å…¶è§£çš„åœ°æ–¹ã€‚</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191207.png" alt="image-20211016182131327" style="zoom:80%;" />

<p>åœºæ™¯ï¼š</p>
<ul>
<li>è¯»ç«¯å·²ç»è¿›å…¥åˆ°1å·èŠ‚ç‚¹</li>
<li>å†™ç«¯å·²ç»å¤åˆ¶äº†2å·èŠ‚ç‚¹2_newï¼Œå®Œæˆäº†æ•°æ®æ›´æ–°ï¼Œå¹¶ä¸”å°†2_newçš„åç»§æŒ‡é’ˆæŒ‡å‘äº†3å·èŠ‚ç‚¹</li>
<li>å†™ç«¯å¼€å§‹ä¿®æ”¹1å·èŠ‚ç‚¹çš„åç»§æŒ‡é’ˆï¼Œä»2å·èŠ‚ç‚¹åˆ‡æ¢åˆ°2_newèŠ‚ç‚¹ï¼›ä½†æ˜¯è¯»ç«¯ä¹Ÿæ­£å¥½åœ¨1å·èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ï¼Œæ­¤æ—¶ä¼šå‡ºç°åç»§èŠ‚ç‚¹ä¸ºç©ºå¯¼è‡´<strong>é“¾è¡¨éå†æå‰ç»“æŸçš„æƒ…å†µ</strong>å—ï¼Ÿ</li>
</ul>
<p>è¿™ä¸ªé—®é¢˜å›°æ‰°äº†å¾ˆä¹…ã€‚ä¸è¿‡å½“æˆ‘å†æ¬¡è¯»<a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a>æ—¶ï¼Œå‘ç°äº†ä¸Šé¢æœ‰è¿™ä¸ªé—®é¢˜çš„å›ç­”ã€‚æœ€åˆçœ‹æ—¶ç«Ÿç„¶æ²¡æœ‰æ³¨æ„åˆ°è¿™ä¸ªé—®é¢˜ã€‚</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191212.png" alt="image-20211016182733118"></p>
<p>ç®€å•çš„è¯´ï¼š<font color="#0000ff"><b>åœ¨Linuxç³»ç»Ÿä¸­ï¼Œæ‰€æœ‰çš„åŠ è½½å’Œå­˜å‚¨æ“éƒ½æ˜¯åŸå­çš„ï¼Œä¸å¯èƒ½è¢«åˆ†å‰²ã€‚é’ˆå¯¹ä¸Šè¿°åœºæ™¯ï¼Œè¯»ç«¯è¦ä¹ˆè¯»å–åˆ°2èŠ‚ç‚¹ï¼Œè¦ä¹ˆè¯»å–åˆ°2_newèŠ‚ç‚¹ã€‚ä¸ä¼šå‡ºç°ç¬¬ä¸‰ç»“æœã€‚</b></font></p>
<h3 id="4-RCU-ä¸èµ„æºå›æ”¶"><a href="#4-RCU-ä¸èµ„æºå›æ”¶" class="headerlink" title="4.  RCU ä¸èµ„æºå›æ”¶"></a>4.  RCU ä¸èµ„æºå›æ”¶</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191216.png" alt="image-20211016183741869"></p>
<p>æœ€åˆæ€ä¹ˆä¹Ÿä¸ä¼šå°†è¿™ä¸¤ä¸ªè”ç³»èµ·æ¥ã€‚ä½†æ˜¯æ…¢æ…¢å‘ç°æœ‰é‚£ä¹ˆä¸€ä¸ç‚¹åƒ</p>
<p><strong>RCUä¼šç­‰å¾…èµ„æºä¸å†è¢«å¼•ç”¨æ—¶é‡Šæ”¾å¯¹åº”çš„èµ„æº</strong>ã€‚ä»è¿™ä¹ˆä¸€ç‚¹çœ‹è¿˜ç¡®å®æœ‰ç‚¹åƒGCçš„èµ¶è„š</p>
<p>ä¸è¿‡ä»–ä»¬æœ€å¤§çš„åŒºåˆ«åœ¨äº(ä»èµ„æºå›æ”¶ä¸Šçœ‹)ï¼šç¨‹åºå‘˜å¿…é¡»æ‰‹åŠ¨æŒ‡å®šRCUè¯»ç«¯ä¸´ç•ŒåŒºèµ„æºï¼Œç”šè‡³æ‰‹åŠ¨æŒ‡å®šé‡Šæ”¾çš„ä½ç½®ã€‚</p>
]]></content>
      <categories>
        <category>Linuxå†…æ ¸</category>
      </categories>
      <tags>
        <tag>Linuxå†…æ ¸</tag>
        <tag>åŒæ­¥äº’æ–¥æœºåˆ¶</tag>
      </tags>
  </entry>
</search>
