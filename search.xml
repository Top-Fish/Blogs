<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>💝openswan专栏目录💝</title>
    <url>/blogs/2021/11/20/openswan%E4%B8%93%E6%A0%8F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><font color="#0000bb">为了方便查阅现有的文章，特准备一个目录页供后续查询使用</font></p>
<span id="more"></span>

<img src="https://img-blog.csdnimg.cn/20201122205357123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MyNjAzODk4MjYw,size_16,color_FFFFFF,t_70#pic_center"  />


<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105780700">专栏序言</a></li>
</ul>
<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105810406">openswan任务调度基础知识之信号</a><h3 id="2-openswan环境搭建"><a href="#2-openswan环境搭建" class="headerlink" title="2. openswan环境搭建"></a>2. openswan环境搭建</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112975141">openswan框架和编译时说明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105855454">openswan编译安装</a><h3 id="3-NAT穿越"><a href="#3-NAT穿越" class="headerlink" title="3. NAT穿越"></a>3. NAT穿越</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105214411">NAT-T下的端口浮动</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105212626">NAT-T原理和环境搭建</a><h3 id="4-openswan函数笔记"><a href="#4-openswan函数笔记" class="headerlink" title="4. openswan函数笔记"></a>4. openswan函数笔记</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106172947">in_struct和out_struct讲解</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106131750">openswan发送状态分析</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107913541">pluto中监听各个网口的500端口处理逻辑</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="">pluto中CPU占有率高的接口与优化方案</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106578067">Openswan支持的算法及参数信息</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113447879">命令行解析函数：getopt_long、getopt</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113445039">ipsec.conf配置文件多个保护子网解析流程</a> </li>
</ul>
<h3 id="5-IKEv1协商流程"><a href="#5-IKEv1协商流程" class="headerlink" title="5. IKEv1协商流程"></a>5. IKEv1协商流程</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226299">openswan协商流程之（一）：main_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226416">openswan协商流程之（二）：main_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106247599">openswan协商流程之（三）：main_inR1_outI2()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106271199">openswan协商流程之（四）：main_inI2_outR2()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106310714">openswan协商流程之（五）：main_inR2_outI3()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106580396">openswan协商流程之（六）：main_inI3_outR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106592883">openswan协商流程之（七）：main_inR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108252077">openswan快速模式协商流程之（一）：quick_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108459144">openswan快速模式协商流程之（二）：quick_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108560293">openswan快速模式协商流程之（三）：quick_inR1_outI2()</a></li>
</ul>
<hr>
<h3 id="6-IKEv2协议相关"><a href="#6-IKEv2协议相关" class="headerlink" title="6. IKEv2协议相关"></a>6. IKEv2协议相关</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106915035">IKEv2协议简介</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107117675">IKEv2协议关键知识点总结整理</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109019539">IKEv2协议协商流程: （IKE-SA-INIT 交换）第一包</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109062848">IKEv2协议协商流程: （IKE-SA-INIT 交换）第二包</a></li>
</ul>
<h3 id="7-加密流程"><a href="#7-加密流程" class="headerlink" title="7. 加密流程"></a>7. 加密流程</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109929113">ipsec 加密流程（一）：ipsec策略匹配</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109943878">ipsec 加密流程（二）：ipsec初始化操作</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110018251">ipsec 加密流程（三）：ESP加密、AH认证处理流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110410067">ipsec 加密流程（四）：封装状态机和发送流程</a></li>
</ul>
<h3 id="8-💖openswan进阶💖"><a href="#8-💖openswan进阶💖" class="headerlink" title="8. 💖openswan进阶💖"></a>8. 💖openswan进阶💖</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113043610">ubantu与CentOS虚拟机之间搭建GRE隧道</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113008094">🔥openswan一条隧道多保护子网配置</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://mp.csdn.net/mp_blog/creation/editor/113075156">🔥为何GRE可以封装组播报文而IPSEC却不行？</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/120593578">🔥SSL/TLS 与 IPSec 对比</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113575857">🔥IKE 多预共享密钥问题 解决方案</a><h3 id="9-图解密码学技术"><a href="#9-图解密码学技术" class="headerlink" title="9. 图解密码学技术"></a>9. 图解密码学技术</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112341844">DH算法图解+数学证明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112503905">openswan中DH算法说明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112744384">图解密码学(一)</a></li>
</ul>
<h3 id="10-Linux内核IPSEC实现"><a href="#10-Linux内核IPSEC实现" class="headerlink" title="10. Linux内核IPSEC实现"></a>10. Linux内核IPSEC实现</h3>]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/blogs/2021/11/27/http-Go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]-->
<!DOCTYPE html>
<html>
<head>
<title>http-Go源码学习</title>
<meta charset="utf-8"/>
</head>
<body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2021-11-27T08:59:35.445Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/14.6.13 Chrome/89.0.4389.128 Electron/12.0.7 Safari/537.36\&quot; etag=\&quot;GzUUDeYV433fBMNxRnRn\&quot; version=\&quot;14.6.13\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;dNDh_BFLtLueB-oMKNk3\&quot; name=\&quot;Go源码学习\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
</body>
</html>]]></content>
  </entry>
  <entry>
    <title>IPSEC的实现方式</title>
    <url>/blogs/2021/11/20/IPSEC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在IPSEC通信中涉及到一个重要方面，那就是如何定义要保护的数据流（又称为感兴趣流）。这不仅涉及到IPSEC最终要保护哪部分数据，还关系到IPSEC的实现方式，因此有必要把感兴趣流的定义方式进行详细说明。</p>
<span id="more"></span>

<h3 id="1-感兴趣流的定义方式"><a href="#1-感兴趣流的定义方式" class="headerlink" title="1. 感兴趣流的定义方式"></a>1. 感兴趣流的定义方式</h3><p>“感兴趣流”指的是哪些数据可以进入IPsec隧道进行传输，哪些数据不能进入IPsec隧道传输。在现有的IPsec 实现过程中，最常用的实现方式有两种：<strong>“基于ACL”</strong>、<strong>“基于虚拟隧道接口”</strong>。下面我们对这两中方式进行详细的介绍。</p>
<h3 id="2-基于ACL-访问控制-方式"><a href="#2-基于ACL-访问控制-方式" class="headerlink" title="2. 基于ACL(访问控制)方式"></a>2. 基于ACL(访问控制)方式</h3><p>​        我们知道，高级IP ACL可以基于源/目的IP地址、源/目的端口、协议等信息对数据报文进行过滤， 而这IPsec正好可以使用ACL的方式来确定哪些数据报文需要隧道保护。</p>
<p>​        当使用当采用ACL的方式来定义“感兴趣流”时，手动方式和IKE协商方式建立的IPsec 隧道是由高级ACL来指定需要保护的数据流范围，并从中过滤出需要进行IPsec隧道的报文。ACL规则允许的报文(permit)将被保护；ACL规则拒绝的报文(deny)将不会被保护。 </p>
<p>​        因为这里的ACL为<strong>高级IP ACL</strong>, 所以可以明确的指定数据报文中的==源/目的IP地址<strong>、</strong>源/目的端口<strong>、</strong>协议类型==等参数。但是这里的源、目的IP地址指数据发送方和接收方的主机IP地址，通常是两端内部网络中的私网地址。</p>
<p>​        这种基于ACL方式定义感兴趣流的方式的优点是：</p>
<blockquote>
<p>可以利用ACL配置的灵活性，根据IP地址、端口信息、协议类型(TCP, UDP, ICMP, IP等)等信息对报文进行过滤从而指定灵活的IPSec保护方法。</p>
</blockquote>
<h3 id="3-基于虚拟隧道接口方式"><a href="#3-基于虚拟隧道接口方式" class="headerlink" title="3. 基于虚拟隧道接口方式"></a>3. 基于虚拟隧道接口方式</h3><p>​        基于虚拟隧道接口来定义需要保护的数据流，首先需要在两端的IPsec设备<strong>创建一个虚拟的隧道接口Tunnel</strong>, 然后通过配置以该Tunnel接口为出接口的静态路由，以此来将到达某一个子网的数据流量通过IPSec隧道进行转发。因为Tunnel接口为点对点类型的接口，是运行PPP链路层协议的，因此以该接口为出接口的静态路由是可以不指定下一跳IP地址的。</p>
<p>​        IPsec虚拟隧道接口是一种三层逻辑接口，采用这种方式时，<strong>所有路由到IPsec虚拟隧道接口上的报文都将进行IPSec保护，而不再对数据流类型进行细分</strong>。使用IPSec虚拟隧道接口有如下诸多优点：</p>
<ul>
<li><p><strong>简化配置</strong></p>
<p>只需要将IPSec保护的数据流引到虚拟隧道接口上，无需再通过ACL来定义加解密流量的特征。这使得IPSec的配置不会受到网络规划的影响，增加了网络规划的可扩展性，降低了网络维护的成本。</p>
</li>
<li><p><strong>较小开销</strong></p>
<p>在保护远程接入用户流量的组网中，只需要在IPSec虚拟隧道接口处进行IPSec报文封装，与IPSec over GRE 或者 IPSec over L2TP方式的隧道封装相比，较少了封装层次，节省了带宽。</p>
</li>
<li><p><strong>支持范围更广</strong></p>
<p>==点对点IPSec虚拟隧道接口可以支持动态路由协议，同时还可以支持对组播流量的报文==。另外，IPSec虚拟隧道接口在实施过程中明确的区分出“加密前”和“加密后”两个阶段，用户可以根据不同的组网需求灵活的选择其他业务(例如NAT, QoS)实施的阶段。 例如用户希望对加密前的报文进行QoS，则可以在IPSec虚拟隧道接口上应用QoS策略；如果希望对IPSec封装后的报文应用QoS，则可以在报文发送的物理接口上应用QoS策略。</p>
</li>
</ul>
<h3 id="4-虚拟隧道接口"><a href="#4-虚拟隧道接口" class="headerlink" title="4. 虚拟隧道接口"></a>4. 虚拟隧道接口</h3><p>​    IPSec 虚拟隧道接口(即Tunnel接口)，是一种支持路由的三层逻辑接口，它可以支持动态路由协议、所有路由到IPSec虚拟隧道接口的报文都将进行IPSec保护，同时可以支持对组播流量的保护。</p>
<p>​    下面简单介绍下IPSec隧道两端的虚拟隧道接口上报文处理流程：</p>
<h4 id="4-1-IPSec虚拟隧道接口上封装和加密流程"><a href="#4-1-IPSec虚拟隧道接口上封装和加密流程" class="headerlink" title="4.1 IPSec虚拟隧道接口上封装和加密流程"></a>4.1 IPSec虚拟隧道接口上封装和加密流程</h4><p>用户数据到达IPSec设备(如路由器)，需要被IPSec保护的报文(==感兴趣流==)会被转发到IPSec虚拟隧道接口上进行封装和加密。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120210702.png" alt="image-20200515224718740"></p>
<ul>
<li>Router将从入接口上收到的明文IP报文后发送到转发模块进行处理</li>
<li>转发模块依据路由表查询结果进行转发，如果为相应的感兴趣流，会被引到IPSec虚拟隧道接口上进行AH或ESP封装;</li>
<li>IPSec虚拟隧道接口完成对明文的封装处理后，根据建立的IPSec SA安全策略再将封装后的报文进行加密，然后再将加密后的报文交由转发模块进行处理</li>
<li>转发模块通过第二次转发查询后，将已经封装完毕的加密IPSec报文通过相应的物理接口发送出去，最终密文到达对端的IPSec设备的虚拟隧道接口上。</li>
</ul>
<h4 id="4-2-IPSec虚拟隧道接口上解封装和解密流程"><a href="#4-2-IPSec虚拟隧道接口上解封装和解密流程" class="headerlink" title="4.2 IPSec虚拟隧道接口上解封装和解密流程"></a>4.2 IPSec虚拟隧道接口上解封装和解密流程</h4><p>数据经过IPSec隧道传输到达对端IPSec设备时，需要对数据包进行解密、解封装处理。它的处理流程如下所示:</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120210705.png" alt="image-20200515225103796"></p>
<ul>
<li>Router将从入接口上收到的加密的IP报文发送到转发模块进行处理</li>
<li>转发模块识别到此密文的目的IP地址为本设备的隧道接口IP地址，且IP报文协议号为ESP、AH、UDP时，会将此报文发送到相应的虚拟隧道接口上进行解密和解封装处理;</li>
<li>IPSec虚拟隧道接口完成对密文的解封装处理后，再将解封装后的报文交由转发模块进行处理</li>
<li>转发模块通过第二次转发查询后，将IP明文通过相应的物理接口发送出去，最终密文到达相应的主机上。</li>
</ul>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>openswan专栏序言</title>
    <url>/blogs/2021/11/20/openswan%E4%B8%93%E6%A0%8F%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<h2 id="openswan专栏序言"><a href="#openswan专栏序言" class="headerlink" title="openswan专栏序言"></a>openswan专栏序言</h2><p><strong>“一杯茶，一包烟，一个bug解一天！！！”。</strong></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120225547.jpg"></p>
<span id="more"></span>        

<p>2020年春季，正值新冠病毒在全球肆虐之际，美国的疫情已经相当的严峻，每天仍以3万速度狂奔。而国内的疫情在全国人民的共同努力下已经逐渐减弱，并趋于正常，人们的工作、生活逐步步入正轨。在这里由衷的希望全球人们早日度过难关，开始新的征程。 </p>
<p>​        首先需要说明openswan的起源。 现在网络已经基本实现了互联互通，但是通讯面临着很大的挑战：不安全，容易被攻击、窃听。比如几年前的棱镜门事件。而为了实现安全网络通讯，出现了各种各样的加密手段：网络层加密、传输层加密、套接字层加密等等。而IPsec便是网络层加密的一个杰出的代表，IPsec的开源实现包括最初的freeswan, 以及之后的再次基础上开发的openswan和strongswan工程。我们这里主要通过openswan来学习IPsec功能。</p>
<p>​        今天特别的在CSDN开通一个openswan源码专栏，主要用来分享个人在学习openswan源码的过程中的心得和体会，将用到的知识和技术分享出来，同时也提供一个平台供大家交流学习。开通这个专栏的目的主要是由于：在学习的过程中，找到的可用资料很少，基本只能去查询RFC文档、分析源码，这样固然让我们印象更加深刻，但是会浪费很多的时间。尽管如此，也可能找不到合适的资料或者结论，因此为了节省宝贵的时间，特将个人的学习历程、获得的资料、用到的知识和技术信息、等等各种信息全部以博客的方式分享。同时也会将笔记、流程图、思维导图等信息整理为文档，后期如果需要则可提交至网盘，并在博客里附上相应的链接。</p>
<p>​        由于openswan的源码代码量比较多，且涉及到的知识也很广，比如加解密算法、IKE协商、PKI公钥设施等，因为它的最终目的是安全，而不是创建隧道访问内网，因此涉及到很多的算法，这部分导致了IPsec学习起来很费力、枯燥。个人没有这部分算法的任何基础，因此对算法的介绍会放到其他工作之后。在接下来的多半年时间里（2020年5月~2021年初），我会尽自己最大的努力来学习openswan源码。计划是每周做一篇博客用来记录这一周时间内的学习心得和技术，同时也会将注释后的代码进行分享。希望通过自己的努力和付出，为其他人节省更多的时间来学习其他的知识和技术。同时其他人也可以将自己的疑问、见解、相关技术分享出来供大家学习和讨论，增进理解。        </p>
<p>结语：决定一个人成就的，不是天分，也不是运气，而是坚持和付出，是不停的做，重复的做，用心的做。如果没有阳光，我们要学会享受风雨的清凉；如果没有鲜花，我们要学会享受泥土的芬芳；记住每天鼓励自己，越努力，越勤奋，越幸运，越感恩，越幸福。</p>
<p>​        </p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第二包：main_inI1_outR1()</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%8C%E5%8C%85%EF%BC%9Amain_inI1_outR1()/</url>
    <content><![CDATA[<h2 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h2><p><code>main_inI1_outR1()</code>函数是ISAKMP协商过程中第二包的核心处理函数，同时也是响应端口的首包。这里我们主要说明<code>main_inI1_outR1</code>的处理流程，关于<code>main_inI1_outR1</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，一个函数有几百行都是很常见的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<h3 id="2-main-inI1-outR1-处理流程图"><a href="#2-main-inI1-outR1-处理流程图" class="headerlink" title="2. main_inI1_outR1()处理流程图"></a>2. <code>main_inI1_outR1()</code>处理流程图</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205011.png" alt="image-20200520004303196"></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205022.png" alt="image-20200520004352037"></p>
<h3 id="3-main-inI1-outR1-源码"><a href="#3-main-inI1-outR1-源码" class="headerlink" title="3. main_inI1_outR1()源码"></a>3. <code>main_inI1_outR1()源码</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* State Transition Functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The definition of state_microcode_table in demux.c is a good</span></span><br><span class="line"><span class="comment"> * overview of these routines.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Called from process_packet; result handled by complete_v1_state_transition</span></span><br><span class="line"><span class="comment"> * - struct state_microcode member &quot;processor&quot; points to these</span></span><br><span class="line"><span class="comment"> * - these routine definitionss are in state order</span></span><br><span class="line"><span class="comment"> * - these routines must be restartable from any point of error return:</span></span><br><span class="line"><span class="comment"> *   beware of memory allocated before any error.</span></span><br><span class="line"><span class="comment"> * - output HDR is usually emitted by process_packet (if state_microcode</span></span><br><span class="line"><span class="comment"> *   member first_out_payload isn&#x27;t ISAKMP_NEXT_NONE).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The transition functions&#x27; functions include:</span></span><br><span class="line"><span class="comment"> * - process and judge payloads</span></span><br><span class="line"><span class="comment"> * - update st_iv (result of decryption is in st_new_iv)</span></span><br><span class="line"><span class="comment"> * - build reply packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle a Main Mode Oakley first packet (responder side).</span></span><br><span class="line"><span class="comment"> * HDR;SA --&gt; HDR;SA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************</span></span><br><span class="line"><span class="comment">*main_inI1_outR1函数被process_packet函数调用</span></span><br><span class="line"><span class="comment">*它的返回结果由complete_v1_state_transition处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*********************************/</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI1_outR1</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DMALLOC</span></span><br><span class="line">     <span class="keyword">if</span> (_dm_initialized != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* log unfreed pointers that have been added to the heap since mark */</span></span><br><span class="line">	dmalloc_log_changed(_dm_mark, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	dmalloc_log_stats ();</span><br><span class="line">     &#125;</span><br><span class="line">     _dm_mark = dmalloc_mark() ;</span><br><span class="line">     _dm_initialized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*接收到的数据包中的SA载荷部分*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sa_pd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="comment">/*准备作为应答的SA载荷缓冲区*/</span></span><br><span class="line">    pb_stream r_sa_pbs;</span><br><span class="line">    <span class="keyword">lset_t</span> policy_hint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we are looking for an OpenPGP Vendor ID sent by the peer */</span></span><br><span class="line">    <span class="keyword">bool</span> openpgp_peer = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determin how many Vendor ID payloads we will be sending */</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> numvidtosend = <span class="number">1</span>;  <span class="comment">/* we always send DPD VID */</span></span><br><span class="line"><span class="comment">/*至少会发送DPD的VID,因此初始值为1*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL   <span class="comment">/*支持NAT-T,则增加一个nat-t探测的VID*/</span></span></span><br><span class="line">    <span class="keyword">if</span> (md-&gt;quirks.nat_traversal_vid &amp;&amp; nat_traversal_enabled) &#123;</span><br><span class="line">	DBG(DBG_NATT, DBG_log(<span class="string">&quot;nat-t detected, sending nat-t VID&quot;</span>));</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*如果预定义了PLUUO VID 或openpgp 对端, 增加VID 数量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SEND_PLUTO_VID || defined(openpgp_peer)</span></span><br><span class="line">    numvidtosend++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(openpgp_peer)</span></span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">p</span>;</span></span><br><span class="line">	   <span class="comment">/*遍历接收到的数据包中的VID 载荷链表*/</span></span><br><span class="line">	    <span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_VID]; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">int</span> vid_len = <span class="keyword">sizeof</span>(pgp_vendorid) - <span class="number">1</span> &lt; pbs_left(&amp;p-&gt;pbs)</span><br><span class="line">			? <span class="keyword">sizeof</span>(pgp_vendorid) - <span class="number">1</span> : pbs_left(&amp;p-&gt;pbs);</span><br><span class="line"></span><br><span class="line">		    <span class="comment">/*检查是否是pgp VID, 是则设置openpgp_peer 标志为TRUE*/</span></span><br><span class="line">		    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(pgp_vendorid, p-&gt;pbs.cur, vid_len) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			    openpgp_peer = TRUE;</span><br><span class="line">			    DBG(DBG_PARSING,</span><br><span class="line">				DBG_log(<span class="string">&quot;we have an OpenPGP peer&quot;</span>)</span><br><span class="line">				)</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据接收到的数据包的目的地址,目的端口,源地址,源端口查找连接结构*/</span></span><br><span class="line">    <span class="comment">/* random source ports are handled by find_host_connection */</span></span><br><span class="line">    c = find_host_connection(ANY_MATCH, &amp;md-&gt;iface-&gt;ip_addr, pluto_port500</span><br><span class="line">                             , KH_IPADDR</span><br><span class="line">			     , &amp;md-&gt;sender</span><br><span class="line">			     , md-&gt;sender_port, LEMPTY, POLICY_IKEV1_DISABLE, &amp;policy_hint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>)<span class="comment">/*如果没找到*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream pre_sa_pbs = sa_pd-&gt;pbs;</span><br><span class="line">	<span class="keyword">lset_t</span> policy = preparse_isakmp_sa_body(&amp;pre_sa_pbs);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is XAUTH VID, copy it to policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (md-&gt;quirks.xauth_vid == TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">	  policy |= POLICY_XAUTH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* See if a wildcarded connection can be found.</span></span><br><span class="line"><span class="comment">	 * We cannot pick the right connection, so we&#x27;re making a guess.</span></span><br><span class="line"><span class="comment">	 * All Road Warrior connections are fair game:</span></span><br><span class="line"><span class="comment">	 * we pick the first we come across (if any).</span></span><br><span class="line"><span class="comment">	 * If we don&#x27;t find any, we pick the first opportunistic</span></span><br><span class="line"><span class="comment">	 * with the smallest subnet that includes the peer.</span></span><br><span class="line"><span class="comment">	 * There is, of course, no necessary relationship between</span></span><br><span class="line"><span class="comment">	 * an Initiator&#x27;s address and that of its client,</span></span><br><span class="line"><span class="comment">	 * but Food Groups kind of assumes one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">// 可能是那种未定义对方地址的动态连接, 将源地址条件置空,重新查找连接,</span></span><br><span class="line">       <span class="comment">// 可能会找到多个连接结构,返回的是一个链表</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">d</span>;</span></span><br><span class="line">	    d = find_host_connection(ANY_MATCH, &amp;md-&gt;iface-&gt;ip_addr, pluto_port500</span><br><span class="line">                                     , KH_ANY</span><br><span class="line">				     , (ip_address*)<span class="literal">NULL</span></span><br><span class="line">				     , md-&gt;sender_port, policy, POLICY_IKEV1_DISABLE, &amp;policy_hint);</span><br><span class="line">           <span class="comment">// 遍历链表</span></span><br><span class="line">	    <span class="keyword">for</span> (; d != <span class="literal">NULL</span>; d = d-&gt;IPhp_next)</span><br><span class="line">	    &#123;</span><br><span class="line">	       <span class="comment">// GROUP 类型连接不考虑</span></span><br><span class="line">		<span class="keyword">if</span> (d-&gt;kind == CK_GROUP)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="comment">/* ignore */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">// 如果连接类型为模板型而且没定义OE, 该连接可用于处理该数据包, 连接找到,中断循环</span></span><br><span class="line">		    <span class="keyword">if</span> (d-&gt;kind == CK_TEMPLATE &amp;&amp; !(d-&gt;policy &amp; POLICY_OPPO))</span><br><span class="line">		    &#123;</span><br><span class="line">			<span class="comment">/* must be Road Warrior: we have a winner */</span></span><br><span class="line">			c = d;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		    <span class="comment">/* Opportunistic or Shunt: pick tightest match */</span></span><br><span class="line">			<span class="comment">// 比较数据包源地址是否匹配连接中对方地址的定义</span></span><br><span class="line">		    <span class="keyword">if</span> (addrinsubnet(&amp;md-&gt;sender, &amp;d-&gt;spd.that.client)</span><br><span class="line">		      <span class="comment">// 而且目前可用连接为空,或目前可用连接的地址范围比新找到的连接范围大, 更新可用连接</span></span><br><span class="line">		    &amp;&amp; (c == <span class="literal">NULL</span> || !subnetinsubnet(&amp;c-&gt;spd.that.client, &amp;d-&gt;spd.that.client)))</span><br><span class="line">			c = d;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 如果没找到连接, 该数据包处理不了, 返回忽略该数据包</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		<span class="string">&quot; but no connection has been authorized%s%s&quot;</span></span><br><span class="line">		, ip_str(&amp;md-&gt;iface-&gt;ip_addr), ntohs(portof(&amp;md-&gt;iface-&gt;ip_addr))</span><br><span class="line">		, (policy != LEMPTY) ? <span class="string">&quot; with policy=&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">		, (policy != LEMPTY) ? bitnamesof(sa_policy_bit_names, policy) : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(policy_hint &amp; POLICY_IKEV1_DISABLE) &#123;</span><br><span class="line">                md-&gt;note = INVALID_MAJOR_VERSION;</span><br><span class="line">                <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* XXX notification is in order! */</span></span><br><span class="line">	    <span class="keyword">return</span> STF_IGNORE;</span><br><span class="line">	&#125;<span class="comment">/* 否则如果不是模板类型连接(动态连接), 返回忽略*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;kind != CK_TEMPLATE)</span><br><span class="line">	&#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		<span class="string">&quot; but \&quot;%s\&quot; forbids connection&quot;</span></span><br><span class="line">		, ip_str(&amp;md-&gt;iface-&gt;ip_addr), pluto_port500, c-&gt;name);</span><br><span class="line">	    <span class="comment">/* XXX notification is in order! */</span></span><br><span class="line">	    <span class="keyword">return</span> STF_IGNORE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* Create a temporary connection that is a copy of this one.</span></span><br><span class="line"><span class="comment">	     * His ID isn&#x27;t declared yet.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	   DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;instantiating \&quot;%s\&quot; for initial Main Mode message received on %s:%u&quot;</span></span><br><span class="line">		, c-&gt;name, ip_str(&amp;md-&gt;iface-&gt;ip_addr), pluto_port500));</span><br><span class="line">	<span class="comment">// 将模板连接进行实例化, 根据模板连接新生成一个新连接结构, 填充对方地址</span></span><br><span class="line">	    c = rw_instantiate(c, &amp;md-&gt;sender</span><br><span class="line">			       , <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */</span></span><br><span class="line">	<span class="keyword">if</span> ((c-&gt;kind == CK_TEMPLATE) &amp;&amp; c-&gt;spd.that.virt) &#123;</span><br><span class="line">	   DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation&quot;</span>));</span><br><span class="line">	   c = rw_instantiate(c,&amp;md-&gt;sender,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_server || c-&gt;spd.<span class="keyword">this</span>.xauth_client)</span><br><span class="line">    &#123;</span><br><span class="line">        numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Set up state */</span></span><br><span class="line"><span class="comment">// 新分配状态结构</span></span><br><span class="line">    md-&gt;st = st = new_state();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    passert(st-&gt;st_oakley.xauth == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    st-&gt;st_connection = c;</span><br><span class="line">    st-&gt;st_remoteaddr = md-&gt;sender;</span><br><span class="line">    st-&gt;st_remoteport = md-&gt;sender_port;</span><br><span class="line">    st-&gt;st_localaddr  = md-&gt;iface-&gt;ip_addr;</span><br><span class="line">    st-&gt;st_localport  = md-&gt;iface-&gt;port;</span><br><span class="line">    st-&gt;st_interface  = md-&gt;iface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKE version numbers -- used mostly in logging */</span></span><br><span class="line">    st-&gt;st_ike_maj        = md-&gt;maj;</span><br><span class="line">    st-&gt;st_ike_min        = md-&gt;min;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* (caller will reset cur_state) */</span></span><br><span class="line">    st-&gt;st_try = <span class="number">0</span>;	<span class="comment">/* not our job to try again from start */</span></span><br><span class="line">    st-&gt;st_policy = c-&gt;policy &amp; ~POLICY_IPSEC_MASK;	<span class="comment">/* only as accurate as connection */</span></span><br><span class="line">    <span class="comment">// 状态类型为R0(接收到初始化包)</span></span><br><span class="line">    change_state(st, STATE_MAIN_R0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制对方的cookie</span></span><br><span class="line">    <span class="built_in">memcpy</span>(st-&gt;st_icookie, md-&gt;hdr.isa_icookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地的cookie</span></span><br><span class="line">    get_cookie(FALSE, st-&gt;st_rcookie, COOKIE_SIZE, &amp;md-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新状态插入到状态哈希表</span></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid (0) */</span></span><br><span class="line"></span><br><span class="line">    st-&gt;st_doi = ISAKMP_DOI_IPSEC;</span><br><span class="line">    st-&gt;st_situation = SIT_IDENTITY_ONLY; <span class="comment">/* We only support this */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy the quirks we might have accumulated */</span></span><br><span class="line">	<span class="comment">// 复制特殊标志</span></span><br><span class="line">    copy_quirks(&amp;st-&gt;quirks,&amp;md-&gt;quirks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;kind == CK_INSTANCE) &amp;&amp; (c-&gt;spd.that.host_port_specific))</span><br><span class="line">    &#123;</span><br><span class="line">       openswan_log(<span class="string">&quot;responding to Main Mode from unknown peer %s:%u&quot;</span></span><br><span class="line">	    , ip_str(&amp;c-&gt;spd.that.host_addr), c-&gt;spd.that.host_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;kind == CK_INSTANCE)</span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;responding to Main Mode from unknown peer %s&quot;</span></span><br><span class="line">	    , ip_str(&amp;c-&gt;spd.that.host_addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;responding to Main Mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse_isakmp_sa also spits out a winning SA into our reply,</span></span><br><span class="line"><span class="comment">     * so we have to build our reply_stream and emit HDR before calling it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out.</span></span><br><span class="line"><span class="comment">     * We can&#x27;t leave this to comm_handle() because we must</span></span><br><span class="line"><span class="comment">     * fill in the cookie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 以下开始填充要发送的回应包信息</span></span><br><span class="line">     </span><br><span class="line">    zero(reply_buffer);</span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 填充ISAKMP头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">r_hdr</span> =</span> md-&gt;hdr;</span><br><span class="line"></span><br><span class="line">	r_hdr.isa_flags &amp;= ~ISAKMP_FLAG_COMMIT;	<span class="comment">/* we won&#x27;t ever turn on this bit */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(r_hdr.isa_rcookie, st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line">	r_hdr.isa_np = ISAKMP_NEXT_SA;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;r_hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;md-&gt;rbody))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 填充SA 结构信息</span></span><br><span class="line">    <span class="comment">/* start of SA out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_sa</span> <span class="title">r_sa</span> =</span> sa_pd-&gt;payload.sa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we to send any VID, then set the NEXT payload correctly */</span></span><br><span class="line">	r_sa.isasa_np = numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;r_sa, &amp;isakmp_sa_desc, &amp;md-&gt;rbody, &amp;r_sa_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA body in and out */</span></span><br><span class="line">	<span class="comment">/*解析对方的SA,根据他的建议载荷来确定本地是否支持，如果支持则回复支持的算法信息，并构建应答SA*/</span></span><br><span class="line">    RETURN_STF_FAILURE(parse_isakmp_sa_body(&amp;sa_pd-&gt;pbs, &amp;sa_pd-&gt;payload.sa</span><br><span class="line">					    , &amp;r_sa_pbs, FALSE, st));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*填充VID*/</span></span><br><span class="line">    <span class="keyword">if</span> (SEND_PLUTO_VID || openpgp_peer)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> *vendorid = (openpgp_peer) ?</span><br><span class="line">	    pgp_vendorid : pluto_vendorid;</span><br><span class="line"></span><br><span class="line">	next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(next, &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody</span><br><span class="line">			     , vendorid, <span class="built_in">strlen</span>(vendorid), <span class="string">&quot;Vendor ID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * NOW SEND VENDOR ID payloads</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/*填充DPD*/</span></span><br><span class="line">    <span class="comment">/* Announce our ability to do RFC 3706 Dead Peer Detection */</span></span><br><span class="line">    next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">    <span class="keyword">if</span>( !out_vid(next, &amp;md-&gt;rbody, VID_MISC_DPD))</span><br><span class="line">      <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="comment">/* If XAUTH is required, insert here Vendor ID */</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_server || c-&gt;spd.<span class="keyword">this</span>.xauth_client)</span><br><span class="line">    &#123;</span><br><span class="line">	    next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	    <span class="keyword">if</span> (!out_vendorid(next, &amp;md-&gt;rbody, VID_MISC_XAUTH))</span><br><span class="line">	       <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;sender checking NAT-T: %d and %d&quot;</span></span><br><span class="line">				, nat_traversal_enabled</span><br><span class="line">				, md-&gt;quirks.nat_traversal_vid));</span><br><span class="line">   <span class="comment">/*填充NAT-T的VID*/</span></span><br><span class="line">    <span class="keyword">if</span> (md-&gt;quirks.nat_traversal_vid &amp;&amp; nat_traversal_enabled) &#123;</span><br><span class="line"></span><br><span class="line">        next = --numvidtosend ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="comment">/* reply if NAT-Traversal draft is supported */</span></span><br><span class="line">	<span class="comment">/*nat_traversal_vid_to_method:将VID转换为对应的标准*/</span></span><br><span class="line">	st-&gt;hidden_variables.st_nat_traversal = nat_traversal_vid_to_method(md-&gt;quirks.nat_traversal_vid);</span><br><span class="line">	<span class="comment">/*填充VID载荷，这里的NAT-T VID选择的是对方发来的最大的NAT-T 的VID,也就是说选用最新的NAT-T标准*/</span></span><br><span class="line">	<span class="keyword">if</span> ((st-&gt;hidden_variables.st_nat_traversal) &amp;&amp; (!out_vendorid(next,</span><br><span class="line">	    &amp;md-&gt;rbody, md-&gt;quirks.nat_traversal_vid))) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* if we are not 0 then something went very wrong above */</span></span><br><span class="line">    <span class="keyword">if</span>(numvidtosend != <span class="number">0</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;payload alignment problem please check the code in main_inI1_outR1 (num=%d)&quot;</span>, numvidtosend);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*应答报文封装完毕，填充长度字段*/</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save initiator SA for HASH */</span></span><br><span class="line">    clonereplacechunk(st-&gt;st_p1isa, sa_pd-&gt;pbs.start, pbs_room(&amp;sa_pd-&gt;pbs), <span class="string">&quot;sa in main_inI1_outR1()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-parse-isakmp-sa-body-源码"><a href="#4-parse-isakmp-sa-body-源码" class="headerlink" title="4. parse_isakmp_sa_body()源码"></a>4. <code>parse_isakmp_sa_body()源码</code></h3><p>暂略。</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第五包：main_inR2_outI3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%94%E5%8C%85%EF%BC%9Amain_inR2_outI3/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p><code>main_inR2_outI3()</code>函数是ISAKMP协商过程中==第五包的核心处理函数的入口==，发起端通过此包收到相应端的KE值和Nonce值收到，可以生成需要的密钥信息。这里我们主要说明<code>main_inR2_outI3</code>的函数调用关系、处理流程以及对源码的注释分析，关于<code>main_inR2_outI3</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<p>ISAKMP协商报文的处理流程都比较复杂，此函数在协商的报文处理函数中比较复杂的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<p>对于源码的学习，我并没有把每一行进行备注，而是将自己认为的关键点做了注释或者标注。</p>
<span id="more"></span>

<hr>
<p>目前主要是整理源码中的处理里流程和实现逻辑，尚未深入比较细节的处理；后续在我整理完毕使用主模式协商的9个报文后，我再次结合代码整理每一个报文的详细流程，到时把每一个报文的注意事项、作用，处理方式做一个整体上的把握。同时结合书本上的描述来解释代码层的实现。</p>
<hr>
<h3 id="2-函数调用关系"><a href="#2-函数调用关系" class="headerlink" title="2.函数调用关系"></a>2.函数调用关系</h3><p>这里暂时给出xmind整理的思维导图。</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204817.png" alt="image-20200524090446620"></p>
<h3 id="3-第五个报文流程图"><a href="#3-第五个报文流程图" class="headerlink" title="3. 第五个报文流程图"></a>3. 第五个报文流程图</h3><p>第五个报文的处理流程主要分为三个大功能：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>解析收到的对端报文</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 密钥交换载荷KE</li>
<li><input checked="" disabled="" type="checkbox"> Nonce载荷</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>使用DH算法制作加密密钥、认证密钥、哈希密钥等</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>构造应答报文（第五个报文）</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 签名</li>
<li><input checked="" disabled="" type="checkbox"> 报文加密</li>
</ul>
</li>
</ul>
<img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%94%E5%8C%85%EF%BC%9Amain_inR2_outI3.assets%5Cimage-20200524091648492.png" alt="image-20200524091648492" style="zoom:200%;" />



<h3 id="4-main-inR2-outI3（）源码学习"><a href="#4-main-inR2-outI3（）源码学习" class="headerlink" title="4. main_inR2_outI3（）源码学习"></a>4. main_inR2_outI3（）源码学习</h3><p>该函数主要的功能是：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解析对端的KE载荷和Nonce，因为这是制作密钥的基础材料。</li>
<li><input checked="" disabled="" type="checkbox"> 解析完毕后，开始制作密钥。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span>;</span></span><br><span class="line">	<span class="comment">/*获取受到的第四个报文中的KE载荷*/</span></span><br><span class="line">    pb_stream *<span class="keyword">const</span> keyex_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_KE]-&gt;pbs;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;</span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE in */</span><span class="comment">/*解析KE载荷并存储在st-&gt;st_gr上*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_KE(&amp;st-&gt;st_gr, <span class="string">&quot;Gr&quot;</span></span><br><span class="line">				 , st-&gt;st_oakley.group, keyex_pbs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nr in */</span><span class="comment">/*解析Nonce载荷，并存储在st-&gt;st_nr*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_nr, <span class="string">&quot;Nr&quot;</span>));</span><br><span class="line"></span><br><span class="line">    dh = alloc_thing(struct dh_continuation, <span class="string">&quot;aggr outR1 DH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dh) &#123; <span class="keyword">return</span> STF_FATAL; &#125;</span><br><span class="line"></span><br><span class="line">    dh-&gt;md = md;</span><br><span class="line">    set_suspended(st, md);<span class="comment">/*挂起当前报文，防止由于耗时操作重新收到对方的重发报文*/</span></span><br><span class="line">    pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">    dh-&gt;dh_pcrc.pcrc_func = main_inR2_outI3_cryptotail;</span><br><span class="line">    <span class="keyword">return</span> start_dh_secretiv(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">			     , st-&gt;st_import</span><br><span class="line">			     , INITIATOR</span><br><span class="line">			     , st-&gt;st_oakley.group-&gt;group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-start-dh-secretiv（）源码学习"><a href="#5-start-dh-secretiv（）源码学习" class="headerlink" title="5. start_dh_secretiv（）源码学习"></a>5. start_dh_secretiv（）源码学习</h3><p>该函数的主要功能：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 获取协商的认证算法、哈希算法、oakley群信息</li>
<li><input checked="" disabled="" type="checkbox"> 准备Nonce、KE、cookie、st_sec_chunk（密钥信息?）</li>
<li><input checked="" disabled="" type="checkbox"> 制作密钥（该流程中会通过回调函数组装报文并发送）</li>
<li><input checked="" disabled="" type="checkbox"> 发送完毕报文的后续处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * invoke helper to do DH work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status <span class="title">start_dh_secretiv</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">			     , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">enum</span> crypto_importance importance</span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">enum</span> phase1_role init       <span class="comment">/* TRUE=g_init,FALSE=g_r */</span></span></span></span><br><span class="line"><span class="params"><span class="function">			     , <span class="keyword">u_int16_t</span> oakley_group2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcr_skeyid_q</span> *<span class="title">dhq</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">chunk_t</span> *pss = get_preshared_secret(st-&gt;st_connection);<span class="comment">/*获取预共享秘钥*/</span></span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"></span><br><span class="line">    pcr_init(&amp;r, pcr_compute_dh_iv, importance);<span class="comment">/*使用DH算法生成三把秘钥*/</span></span><br><span class="line"></span><br><span class="line">    dhq = &amp;r.pcr_d.dhq;</span><br><span class="line"></span><br><span class="line">    passert(st-&gt;st_sec_in_use);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert appropriate data to dhq */</span></span><br><span class="line">    dhq-&gt;auth = st-&gt;st_oakley.auth;</span><br><span class="line">    dhq-&gt;prf_hash = st-&gt;st_oakley.prf_hash;</span><br><span class="line">    dhq-&gt;oakley_group = oakley_group2;</span><br><span class="line">    dhq-&gt;init = init;</span><br><span class="line">    dhq-&gt;keysize = st-&gt;st_oakley.enckeylen/BITS_PER_BYTE;</span><br><span class="line"></span><br><span class="line">    passert(r.pcr_d.dhq.oakley_group != <span class="number">0</span>);</span><br><span class="line">    DBG(DBG_CONTROL | DBG_CRYPT,</span><br><span class="line">       DBG_log(<span class="string">&quot;parent1 type: %d group: %d len: %d\n&quot;</span>, r.pcr_type,</span><br><span class="line">	    r.pcr_d.dhq.oakley_group, (<span class="keyword">int</span>)r.pcr_len));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将*pss的内容拷贝到dhq-&gt;space中，起始位置是thespace；同时将dhq-&gt;pss指向spce对应的空间。然后更新thespace*/</span></span><br><span class="line">    <span class="keyword">if</span>(pss) &#123;</span><br><span class="line">	pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;pss, *pss);</span><br><span class="line">    &#125;</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;ni,  st-&gt;st_ni);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;nr,  st-&gt;st_nr);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;gi,  st-&gt;st_gi);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space, &amp;dhq-&gt;gr,  st-&gt;st_gr);</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space</span><br><span class="line">			   , &amp;dhq-&gt;secret, st-&gt;st_sec_chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最后发起端和相应者Nonce、KE等信息全部拷贝到了space中*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LIBNSS</span></span><br><span class="line">    <span class="comment">/*copying required encryption algo*/</span></span><br><span class="line">    <span class="comment">/*dhq-&gt;encrypt_algo = st-&gt;st_oakley.encrypt;*/</span></span><br><span class="line">    dhq-&gt;encrypter = st-&gt;st_oakley.encrypter;</span><br><span class="line">    DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;Copying DH pub key pointer to be sent to a thread helper&quot;</span>));</span><br><span class="line">    pluto_crypto_copychunk(&amp;dhq-&gt;thespace, dhq-&gt;space , &amp;dhq-&gt;pubk, st-&gt;pubk);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将发起者、相应者cookie也拷贝到dhq-&gt;space中*/</span></span><br><span class="line">    pluto_crypto_allocchunk(&amp;dhq-&gt;thespace, &amp;dhq-&gt;icookie, COOKIE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(wire_chunk_ptr(dhq, &amp;dhq-&gt;icookie), st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line">    pluto_crypto_allocchunk(&amp;dhq-&gt;thespace, &amp;dhq-&gt;rcookie, COOKIE_SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(wire_chunk_ptr(dhq, &amp;dhq-&gt;rcookie)</span><br><span class="line">	   , st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*至此，发起端和相应者Nonce、KE、cookie等信息全部拷贝到了space中*/</span></span><br><span class="line">    passert(dhq-&gt;oakley_group != <span class="number">0</span>);</span><br><span class="line">    e = send_crypto_helper_request(&amp;r, cn, &amp;toomuch);<span class="comment">/*r 中包含上述信息，用来生成三把秘钥*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;</span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-main-inR2-outI3-cryptotail（）源码学习"><a href="#6-main-inR2-outI3-cryptotail（）源码学习" class="headerlink" title="6. main_inR2_outI3_cryptotail（）源码学习"></a>6. main_inR2_outI3_cryptotail（）源码学习</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3_cryptotail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			   , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			   , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> (struct dh_continuation *)pcrc;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> dh-&gt;md;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">  stf_status e;</span><br><span class="line"></span><br><span class="line">  DBG(DBG_CONTROLMORE</span><br><span class="line">      , DBG_log(<span class="string">&quot;main inR2_outI3: calculated DH, sending R1&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: Request was disconnected from state&quot;</span>,</span><br><span class="line">	      __FUNCTION__);</span><br><span class="line">      <span class="keyword">if</span> (dh-&gt;md)</span><br><span class="line">          release_md(dh-&gt;md);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  passert(cur_state == <span class="literal">NULL</span>);</span><br><span class="line">  passert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  passert(st-&gt;st_suspended_md == dh-&gt;md);</span><br><span class="line">  set_suspended(st, <span class="literal">NULL</span>);	<span class="comment">/* no longer connected or suspended */</span></span><br><span class="line"></span><br><span class="line">  set_cur_state(st);</span><br><span class="line">  st-&gt;st_calculating = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ugh) &#123;</span><br><span class="line">      loglog(RC_LOG_SERIOUS, <span class="string">&quot;failed in DH exponentiation: %s&quot;</span>, ugh);</span><br><span class="line">      e = STF_FATAL;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      e = main_inR2_outI3_continue(md, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dh-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      complete_v1_state_transition(&amp;dh-&gt;md, e);</span><br><span class="line">      <span class="keyword">if</span>(dh-&gt;md) release_md(dh-&gt;md);</span><br><span class="line">  &#125;</span><br><span class="line">  reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-main-inR2-outI3-cryptotail（）源码学习"><a href="#7-main-inR2-outI3-cryptotail（）源码学习" class="headerlink" title="7. main_inR2_outI3_cryptotail（）源码学习"></a>7. main_inR2_outI3_cryptotail（）源码学习</h3><p>该函数的主要功能是：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 将制作的密钥存储在状态上</li>
<li><input checked="" disabled="" type="checkbox"> 解析对方报文中的证书，确定是否需要发送证书载荷</li>
<li><input checked="" disabled="" type="checkbox"> 构造ID标识载荷、并计算哈希</li>
<li><input checked="" disabled="" type="checkbox"> 如果使用哈希认证则填充哈希载荷；如果使用签名认证则进行数字签名</li>
<li><input checked="" disabled="" type="checkbox"> 报文加密</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* STATE_MAIN_I2:</span></span><br><span class="line"><span class="comment"> * SMF_PSK_AUTH: HDR, KE, Nr --&gt; HDR*, IDi1, HASH_I</span></span><br><span class="line"><span class="comment"> * SMF_DS_AUTH: HDR, KE, Nr --&gt; HDR*, IDi1, [ CERT, ] SIG_I</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following are not yet implemented.</span></span><br><span class="line"><span class="comment"> * SMF_PKE_AUTH: HDR, KE, &lt;IDr1_b&gt;PubKey_i, &lt;Nr_b&gt;PubKey_i</span></span><br><span class="line"><span class="comment"> *	    --&gt; HDR*, HASH_I</span></span><br><span class="line"><span class="comment"> * SMF_RPKE_AUTH: HDR, &lt;Nr_b&gt;PubKey_i, &lt;KE_b&gt;Ke_r, &lt;IDr1_b&gt;Ke_r</span></span><br><span class="line"><span class="comment"> *	    --&gt; HDR*, HASH_I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR2_outI3_continue</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="comment">/*选择认证的载荷类型:哈希\签名*/</span></span><br><span class="line">    <span class="keyword">int</span> auth_payload = st-&gt;st_oakley.auth == OAKLEY_PRESHARED_KEY</span><br><span class="line">	? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;</span><br><span class="line">    pb_stream id_pbs;	<span class="comment">/* ID Payload; also used for hash calculation */</span></span><br><span class="line">    <span class="keyword">bool</span> send_cert = FALSE;</span><br><span class="line">    <span class="keyword">bool</span> send_cr = FALSE;</span><br><span class="line">    generalName_t *requested_ca = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">cert_t</span> mycert = st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.cert;<span class="comment">/*获取自己的证书*/</span></span><br><span class="line"></span><br><span class="line">    finish_dh_secretiv(st, r);<span class="comment">/*将DH产生的三把秘钥存储在结构体上*/</span></span><br><span class="line">    <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decode certificate requests */</span></span><br><span class="line">    decode_cr(md, &amp;requested_ca);<span class="comment">/*解析报文中的证书载荷，并使用requested_ca链起来*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(requested_ca != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	st-&gt;hidden_variables.st_got_certrequest = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * send certificate if we have one and auth is RSA, and we were</span></span><br><span class="line"><span class="comment">     * told we can send one if asked, and we were asked, or we were told</span></span><br><span class="line"><span class="comment">     * to always send one.</span></span><br><span class="line"><span class="comment">     * 同时满足下面的条件再发送证书载荷:</span></span><br><span class="line"><span class="comment">     *		1. 使用RSA签名</span></span><br><span class="line"><span class="comment">     *		2. 本端导入了数字证书</span></span><br><span class="line"><span class="comment">     *		3. 配置要求发送证书或强制发送证书</span></span><br><span class="line"><span class="comment">     *		4. 从对端收到了证书</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    send_cert = st-&gt;st_oakley.auth == OAKLEY_RSA_SIG</span><br><span class="line">	&amp;&amp; mycert.type != CERT_NONE</span><br><span class="line">	&amp;&amp; ((st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert == cert_sendifasked</span><br><span class="line">	     &amp;&amp; st-&gt;hidden_variables.st_got_certrequest)</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_alwayssend</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_forcedtype);</span><br><span class="line"></span><br><span class="line">    doi_log_cert_thinking(md</span><br><span class="line">			  , st-&gt;st_oakley.auth</span><br><span class="line">			  , mycert.type</span><br><span class="line">			  , st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert</span><br><span class="line">			  , st-&gt;hidden_variables.st_got_certrequest</span><br><span class="line">			  , send_cert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send certificate request, if we don&#x27;t have a preloaded RSA public key */</span></span><br><span class="line">    send_cr = !no_cr_send &amp;&amp; send_cert &amp;&amp; !has_preloaded_public_key(st);<span class="comment">/*是否可以发送证书*/</span></span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROL</span><br><span class="line">	, DBG_log(<span class="string">&quot; I am %ssending a certificate request&quot;</span></span><br><span class="line">		  , send_cr ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;not &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * free collected certificate requests since as initiator</span></span><br><span class="line"><span class="comment">     * we don&#x27;t heed them anyway</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    free_generalNames(requested_ca, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* done parsing; initialize crypto  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">      nat_traversal_natd_lookup(md);<span class="comment">/*检测隧道两端是否经过NAT穿越*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal) &#123;</span><br><span class="line">      nat_traversal_show_result(st-&gt;hidden_variables.st_nat_traversal</span><br><span class="line">				, md-&gt;sender_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_KA) &#123;</span><br><span class="line">      nat_traversal_new_ka_event();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************** build output packet HDR*;IDii;HASH/SIG_I ***************/</span></span><br><span class="line">    <span class="comment">/* ??? <span class="doctag">NOTE:</span> this is almost the same as main_inI3_outR3&#x27;s code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out done */</span></span><br><span class="line">	<span class="comment">/*HDR在哪里完成填充的呢???*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* IDii out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id_hd</span>;</span></span><br><span class="line">	<span class="keyword">chunk_t</span> id_b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从状态/连接上获取本端标识信息*/</span></span><br><span class="line">	build_id_payload(&amp;id_hd, &amp;id_b, &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>);</span><br><span class="line">	id_hd.isaiid_np = (send_cert)? ISAKMP_NEXT_CERT : auth_payload;</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;id_hd</span><br><span class="line">			, &amp;isakmp_ipsec_identification_desc</span><br><span class="line">			, &amp;md-&gt;rbody</span><br><span class="line">			, &amp;id_pbs)</span><br><span class="line">	    || !out_chunk(id_b, &amp;id_pbs, <span class="string">&quot;my identity&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CERT out */</span></span><br><span class="line">    <span class="keyword">if</span> (send_cert)</span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream cert_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_cert</span> <span class="title">cert_hd</span>;</span></span><br><span class="line">	cert_hd.isacert_np = (send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_SIG;</span><br><span class="line">	cert_hd.isacert_type = mycert.type;</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending my cert&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;cert_hd</span><br><span class="line">			, &amp;isakmp_ipsec_certificate_desc</span><br><span class="line">			, &amp;md-&gt;rbody</span><br><span class="line">			, &amp;cert_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mycert.forced) &#123;</span><br><span class="line">	  <span class="keyword">if</span> (!out_chunk(mycert.u.blob, &amp;cert_pbs, <span class="string">&quot;forced CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="keyword">if</span> (!out_chunk(get_mycert(mycert), &amp;cert_pbs, <span class="string">&quot;CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	close_output_pbs(&amp;cert_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CR out */</span><span class="comment">/*添加证书请求载荷,即要求对对端进行发送证书以求认证...*/</span></span><br><span class="line">    <span class="keyword">if</span> (send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending a certificate request&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!build_and_ship_CR(mycert.type</span><br><span class="line">			       , st-&gt;st_connection-&gt;spd.that.ca</span><br><span class="line">			       , &amp;md-&gt;rbody, ISAKMP_NEXT_SIG))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;md-&gt;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find location of ID PBS */</span></span><br><span class="line">	tpm_findID(pbs, &amp;id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH_I or SIG_I out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char hash_val[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="keyword">size_t</span> hash_len = main_mode_hash(st, hash_val, TRUE, &amp;id_pbs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (auth_payload == ISAKMP_NEXT_HASH)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* HASH_I out */</span></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(ISAKMP_NEXT_NONE</span><br><span class="line">				 , &amp;isakmp_hash_desc</span><br><span class="line">				 , &amp;md-&gt;rbody</span><br><span class="line">				 , hash_val, hash_len, <span class="string">&quot;HASH_I&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* SIG_I out */</span></span><br><span class="line">	    u_char sig_val[RSA_MAX_OCTETS];</span><br><span class="line">	    <span class="keyword">size_t</span> sig_len = RSA_sign_hash(st-&gt;st_connection</span><br><span class="line">		, sig_val, hash_val, hash_len);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (sig_len == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;unable to locate my private key for RSA Signature&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + AUTHENTICATION_FAILED;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(ISAKMP_NEXT_NONE</span><br><span class="line">				 , &amp;isakmp_signature_desc</span><br><span class="line">				 , &amp;md-&gt;rbody</span><br><span class="line">				 , sig_val</span><br><span class="line">				 , sig_len</span><br><span class="line">				 , <span class="string">&quot;SIG_I&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* st_new_iv was computed by generate_skeyids_iv */</span></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第六包(收包)：main_inR3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%85%AD%E5%8C%85(%E6%94%B6%E5%8C%85)%EF%BC%9Amain_inR3/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p><code>main_inR3()</code>函数是ISAKMP协商过程中==第一阶段的最后一个报文的接收处理函数==，它的作用同<code>main_inI3_outR3()</code>部分功能相同：完成对对端身份的认证。他们的不同之处在于不在需要响应报文（如果不考虑第二阶段的话）。此包处理完毕后，发起端便成功建立了ISAKMP SA, 完成了第一阶段主模式的协商。后续便是第二阶段的协商。这里我们主要说明<code>main_inR3</code>的函数调用关系、处理流程以及对源码的注释分析，关于<code>main_inR3</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，此函数在协商的报文处理函数中比较复杂的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<hr>
<p>目前主要是整理源码中的处理里流程和实现逻辑，尚未深入比较细节的处理；后续在我整理完毕使用主模式协商的9个报文后，我再次结合代码整理每一个报文的详细流程，到时把每一个报文的注意事项、作用，处理方式做一个整体上的把握。同时结合书本上的描述来解释代码层的实现。</p>
<hr>
<p>ISAKMP主模式协商流程如下：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204950.png" alt="image-20200606195135324"></p>
<p>本文要说明的便是第⑥包的接收函数：<code>main_inR3()</code>;</p>
<h3 id="2-函数调用关系"><a href="#2-函数调用关系" class="headerlink" title="2. 函数调用关系"></a>2. 函数调用关系</h3><p><code>main_inR3()</code>函数的调用层次少了很多（如果不考虑加解密、证书认证的话），它的调用关系图如下所示</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204953.png" alt="image-20200606195717889"></p>
<h3 id="3-第⑥个报文接收流程图"><a href="#3-第⑥个报文接收流程图" class="headerlink" title="3. 第⑥个报文接收流程图"></a>3. 第⑥个报文接收流程图</h3><p><strong>第⑥个报文的接收流程<code>main_inR3</code>的功能可以分为三类</strong>(如果把建立ISAKMP SA也看作一类的话)：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>解析对方的身份标识(ID)和证书载荷，匹配对方的身份标识</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>身份验证</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 预共享秘钥</li>
<li><input checked="" disabled="" type="checkbox"> 数字证书</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>建立ISAKMP SA</strong></li>
</ul>
<p>流程图下图：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204955.png" alt="image-20200606185131522"></p>
<h3 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h3><p>由于<code>main_R3()</code>的处理流程和<code>main_inI3_outR3()</code>中的部分处理流程调用了相同的函数接口，因此无需再进行说明，如果有疑问可以查看<code>main_inI3_outR3()</code>的中的源码部分。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>openswan的源码确实难度很高，虽然用了很长的时间来看主模式的6个报文7个主要的函数接口，前后花费了一个月时间吧（之前陆陆续续看过部分接口），但是学习的时候比较浅，没有深层次的理解。最主要包括以下几个方面：</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  报文的加解密</p>
<p>报文加密、解密是在第⑤⑥个报文中才有的，关于这部分的功能（加密、哈希、数字证书签名验签、预共享密钥等），只知道它是在做这种处理，基本没有深入去分析代码。这个主要是由于看不懂，内心里有种抵触心理；其次是不想直接深入学习这部分，先学习整体处理框架，然后再慢慢深入学习这部分功能。即“<strong>先广度优先搜索，再深度优先搜索</strong>”</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  算法相关的操作</p>
<p>这里的算法相关，我是想表达对于策略的配置解析存储算法、如何与报文中的载荷相对应、支持的算法类型、协商时处理对方建议载荷的原则等等问题。这部分有的可能已经在协商流程中有所涉及，但是关于算法的存储等是在这部分之前的流程中处理的(<code>whack_handle()</code>)，因此没有过多学习。后面再补充whack命令相关的知识。</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  连接和状态之间的联系</p>
<p>主要的疑惑是不清楚他们成员之间的关系，可能是特别大，同时关系有比较复杂的缘故。状态是一个动态的概念，即协商过程中的参数；连接是我们的隧道配置信息，基本是个固定的结构。他们是如何维护、以及协商过程中如何联系起来，这部分没有系统整理和分析过。举个简单的例子：<strong>NAT-T在ISAKMP中是如何完成协商的？</strong> 这个我之前处理过一个bug,因此可能分析过协商过程中的联系，但是其他的我就不得而知了。</p>
</li>
</ul>
<p><strong>任重而道远，继续努力吧。</strong></p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第一包：main_outI1()</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Amain_outI1()/</url>
    <content><![CDATA[<h2 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h2><p><code>main_outI1()</code>作为主模式主动发起连接请求的核心处理函数，我们可以通过学习该函数的处理流程来探究openswan中报文封装的基本思想。如果之前没有学习基本的函数接口(如in_struct, out_struct, out_sa等)，那么直接学习<code>main_outI1()</code>流程是比较困难的。如果想快速学习这几个函数接口，可以查看我先前的文章，我把需要的基本知识、思想等做了基本介绍，看完那几个接口再来学习此后的ISAKMP协商流程会容易很多，起到事半功倍的效果。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，一个函数有几百行都是很常见的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<h2 id="2-main-outI1-流程图"><a href="#2-main-outI1-流程图" class="headerlink" title="2. main_outI1()流程图"></a>2. main_outI1()流程图</h2><p>下面两个流程图中主要描述了三个函数的处理流程，后面我会分别附上这三个函数的源码信息。</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204802.png" alt="main_outI1"></p>
<p><img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Amain_outI1().assets%5Cimage-20200520000233483.png" alt="out_sa处理流程"></p>
<h2 id="3-main-outI1-源码注释"><a href="#3-main-outI1-源码注释" class="headerlink" title="3. main_outI1()源码注释"></a>3. main_outI1()源码注释</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_outI1</span><span class="params">(<span class="keyword">int</span> whack_sock</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct connection *c</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct state *predecessor</span></span></span><br><span class="line"><span class="params"><span class="function">           , <span class="keyword">so_serial_t</span>  *newstateno</span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">lset_t</span> policy</span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">try</span></span></span></span><br><span class="line"><span class="params"><span class="function">	   , <span class="keyword">enum</span> crypto_importance importance</span></span></span><br><span class="line"><span class="params"><span class="function">	   , struct xfrm_user_sec_ctx_ike * uctx</span></span></span><br><span class="line"><span class="params"><span class="function">	   )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> new_state();<span class="comment">/*创建一个新的状态*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> <span class="title">md</span>;</span>   <span class="comment">/* use reply/rbody found inside */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numvidtosend = <span class="number">1</span>;  <span class="comment">/* we always send DPD VID */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled) &#123;</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SEND_PLUTO_VID || defined(openpgp_peer)</span></span><br><span class="line">    numvidtosend++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_client || c-&gt;spd.<span class="keyword">this</span>.xauth_server) &#123;</span><br><span class="line">	numvidtosend++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*统计VID个数*/</span></span><br><span class="line">    <span class="comment">/* set up new state */</span><span class="comment">/*根据对端IP地址信息生成一个新的cookie*/</span></span><br><span class="line">    get_cookie(TRUE, st-&gt;st_icookie, COOKIE_SIZE, &amp;c-&gt;spd.that.host_addr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*初始化新的state结构*/</span></span><br><span class="line">    initialize_new_state(st, c, policy, <span class="keyword">try</span>, whack_sock, importance);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(newstateno) *newstateno = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKE version numbers -- used mostly in logging */</span></span><br><span class="line">    st-&gt;st_ike_maj        = IKEv1_MAJOR_VERSION;</span><br><span class="line">    st-&gt;st_ike_min        = IKEv1_MINOR_VERSION;</span><br><span class="line"></span><br><span class="line">    change_state(st, STATE_MAIN_I1);<span class="comment">/*设置当前的状态为STATE_MAIN_I1*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAS_IPSEC_POLICY(policy))</span><br><span class="line">	add_pending(dup_any(whack_sock), st, c, policy, <span class="number">1</span></span><br><span class="line">	    , predecessor == <span class="literal">NULL</span>? SOS_NOBODY : predecessor-&gt;st_serialno</span><br><span class="line">	    , uctx</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">    <span class="comment">/*For main modes states, sec ctx is always null*/</span></span><br><span class="line">    st-&gt;sec_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predecessor == <span class="literal">NULL</span>)</span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Main Mode&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Main Mode to replace #%lu&quot;</span>, predecessor-&gt;st_serialno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set up reply */</span></span><br><span class="line">    zero(reply_buffer);<span class="comment">/*初始化应答报文(发送的报文)的结构*/</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out */</span></span><br><span class="line">    &#123;<span class="comment">/*添加isakmp头部信息*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	zero(&amp;hdr);	<span class="comment">/* default to 0 */</span></span><br><span class="line">	hdr.isa_version = ISAKMP_MAJOR_VERSION &lt;&lt; ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION;</span><br><span class="line">	hdr.isa_np = ISAKMP_NEXT_SA;</span><br><span class="line">	hdr.isa_xchg = ISAKMP_XCHG_IDPROT;</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_icookie, st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line">	<span class="comment">/* R-cookie, flags and MessageID are left zero */</span></span><br><span class="line">	<span class="comment">/*长度字段最后设置: close_output_pbs(&amp;reply_stream);*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;md.rbody))</span><br><span class="line">	&#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA out */</span></span><br><span class="line">    &#123;<span class="comment">/************封装SA载荷**************/</span></span><br><span class="line">	u_char *sa_start = md.rbody.cur;</span><br><span class="line">	<span class="keyword">int</span>    policy_index = POLICY_ISAKMP(policy</span><br><span class="line">					    , c-&gt;spd.<span class="keyword">this</span>.xauth_server</span><br><span class="line">					    , c-&gt;spd.<span class="keyword">this</span>.xauth_client);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we  have an OpenPGP certificate we assume an</span></span><br><span class="line"><span class="comment">	 * OpenPGP peer and have to send the Vendor ID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*如果存在VID，则需要设置下一载荷的值*/</span></span><br><span class="line">	<span class="keyword">int</span> np = numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span> (!out_sa(&amp;md.rbody</span><br><span class="line">		    , &amp;oakley_sadb[policy_index], st, TRUE, FALSE, np))</span><br><span class="line">	&#123;</span><br><span class="line">	    openswan_log(<span class="string">&quot;outsa fail&quot;</span>);</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* save initiator SA for later HASH */</span></span><br><span class="line">	passert(st-&gt;st_p1isa.ptr == <span class="literal">NULL</span>);	<span class="comment">/* no leak!  (MUST be first time) */</span></span><br><span class="line">	clonetochunk(st-&gt;st_p1isa, sa_start, md.rbody.cur - sa_start</span><br><span class="line">	    , <span class="string">&quot;sa in main_outI1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SEND_PLUTO_VID || c-&gt;spd.<span class="keyword">this</span>.cert.type == CERT_PGP)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> *vendorid = (c-&gt;spd.<span class="keyword">this</span>.cert.type == CERT_PGP) ?</span><br><span class="line">	    pgp_vendorid : pluto_vendorid;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_vendor_id_desc, &amp;md.rbody</span><br><span class="line">			     , vendorid, <span class="built_in">strlen</span>(vendorid), <span class="string">&quot;Vendor ID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send DPD VID */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(np, &amp;md.rbody, VID_MISC_DPD)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;nat traversal enabled: %d&quot;</span></span><br><span class="line">			  , nat_traversal_enabled));</span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled) &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add supported NAT-Traversal VID */</span></span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_insert_vid(np, &amp;md.rbody, st)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XAUTH</span></span><br><span class="line">    <span class="keyword">if</span>(c-&gt;spd.<span class="keyword">this</span>.xauth_client || c-&gt;spd.<span class="keyword">this</span>.xauth_server) &#123;</span><br><span class="line">	<span class="keyword">int</span> np = --numvidtosend &gt; <span class="number">0</span> ? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(np, &amp;md.rbody, VID_MISC_XAUTH)) &#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* if we are not 0 then something went very wrong above */</span></span><br><span class="line">    <span class="keyword">if</span>(numvidtosend != <span class="number">0</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;payload alignment problem please check the code in main_inR1_outR2 (num=%d)&quot;</span>, numvidtosend);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    close_message(&amp;md.rbody);</span><br><span class="line">    close_output_pbs(&amp;reply_stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let TCL hack it before we mark the length and copy it */</span></span><br><span class="line">    TCLCALLOUT(<span class="string">&quot;avoidEmitting&quot;</span>, st, st-&gt;st_connection, &amp;md);</span><br><span class="line">    clonetochunk(st-&gt;st_tpacket, reply_stream.start, pbs_offset(&amp;reply_stream)</span><br><span class="line">	, <span class="string">&quot;reply packet for main_outI1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transmit */</span></span><br><span class="line">    send_packet(st, <span class="string">&quot;main_outI1&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a retransmission event, half a minute henceforth */</span></span><br><span class="line">    TCLCALLOUT(<span class="string">&quot;adjustTimers&quot;</span>, st, st-&gt;st_connection, &amp;md);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line"> tpm_stolen:</span><br><span class="line"> tpm_ignore:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    delete_event(st);</span><br><span class="line">    event_schedule(EVENT_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predecessor != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	update_pending(predecessor, st);</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_MAIN_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate, replacing #%lu&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state)</span><br><span class="line">	    , predecessor-&gt;st_serialno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_MAIN_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate&quot;</span>, enum_name(&amp;state_names, st-&gt;st_state));</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-out-sa-源码注释"><a href="#4-out-sa-源码注释" class="headerlink" title="4. out_sa()源码注释"></a>4. out_sa()源码注释</h2><p>略。此函数400多行，由于流程图上比较详细就不再列出。</p>
<h3 id="5-oakley-alg-makedb-源码注释"><a href="#5-oakley-alg-makedb-源码注释" class="headerlink" title="5. oakley_alg_makedb()源码注释"></a>5. oakley_alg_makedb()源码注释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	Create an OAKLEY proposal based on alg_info and policy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: maxtrans is an enum, not a count</span></span><br><span class="line"><span class="comment"> * 	Should probably be declared an enum at some point.</span></span><br><span class="line"><span class="comment"> * 	-1 - ???</span></span><br><span class="line"><span class="comment"> * 	 0 - No limit</span></span><br><span class="line"><span class="comment"> * 	 1 - One proposal - period</span></span><br><span class="line"><span class="comment"> * 	 2 - One DH group, take first DH group and ignore any that don&#x27;t match</span></span><br><span class="line"><span class="comment"> *根据配置的秘钥算法信息重新生成一个sadb信息</span></span><br><span class="line"><span class="comment"> *传入的sadb应该为固定的秘钥算法信息，因此需要根据策略来重新生成一个新的sadb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct db_sa *</span></span><br><span class="line"><span class="function"><span class="title">oakley_alg_makedb</span><span class="params">(struct alg_info_ike *ai</span></span></span><br><span class="line"><span class="params"><span class="function">		  , struct db_sa *base</span></span></span><br><span class="line"><span class="params"><span class="function">		  , <span class="keyword">int</span> maxtrans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* struct db_context inprog UNUSED; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">gsp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">emp_sp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ike_info</span> *<span class="title">ike_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ealg, halg, modp, eklen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Next two are for multiple proposals in agressive mode... */</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_modp=<span class="number">0</span>, wrong_modp=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">encrypt_desc</span> *<span class="title">enc_desc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> transcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * start by copying the proposal that would have been picked by</span></span><br><span class="line"><span class="comment">     * standard defaults.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ai) &#123;</span><br><span class="line">	DBG(DBG_CRYPT,DBG_log(<span class="string">&quot;no IKE algorithms for this connection &quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gsp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for each group, we will create a new proposal item, and then</span></span><br><span class="line"><span class="comment">     * append it to the list of transforms in the conjoint point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * when creating each item, we will use the first transform</span></span><br><span class="line"><span class="comment">     * from the base item as the template.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALG_INFO_IKE_FOREACH(ai, ike_info, i) &#123;<span class="comment">//遍历策略中的算法信息</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ike_info-&gt;ike_default == FALSE) &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_attr</span>  *<span class="title">enc</span>, *<span class="title">hash</span>, *<span class="title">auth</span>, *<span class="title">grp</span>, *<span class="title">enc_keylen</span>, *<span class="title">new_auth</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_prop</span>  *<span class="title">prop</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">db_prop_conj</span> *<span class="title">cprop</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*获取到加密算法、哈希算法、认证算法、加密秘钥长度等信息*/</span></span><br><span class="line">	    ealg = ike_info-&gt;ike_ealg;</span><br><span class="line">	    halg = ike_info-&gt;ike_halg;</span><br><span class="line">	    modp = ike_info-&gt;ike_modp;</span><br><span class="line">	    eklen= ike_info-&gt;ike_eklen;</span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">/*判断这几个算法是否合法、是否存在等*/</span></span></span><br><span class="line">	    <span class="keyword">if</span> (!ike_alg_enc_present(ealg)) &#123;</span><br><span class="line">		DBG_log(<span class="string">&quot;oakley_alg_makedb() &quot;</span></span><br><span class="line">			<span class="string">&quot;ike enc ealg=%d not present&quot;</span>,</span><br><span class="line">			ealg);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (!ike_alg_hash_present(halg)) &#123;</span><br><span class="line">		DBG_log(<span class="string">&quot;oakley_alg_makedb() &quot;</span></span><br><span class="line">			<span class="string">&quot;ike hash halg=%d not present&quot;</span>,</span><br><span class="line">			halg);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    enc_desc = ike_alg_get_encrypter(ealg);</span><br><span class="line"></span><br><span class="line">	    passert(enc_desc != <span class="literal">NULL</span>);</span><br><span class="line">	    <span class="keyword">if</span> (eklen	<span class="comment">/*秘钥长度是否符合要求*/</span></span><br><span class="line">		&amp;&amp; (eklen &lt; enc_desc-&gt;keyminlen</span><br><span class="line">		    || eklen &gt;  enc_desc-&gt;keymaxlen))</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">		    DBG_log(<span class="string">&quot;ike_alg_db_new() &quot;</span></span><br><span class="line">			    <span class="string">&quot;ealg=%d (specified) keylen:%d, &quot;</span></span><br><span class="line">			    <span class="string">&quot;not valid &quot;</span></span><br><span class="line">			    <span class="string">&quot;min=%d, max=%d&quot;</span></span><br><span class="line">			    , ealg</span><br><span class="line">			    , eklen</span><br><span class="line">			    , enc_desc-&gt;keyminlen</span><br><span class="line">			    , enc_desc-&gt;keymaxlen</span><br><span class="line">			    );</span><br><span class="line">		    <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    <span class="comment">/* okay copy the basic item, and modify it. */</span></span><br><span class="line">	    <span class="keyword">if</span>(eklen &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		emp_sp = sa_copy_sa(&amp;oakley_empty, <span class="number">0</span>);<span class="comment">/*重新分配一个新的描述信息*/</span></span><br><span class="line">		cprop = &amp;base-&gt;prop_conjs[<span class="number">0</span>];<span class="comment">/*从定义的描述信息中获取参数*/</span></span><br><span class="line">		prop = &amp;cprop-&gt;props[<span class="number">0</span>];<span class="comment">/*建议载荷*/</span></span><br><span class="line">		trans = &amp;prop-&gt;trans[<span class="number">0</span>];<span class="comment">/*变换载荷*/</span></span><br><span class="line">		new_auth = &amp;trans-&gt;attrs[<span class="number">2</span>];<span class="comment">/*属性载荷*/</span></span><br><span class="line"></span><br><span class="line">		cprop = &amp;emp_sp-&gt;prop_conjs[<span class="number">0</span>];</span><br><span class="line">		prop = &amp;cprop-&gt;props[<span class="number">0</span>];</span><br><span class="line">		trans = &amp;prop-&gt;trans[<span class="number">0</span>];</span><br><span class="line">		auth = &amp;trans-&gt;attrs[<span class="number">2</span>];</span><br><span class="line">		*auth = *new_auth;		<span class="comment">/*给新的描述结构中设置认证算法*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		emp_sp = sa_copy_sa_first(base);</span><br><span class="line"></span><br><span class="line">	    passert(emp_sp-&gt;prop_conj_cnt == <span class="number">1</span>);</span><br><span class="line">	    cprop = &amp;emp_sp-&gt;prop_conjs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(cprop-&gt;prop_cnt == <span class="number">1</span>);</span><br><span class="line">	    prop = &amp;cprop-&gt;props[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(prop-&gt;trans_cnt == <span class="number">1</span>);</span><br><span class="line">	    trans = &amp;prop-&gt;trans[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	    passert(trans-&gt;attr_cnt == <span class="number">4</span> || trans-&gt;attr_cnt == <span class="number">5</span>);</span><br><span class="line">	    enc  = &amp;trans-&gt;attrs[<span class="number">0</span>]; <span class="comment">/*加密*/</span></span><br><span class="line">	    hash = &amp;trans-&gt;attrs[<span class="number">1</span>];<span class="comment">/*哈希*/</span></span><br><span class="line">	    auth = &amp;trans-&gt;attrs[<span class="number">2</span>];<span class="comment">/*认证*/</span></span><br><span class="line">	    grp  = &amp;trans-&gt;attrs[<span class="number">3</span>];<span class="comment">/*DH组?*/</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(eklen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		enc_keylen = &amp;trans-&gt;attrs[<span class="number">4</span>];</span><br><span class="line">		enc_keylen-&gt;val = eklen;<span class="comment">/*设置加密算法长度*/</span></span><br><span class="line">	    &#125; <span class="keyword">else</span></span><br><span class="line">		trans-&gt;attr_cnt = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	    passert(enc-&gt;type.oakley == OAKLEY_ENCRYPTION_ALGORITHM);</span><br><span class="line">	    <span class="keyword">if</span>(ealg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		enc-&gt;val = ealg;<span class="comment">/*设置加密算法*/</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    modp = ike_info-&gt;ike_modp;</span><br><span class="line">	    eklen= ike_info-&gt;ike_eklen;</span><br><span class="line"></span><br><span class="line">	    passert(hash-&gt;type.oakley == OAKLEY_HASH_ALGORITHM);</span><br><span class="line">	    <span class="keyword">if</span>(halg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		hash-&gt;val = halg;<span class="comment">/*设置哈希算法*/</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    passert(auth-&gt;type.oakley == OAKLEY_AUTHENTICATION_METHOD);</span><br><span class="line">	    <span class="comment">/* no setting for auth type for IKE */</span></span><br><span class="line"></span><br><span class="line">	    passert(grp-&gt;type.oakley  == OAKLEY_GROUP_DESCRIPTION);</span><br><span class="line">	    <span class="keyword">if</span>(modp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		grp-&gt;val = modp;  <span class="comment">/*设置认证算法*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    emp_sp = sa_copy_sa(base, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxtrans == <span class="number">1</span>) &#123;<span class="comment">/*最大变换载荷数*/</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  We&#x27;re going to leave maxtrans == 1 alone in case there</span></span><br><span class="line"><span class="comment">             * really really is a case where we only want 1.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(transcnt == <span class="number">0</span>) &#123;</span><br><span class="line">		DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;using transform (%d,%d,%d,%ld)&quot;</span></span><br><span class="line">					 , ike_info-&gt;ike_ealg</span><br><span class="line">					 , ike_info-&gt;ike_halg</span><br><span class="line">					 , ike_info-&gt;ike_modp</span><br><span class="line">					 , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen));</span><br><span class="line">		<span class="keyword">if</span>(gsp) &#123;</span><br><span class="line">		    free_sa(gsp);</span><br><span class="line">		&#125;</span><br><span class="line">		gsp = emp_sp;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(transcnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(transcnt == <span class="number">1</span>) &#123;</span><br><span class="line">		    loglog(RC_LOG_SERIOUS</span><br><span class="line"></span><br><span class="line">			   , <span class="string">&quot;multiple transforms were set in aggressive mode. Only first one used.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		loglog(RC_LOG_SERIOUS</span><br><span class="line">		       , <span class="string">&quot;transform (%d,%d,%d,%ld) ignored.&quot;</span></span><br><span class="line">		       , ike_info-&gt;ike_ealg</span><br><span class="line">		       , ike_info-&gt;ike_halg</span><br><span class="line">		       , ike_info-&gt;ike_modp</span><br><span class="line">		       , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Now...  We&#x27;re allowing multiple proposals...  Are we allowing</span></span><br><span class="line"><span class="comment">             * multiple DH groups?</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">	    struct db_sa *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxtrans == <span class="number">2</span> &amp;&amp; transcnt &gt; <span class="number">0</span> &amp;&amp; ike_info-&gt;ike_modp != last_modp ) &#123;</span><br><span class="line">                <span class="comment">/* Not good.</span></span><br><span class="line"><span class="comment">                 * Already got a DH group and this one doesn&#x27;t match */</span></span><br><span class="line">		<span class="keyword">if</span>(wrong_modp == <span class="number">0</span>) &#123;</span><br><span class="line">		    loglog(RC_LOG_SERIOUS</span><br><span class="line">			   , <span class="string">&quot;multiple DH groups were set in aggressive mode. Only first one used.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		loglog(RC_LOG_SERIOUS</span><br><span class="line">		           , <span class="string">&quot;transform (%d,%d,%d,%ld) ignored.&quot;</span></span><br><span class="line">		           , ike_info-&gt;ike_ealg</span><br><span class="line">		           , ike_info-&gt;ike_halg</span><br><span class="line">		           , ike_info-&gt;ike_modp</span><br><span class="line">		           , (<span class="keyword">long</span>)ike_info-&gt;ike_eklen);</span><br><span class="line"></span><br><span class="line">                wrong_modp++;</span><br><span class="line"></span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(gsp) &#123;</span><br><span class="line">	    <span class="comment">/* now merge emp_sa and gsp */</span></span><br><span class="line">		<span class="keyword">new</span> = sa_merge_proposals(gsp, emp_sp);<span class="comment">/*变换载荷合并*/</span></span><br><span class="line">		free_sa(gsp);</span><br><span class="line">		free_sa(emp_sp);</span><br><span class="line">		emp_sp = <span class="literal">NULL</span>;</span><br><span class="line">		gsp = <span class="keyword">new</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		gsp = emp_sp;</span><br><span class="line">	    &#125;</span><br><span class="line">            last_modp = ike_info-&gt;ike_modp;</span><br><span class="line">	&#125;</span><br><span class="line">	transcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    gsp-&gt;parentSA = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第三包：main_inR1_outI2</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85%EF%BC%9Amain_inR1_outI2/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p><code>main_inR1_outI2()</code>函数是ISAKMP协商过程中==第三包的核心处理函数的入口==。这里我们主要说明<code>main_inR1_outI2</code>的函数调用关系、处理流程以及对源码的注释分析，关于<code>main_inR1_outI2</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，一个函数有几百行都是很常见的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<p>对于源码的学习，我并没有把每一行进行备注，而是将自己认为的关键点做了注释或者标注。</p>
<hr>
<h3 id="2-函数调用关系"><a href="#2-函数调用关系" class="headerlink" title="2. 函数调用关系"></a>2. 函数调用关系</h3><blockquote>
<p>注意：这里我把收到对方报文后的处理流程也添加上了，主要是在学习源码过程中遇到<code>complete_v1_state_transition</code>执行了两次。第二次会检测第一次的返回值，因此不会重复的发送报文更新状态。</p>
</blockquote>
<ul>
<li>process_v1_packet<ul>
<li>process_packet_tail<ul>
<li>smc-&gt;processor(md)<ul>
<li>main_inR1_outI2<ul>
<li>build_ke<ul>
<li>send_crypto_helper_request<ul>
<li>pluto_do_crypto_op</li>
<li>main_inR1_outI2_continue<ul>
<li>main_inR1_outI2_tail<ul>
<li>init_pbs</li>
<li>ship_KE</li>
<li>ship_nonce</li>
<li>nat_traversal_add_natd</li>
<li>close_message</li>
<li>insert_state</li>
</ul>
</li>
<li>complete_v1_state_transition</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>complete_v1_state_transition</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204847.png" alt="image-20200521075841786"></p>
<h3 id="3-第三个报文流程图"><a href="#3-第三个报文流程图" class="headerlink" title="3. 第三个报文流程图"></a>3. 第三个报文流程图</h3><p>由于第三个报文的核心处理函数包含多个，不仅仅包含<code>main_inR1_outI2</code>, 因此这里会将涉及的关键函数接口都添加到流程图中，方便根据函数定位对应的功能。</p>
<hr>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>解析对端发送的SA载荷，确定对端选择的算法，并将其存储在状态/连接上</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>生成秘钥交换材料和Nonce信息</strong></li>
<li><input checked="" disabled="" type="checkbox"> ==构造应答报文(第四个报文）==<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>填充KE载荷和Nonce载荷</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204851.png" alt="image-20200520231919967"></p>
<h3 id="4-main-inR1-outI2源码注释"><a href="#4-main-inR1-outI2源码注释" class="headerlink" title="4. main_inR1_outI2源码注释"></a>4. main_inR1_outI2源码注释</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 解析收到的第二个报文，确定对端选择的算法，并将算法存储在状态结构上</li>
<li><input checked="" disabled="" type="checkbox"> 申请生成交换密钥信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* verify echoed SA */</span></span><br><span class="line">    &#123;<span class="comment">/*md-&gt;chain为解析完毕的收到的报文,下标为np的值*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sapd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*解析对端SA, 由于无需填充应答SA因此第三个参数为NULL*/</span></span><br><span class="line">	RETURN_STF_FAILURE(parse_isakmp_sa_body(&amp;sapd-&gt;pbs</span><br><span class="line">						, &amp;sapd-&gt;payload.sa</span><br><span class="line">						, <span class="literal">NULL</span>, TRUE, st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;sender checking NAT-T: %d and %d&quot;</span></span><br><span class="line">				 , nat_traversal_enabled</span><br><span class="line">				 , md-&gt;quirks.nat_traversal_vid))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nat_traversal_enabled &amp;&amp; md-&gt;quirks.nat_traversal_vid) &#123;<span class="comment">/*获取NAT-T采用的标准*/</span></span><br><span class="line">	st-&gt;hidden_variables.st_nat_traversal = nat_traversal_vid_to_method(md-&gt;quirks.nat_traversal_vid);</span><br><span class="line">	openswan_log(<span class="string">&quot;enabling possible NAT-traversal with method %s&quot;</span></span><br><span class="line">	     , bitnamesof(natt_type_bitnames, st-&gt;hidden_variables.st_nat_traversal));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">/*密钥交换*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> alloc_thing(struct ke_continuation</span><br><span class="line">						 , <span class="string">&quot;outI2 KE&quot;</span>);</span><br><span class="line">	ke-&gt;md = md;</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_sec_in_use==FALSE);<span class="comment">/*是否已经加密,是的话，状态有误，返回退出*/</span></span><br><span class="line">	pcrc_init(&amp;ke-&gt;ke_pcrc);</span><br><span class="line">	ke-&gt;ke_pcrc.pcrc_func = main_inR1_outI2_continue;</span><br><span class="line">	set_suspended(st, md);</span><br><span class="line">        <span class="comment">/*构建秘钥交换载荷信息*/</span></span><br><span class="line">	<span class="keyword">return</span> build_ke(&amp;ke-&gt;ke_pcrc, st, st-&gt;st_oakley.group, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-build-ke源码注释"><a href="#5-build-ke源码注释" class="headerlink" title="5. build_ke源码注释"></a>5. build_ke源码注释</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 初始化并发送加密请求<ul>
<li><input disabled="" type="checkbox"> 生成加密材料、Nonce载荷、构建应答报文在<code>send_crypto_helper_request</code>及其以后。</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 完成报文发送后的后续操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status <span class="title">build_ke</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">		    , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">const</span> struct oakley_group_desc *group</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">enum</span> crypto_importance importance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">rd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> *<span class="title">r</span> =</span> &amp;rd;</span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"><span class="comment">/*初始化加密请求*/</span></span><br><span class="line">    pcr_init(r, pcr_build_kenonce, importance);</span><br><span class="line">    r-&gt;pcr_d.kn.oakley_group   = group-&gt;group;</span><br><span class="line"></span><br><span class="line">    cn-&gt;pcrc_serialno = st-&gt;st_serialno;</span><br><span class="line">	<span class="comment">/*发送加密请求*/</span></span><br><span class="line">    e= send_crypto_helper_request(r, cn, &amp;toomuch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;<span class="comment">/*加密失败*/</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;<span class="comment">/*加密任务繁忙，先挂起等待再次调度*/</span></span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_v1_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 * 由于我们已经手动执行了main_inR1_outI2_continue(),该函数最终会调用到complete_v1_state_transition, 因此在(process_v1_state_xxx流程中不必再此执行状态转换函数。因此返回STF_INLINE，当再次到complete_v1_state_transition判断返回值为它，则不再执行此函数。)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-send-crypto-helper-request源码注释"><a href="#6-send-crypto-helper-request源码注释" class="headerlink" title="6. send_crypto_helper_request源码注释"></a>6. send_crypto_helper_request源码注释</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 生成秘钥信息(KE信息、Nonce信息)，并存储在r中；</li>
<li><input checked="" disabled="" type="checkbox"> 执行后续处理函数：<code>main_inR1_outI2_continue</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this function is called with a request to do some cryptographic operations</span></span><br><span class="line"><span class="comment"> * along with a continuation structure, which will be used to deal with</span></span><br><span class="line"><span class="comment"> * the response.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This may fail if there are no helpers that can take any data, in which</span></span><br><span class="line"><span class="comment"> * case an error is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">err_t</span> <span class="title">send_crypto_helper_request</span><span class="params">(struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">				 , struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">				 , <span class="keyword">bool</span> *toomuch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_worker</span> *<span class="title">w</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do it all ourselves? */</span></span><br><span class="line">    <span class="keyword">if</span>(pc_workers == <span class="literal">NULL</span>) &#123;<span class="comment">/*据说一般会执行此分支*/</span></span><br><span class="line">	reset_cur_state();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成nonce值相关*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LIBNSS</span></span><br><span class="line">	pluto_do_crypto_op(r,pc_helper_num);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	pluto_do_crypto_op(r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* call the continuation */</span></span><br><span class="line">	(*cn-&gt;pcrc_func)(cn, r, <span class="literal">NULL</span>);<span class="comment">//1 /*执行后续函数，如main_inR1_outI2_continue等*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* indicate that we did everything ourselves */</span></span><br><span class="line">	*toomuch = TRUE;</span><br><span class="line"></span><br><span class="line">	pfree(cn);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*后续代码尚未整理，暂不考虑*/</span></span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-send-crypto-helper-request源码注释"><a href="#7-send-crypto-helper-request源码注释" class="headerlink" title="7. send_crypto_helper_request源码注释"></a>7. send_crypto_helper_request源码注释</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 通过<code>main_inR1_outI2_tail</code>构建应答报文</li>
<li><input checked="" disabled="" type="checkbox"> 通过<code>complete_v1_state_transition</code>完成报文的发送和后续的状态切换等。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STATE_MAIN_I1: HDR, SA --&gt; auth dependent</span></span><br><span class="line"><span class="comment"> * PSK_AUTH, DS_AUTH: --&gt; HDR, KE, Ni</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We do heavy computation here. For Main Mode, this is mostly okay,</span></span><br><span class="line"><span class="comment"> * since have already done a return routeability check.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    stf_status e;</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">/*中间调试信息代码略去*/</span></span><br><span class="line"></span><br><span class="line">    e = main_inR1_outI2_tail(pcrc, r);<span class="comment">/*构造应答报文(第四包)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ke-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	complete_v1_state_transition(&amp;ke-&gt;md, e);<span class="comment">/*完成状态转换、发送报文，...*/</span></span><br><span class="line">	<span class="keyword">if</span>(ke-&gt;md) release_md(ke-&gt;md);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-main-inR1-outI2-tail源码注释"><a href="#8-main-inR1-outI2-tail源码注释" class="headerlink" title="8. main_inR1_outI2_tail源码注释"></a>8. main_inR1_outI2_tail源码注释</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 构建ISAKMP头部信息</li>
<li><input checked="" disabled="" type="checkbox"> 构建KE载荷</li>
<li><input checked="" disabled="" type="checkbox"> 构建Nonce载荷</li>
<li><input checked="" disabled="" type="checkbox"> 构建NAT-d载荷</li>
<li><input checked="" disabled="" type="checkbox"> 载荷添加完毕，关闭应答buf, 确定ISAKMP报文长度并填充长度字段。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* STATE_MAIN_I1: HDR, SA --&gt; auth dependent</span></span><br><span class="line"><span class="comment"> * PSK_AUTH, DS_AUTH: --&gt; HDR, KE, Ni</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following are not yet implemented:</span></span><br><span class="line"><span class="comment"> * PKE_AUTH: --&gt; HDR, KE, [ HASH(1), ] &lt;IDi1_b&gt;PubKey_r, &lt;Ni_b&gt;PubKey_r</span></span><br><span class="line"><span class="comment"> * RPKE_AUTH: --&gt; HDR, [ HASH(1), ] &lt;Ni_b&gt;Pubkey_r, &lt;KE_b&gt;Ke_i,</span></span><br><span class="line"><span class="comment"> *                &lt;IDi1_b&gt;Ke_i [,&lt;&lt;Cert-I_b&gt;Ke_i]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We must verify that the proposal received matches one we sent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inR1_outI2_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build output packet HDR;KE;Ni ****************/</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out.</span></span><br><span class="line"><span class="comment">     * We can&#x27;t leave this to comm_handle() because the isa_np</span></span><br><span class="line"><span class="comment">     * depends on the type of Auth (eventually).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*下一个载荷：密钥交换. 填充ISAKMP头部信息*/</span></span><br><span class="line">    echo_hdr(md, FALSE, ISAKMP_NEXT_KE);<span class="comment">/*reply_stream-----md-&gt;rbody*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE out */</span></span><br><span class="line"><span class="comment">/*填充密钥交换载荷，同时状态上记录了密钥的相关信息*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_KE(st, r , &amp;st-&gt;st_gi</span><br><span class="line">		 , &amp;md-&gt;rbody, ISAKMP_NEXT_NONCE))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*填充Nonce载荷*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">/* Ni out */</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;md-&gt;rbody</span><br><span class="line">		    , (cur_debugging &amp; IMPAIR_BUST_MI2)? ISAKMP_NEXT_VID : ISAKMP_NEXT_NONE</span><br><span class="line">		    , <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_debugging &amp; IMPAIR_BUST_MI2)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* generate a pointless large VID payload to push message over MTU */</span></span><br><span class="line">	pb_stream vid_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic(ISAKMP_NEXT_NONE, &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody</span><br><span class="line">	    , &amp;vid_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="keyword">if</span> (!out_zero(<span class="number">1500</span> <span class="comment">/*MTU?*/</span>, &amp;vid_pbs, <span class="string">&quot;Filler VID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;vid_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Ni out */</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;md-&gt;rbody, ISAKMP_NEXT_NONE, <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*填充NAT-D载荷*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T checking st_nat_traversal for NAT_T_WITH_NATD&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">        DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T found NAT_T_WITH_NATD&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_add_natd(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, md))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish message 报文构建结束，确定报文长度*/</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reinsert the state, using the responder cookie we just received */</span></span><br><span class="line">	<span class="comment">//将st从哈希表中删除</span></span><br><span class="line">    unhash_state(st);<span class="comment">/*unhash_state：使用二级指针从双向链表中删除st节点*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(st-&gt;st_rcookie, md-&gt;hdr.isa_rcookie, COOKIE_SIZE);</span><br><span class="line">	<span class="comment">/*重新计算hash值，并插入全局状态链表中*/</span></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid (0) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-NAT-D载荷中哈希值说明"><a href="#9-NAT-D载荷中哈希值说明" class="headerlink" title="9. NAT-D载荷中哈希值说明"></a>9. NAT-D载荷中哈希值说明</h2><p>在NAT-D载荷中，hash值的计算公式为：<br>$$<br>HASH(CKY-I | CKY-R | IP | PORT)<br>$$<br>即分别计算发起者cookie、相应者cookie、IP、端口四个信息的哈希值。对端收到后通过计算报文信息的哈希值和报文中的NAT-D载荷的哈希值相比较，以此来确定中间是否存在NAT设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nat_traversal_add_natd</span><span class="params">(<span class="keyword">u_int8_t</span> np, pb_stream *outs,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nat_np;</span><br><span class="line">	<span class="keyword">const</span> ip_address *first, *second;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> firstport, secondport;</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_oakley.prf_hasher);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_EMITTING|DBG_NATT, DBG_log(<span class="string">&quot;sending NAT-D payloads&quot;</span>));</span><br><span class="line"></span><br><span class="line">	nat_np = (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_RFC_VALUES</span><br><span class="line">		  ? ISAKMP_NEXT_NATD_RFC : ISAKMP_NEXT_NATD_DRAFTS);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!out_modify_previous_np(nat_np, outs)) &#123;<span class="comment">/*修改上一个载荷的np字段*/</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*获取本端和对端的IP和端口*/</span></span><br><span class="line">	first      = &amp;(md-&gt;sender);</span><br><span class="line">	firstport  = ntohs(st-&gt;st_remoteport);</span><br><span class="line">	second     = &amp;(md-&gt;iface-&gt;ip_addr);</span><br><span class="line">	secondport = ntohs(st-&gt;st_localport);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;forceencaps) &#123;<span class="comment">/*强制封装*/</span></span><br><span class="line">		DBG(DBG_NATT, DBG_log(<span class="string">&quot;NAT-T: forceencaps=yes, so mangling hash to force NAT-T detection&quot;</span>));</span><br><span class="line">		firstport=secondport=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * First one with sender IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*计算对端的哈希值: rcookie, icookie, ip, port*/</span></span><br><span class="line">        _natd_hash(st-&gt;st_oakley.prf_hasher, hash, st-&gt;st_icookie</span><br><span class="line">		       , is_zero_cookie(st-&gt;st_rcookie) ? md-&gt;hdr.isa_rcookie : st-&gt;st_rcookie</span><br><span class="line">		       , first, firstport);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic_raw(nat_np, &amp;isakmp_nat_d, outs</span><br><span class="line">			     , hash</span><br><span class="line">			     , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len</span><br><span class="line">			     , <span class="string">&quot;NAT-D&quot;</span>)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Second one with my IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/*计算本端的哈希值: rcookie, icookie, ip, port*/</span></span><br><span class="line">        _natd_hash(st-&gt;st_oakley.prf_hasher, hash</span><br><span class="line">		       , st-&gt;st_icookie</span><br><span class="line">		       , is_zero_cookie(st-&gt;st_rcookie) ? md-&gt;hdr.isa_rcookie : st-&gt;st_rcookie</span><br><span class="line">		       , second, secondport);</span><br><span class="line">	<span class="keyword">return</span> (out_generic_raw(np, &amp;isakmp_nat_d, outs,</span><br><span class="line">		hash, st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len, <span class="string">&quot;NAT-D&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第六包：main_inI3_outR 3</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%85%AD%E5%8C%85%EF%BC%9Amain_inI3_outR3/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p><code>main_inI3_outR3()</code>函数是ISAKMP协商过程中==第六包的核心处理函数的入口==，第五六包主要用来验证对方的身份信息，同时此报文也是加密后的报文。这里我们主要说明<code>main_inI3_outR3</code>的函数调用关系、处理流程以及对源码的注释分析，关于<code>main_inI3_outR3</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，此函数在协商的报文处理函数中比较复杂的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<hr>
<p>目前主要是整理源码中的处理里流程和实现逻辑，尚未深入比较细节的处理；后续在我整理完毕使用主模式协商的9个报文后，我再次结合代码整理每一个报文的详细流程，到时把每一个报文的注意事项、作用，处理方式做一个整体上的把握。同时结合书本上的描述来解释代码层的实现。</p>
<hr>
<p>第五六个报文的载荷内容如下：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205001.png" alt="image-20200605231831766"></p>
<h3 id="2-函数调用关系"><a href="#2-函数调用关系" class="headerlink" title="2.函数调用关系"></a>2.函数调用关系</h3><p>略。</p>
<h3 id="3-第六个报文流程图"><a href="#3-第六个报文流程图" class="headerlink" title="3. 第六个报文流程图"></a>3. 第六个报文流程图</h3><p>第六个报文的处理流程可以分为三类：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>解析对方的身份标识(ID)和证书载荷，匹配对方的身份标识</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>身份验证</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 预共享秘钥</li>
<li><input checked="" disabled="" type="checkbox"> 数字证书</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>构建应答报文</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 身份标识</li>
<li><input checked="" disabled="" type="checkbox"> 证书载荷</li>
<li><input checked="" disabled="" type="checkbox"> 对数据包进行签名</li>
<li><input checked="" disabled="" type="checkbox"> 加密</li>
</ul>
</li>
</ul>
<p>流程图下图：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205004.png" alt="image-20200605232806235"></p>
<h3 id="4-main-inI3-outR3-tail源码学习"><a href="#4-main-inI3-outR3-tail源码学习" class="headerlink" title="4. main_inI3_outR3_tail源码学习"></a>4. main_inI3_outR3_tail源码学习</h3><p>因为<code>main_inI3_outR3</code>中直接调用了<code>main_inI3_outR3_tail</code>, 故而直接将<code>main_inI3_outR3_tail</code>的源代码进行说明，而不再介绍<code>main_inI3_outR3</code>。</p>
<p>该函数的是第六包的核心处理函数，它中调用了<code>main_id_and_auth()</code>完成了对方的ID载荷、证书载荷等的解析和认证工作。</p>
<p>在认证成功的前提下，在继续构建自已的应答报文，将自己的身份标识、证书、签名值等载荷封装然后对报文进行加密，最后发送给隧道的发起者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI3_outR3_tail</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">, struct key_continuation *kc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    <span class="keyword">u_int8_t</span> auth_payload;</span><br><span class="line">    pb_stream r_id_pbs;	<span class="comment">/* ID Payload; also used for hash calculation */</span></span><br><span class="line">    <span class="keyword">cert_t</span> mycert;</span><br><span class="line">    <span class="keyword">bool</span> send_cert;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> np;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID and HASH_I or SIG_I in</span></span><br><span class="line"><span class="comment">     * Note: this may switch the connection being used!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	stf_status r = main_id_and_auth(md, FALSE</span><br><span class="line">					, main_inI3_outR3_continue</span><br><span class="line">					, kc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r != STF_OK)</span><br><span class="line">	    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send certificate if we have one and auth is RSA */</span></span><br><span class="line">    mycert = st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.cert;</span><br><span class="line"></span><br><span class="line">    send_cert = st-&gt;st_oakley.auth == OAKLEY_RSA_SIG</span><br><span class="line">	&amp;&amp; mycert.type != CERT_NONE</span><br><span class="line">	&amp;&amp; ((st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert == cert_sendifasked</span><br><span class="line">	     &amp;&amp; st-&gt;hidden_variables.st_got_certrequest)</span><br><span class="line">	    || st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert==cert_alwayssend);</span><br><span class="line"></span><br><span class="line">    doi_log_cert_thinking(md</span><br><span class="line">			  , st-&gt;st_oakley.auth</span><br><span class="line">			  , mycert.type</span><br><span class="line">			  , st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.sendcert</span><br><span class="line">			  , st-&gt;hidden_variables.st_got_certrequest</span><br><span class="line">			  , send_cert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************** build output packet HDR*;IDir;HASH/SIG_R ***************/</span></span><br><span class="line">    <span class="comment">/* proccess_packet() would automatically generate the HDR*</span></span><br><span class="line"><span class="comment">     * payload if smc-&gt;first_out_payload is not ISAKMP_NEXT_NONE.</span></span><br><span class="line"><span class="comment">     * We don&#x27;t do this because we wish there to be no partially</span></span><br><span class="line"><span class="comment">     * built output packet if we need to suspend for asynch DNS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* ??? <span class="doctag">NOTE:</span> this is almost the same as main_inR2_outI3&#x27;s code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out</span></span><br><span class="line"><span class="comment">     * If auth were PKE_AUTH or RPKE_AUTH, ISAKMP_NEXT_HASH would</span></span><br><span class="line"><span class="comment">     * be first payload.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    echo_hdr(md, TRUE, ISAKMP_NEXT_ID);<span class="comment">/*回转数据包头;*/</span></span><br><span class="line"></span><br><span class="line">    auth_payload = st-&gt;st_oakley.auth == OAKLEY_PRESHARED_KEY</span><br><span class="line">	? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IDir out */</span><span class="comment">/*添加ID载荷*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* id_hd should be struct isakmp_id, but struct isakmp_ipsec_id</span></span><br><span class="line"><span class="comment">	 * allows build_id_payload() to work for both phases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id_hd</span>;</span></span><br><span class="line">		<span class="keyword">chunk_t</span> id_b;</span><br><span class="line"></span><br><span class="line">		build_id_payload(&amp;id_hd, &amp;id_b, &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>);</span><br><span class="line">		</span><br><span class="line">		id_hd.isaiid_np = (send_cert)? ISAKMP_NEXT_CERT : auth_payload;</span><br><span class="line">		<span class="keyword">if</span> (!out_struct(&amp;id_hd, &amp;isakmp_ipsec_identification_desc, &amp;md-&gt;rbody, &amp;r_id_pbs)<span class="comment">/*添加头部*/</span></span><br><span class="line">		|| !out_chunk(id_b, &amp;r_id_pbs, <span class="string">&quot;my identity&quot;</span>))<span class="comment">/*添加ID内容*/</span></span><br><span class="line">		    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">		close_output_pbs(&amp;r_id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CERT out, if we have one */</span></span><br><span class="line">    <span class="keyword">if</span> (send_cert)<span class="comment">/*添加证书载荷*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream cert_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_cert</span> <span class="title">cert_hd</span>;</span></span><br><span class="line">	cert_hd.isacert_np = ISAKMP_NEXT_SIG;</span><br><span class="line">	cert_hd.isacert_type = mycert.type;</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;I am sending my cert&quot;</span>);</span><br><span class="line">	<span class="comment">/*添加证书头部描述*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;cert_hd, &amp;isakmp_ipsec_certificate_desc, &amp;md-&gt;rbody, &amp;cert_pbs))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="comment">/*添加证书主体内容*/</span></span><br><span class="line">	<span class="keyword">if</span> (!out_chunk(get_mycert(mycert), &amp;cert_pbs, <span class="string">&quot;CERT&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;cert_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;md-&gt;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find location of ID PBS */</span></span><br><span class="line">	tpm_findID(pbs, &amp;r_id_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IKEv2 NOTIFY payload */</span></span><br><span class="line">    np = ISAKMP_NEXT_NONE;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;policy &amp; POLICY_IKEV2_ALLOW) &#123;</span><br><span class="line">	np = ISAKMP_NEXT_VID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH_R or SIG_R out */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char hash_val[MAX_DIGEST_LEN];<span class="comment">/*计算ID载荷的hash值*/</span></span><br><span class="line">	<span class="keyword">size_t</span> hash_len = main_mode_hash(st, hash_val, FALSE, &amp;r_id_pbs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (auth_payload == ISAKMP_NEXT_HASH)<span class="comment">/*如果采用hash进制认证*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* HASH_R out */</span><span class="comment">/*填充哈希值*/</span></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_hash_desc, &amp;md-&gt;rbody</span><br><span class="line">	    , hash_val, hash_len, <span class="string">&quot;HASH_R&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">/*在哈希的基础上再进行一个签名采用签名进制认证*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* SIG_R out */</span></span><br><span class="line">	    u_char sig_val[RSA_MAX_OCTETS];</span><br><span class="line">	    <span class="keyword">size_t</span> sig_len = RSA_sign_hash(st-&gt;st_connection</span><br><span class="line">		, sig_val, hash_val, hash_len);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (sig_len == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;unable to locate my private key for RSA Signature&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + AUTHENTICATION_FAILED;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!out_generic_raw(np, &amp;isakmp_signature_desc<span class="comment">/*填充签名签名信息*/</span></span><br><span class="line">	    , &amp;md-&gt;rbody, sig_val, sig_len, <span class="string">&quot;SIG_R&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;policy &amp; POLICY_IKEV2_ALLOW) &#123;</span><br><span class="line">	<span class="keyword">if</span>(!out_vid(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, VID_MISC_IKEv2))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, sans fixed part of header */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last block of Phase 1 (R3), kept for Phase 2 IV generation */</span></span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;last encrypted block of Phase 1:&quot;</span></span><br><span class="line">	, st-&gt;st_new_iv, st-&gt;st_new_iv_len);</span><br><span class="line"><span class="comment">/*保存第一阶段的IV信息*/</span></span><br><span class="line">    st-&gt;st_ph1_iv_len = st-&gt;st_new_iv_len;</span><br><span class="line">    set_ph1_iv(st, st-&gt;st_new_iv);<span class="comment">/*设置初始化向量*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It seems as per Cisco implementation, XAUTH and MODECFG</span></span><br><span class="line"><span class="comment">     * are not supposed to be performed again during rekey */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( st-&gt;st_connection-&gt;remotepeertype == CISCO &amp;&amp;</span><br><span class="line">	st-&gt;st_connection-&gt;newest_isakmp_sa != SOS_NOBODY &amp;&amp;</span><br><span class="line">        st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.xauth_client) &#123;</span><br><span class="line">           DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;Skipping XAUTH for rekey for Cisco Peer compatibility.&quot;</span>));</span><br><span class="line">           st-&gt;hidden_variables.st_xauth_client_done = TRUE;</span><br><span class="line">           st-&gt;st_oakley.xauth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(st-&gt;st_connection-&gt;spd.<span class="keyword">this</span>.modecfg_client) &#123;</span><br><span class="line">                DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;Skipping ModeCFG for rekey for Cisco Peer compatibility.&quot;</span>));</span><br><span class="line">                st-&gt;hidden_variables.st_modecfg_vars_set = TRUE;</span><br><span class="line">                st-&gt;hidden_variables.st_modecfg_started = TRUE;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ISAKMP_SA_established(st-&gt;st_connection, st-&gt;st_serialno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ??? If st-&gt;st_connectionc-&gt;gw_info != NULL,</span></span><br><span class="line"><span class="comment">     * we should keep the public key -- it tested out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-oakley-id-and-auth源码学习"><a href="#5-oakley-id-and-auth源码学习" class="headerlink" title="5. oakley_id_and_auth源码学习"></a>5. oakley_id_and_auth源码学习</h3><p><code>oakley_id_and_auth()</code>函数的作用是对第五包中的身份标识、证书载荷、证书请求载荷等进行解析，并根据配置的认证方式(<strong>预共享秘钥、数字证书</strong>)完成对对端的认证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">oakley_id_and_auth</span><span class="params">(struct msg_digest *md</span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">bool</span> initiator	<span class="comment">/* are we the Initiator? */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">bool</span> aggrmode                <span class="comment">/* aggressive mode? */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">cont_fn_t</span> cont_fn	<span class="comment">/* continuation function */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 , <span class="keyword">const</span> struct key_continuation *kc	<span class="comment">/* current state, can be NULL */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    u_char hash_val[MAX_DIGEST_LEN];</span><br><span class="line">    <span class="keyword">size_t</span> hash_len;</span><br><span class="line">    stf_status r = STF_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;<span class="comment">/*当前有数据包正在处理*/</span></span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//1 HDR*, IDii, [ CERT, ] SIG_I </span></span><br><span class="line">    <span class="comment">/* ID Payload in.</span></span><br><span class="line"><span class="comment">     * Note: this may switch the connection being used!</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">/*主动模式时，需要解析对端标识信息;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!aggrmode &amp;&amp; !decode_peer_id(md, initiator, FALSE))</span><br><span class="line">	<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"><span class="comment">/*对报文进行验签: </span></span><br><span class="line"><span class="comment">	1.计算对端ID的哈希值</span></span><br><span class="line"><span class="comment">	2. 如果使用的共享秘钥，则报文中使用hash算法进行签名，因此直接比较哈希值是否一致即可</span></span><br><span class="line"><span class="comment">	3. 如果使用证书的方式，则需要使用RSA....等进行验签</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hash the ID Payload.</span></span><br><span class="line"><span class="comment">     * main_mode_hash requires idpl-&gt;cur to be at end of payload</span></span><br><span class="line"><span class="comment">     * so we temporarily set if so.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *idpl = &amp;md-&gt;chain[ISAKMP_NEXT_ID]-&gt;pbs;</span><br><span class="line">	<span class="keyword">u_int8_t</span> *old_cur = idpl-&gt;cur;</span><br><span class="line"></span><br><span class="line">	idpl-&gt;cur = idpl-&gt;roof;</span><br><span class="line">	hash_len = main_mode_hash(st, hash_val, !initiator, idpl);</span><br><span class="line">	idpl-&gt;cur = old_cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;st_oakley.auth)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OAKLEY_PRESHARED_KEY:<span class="comment">/*共享秘钥认证*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    pb_stream *<span class="keyword">const</span> hash_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_HASH]-&gt;pbs;<span class="comment">/*获取哈希载荷的数据部分(即哈希值)*/</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (pbs_left(hash_pbs) != hash_len</span><br><span class="line">	    || <span class="built_in">memcmp</span>(hash_pbs-&gt;cur, hash_val, hash_len) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;received HASH:&quot;</span></span><br><span class="line">		    , hash_pbs-&gt;cur, pbs_left(hash_pbs));</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;received Hash Payload does not match computed value&quot;</span>);</span><br><span class="line">		<span class="comment">/* XXX Could send notification back */</span></span><br><span class="line">		r = STF_FAIL + INVALID_HASH_INFORMATION;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OAKLEY_RSA_SIG:<span class="comment">/*数字证书认证*/</span></span><br><span class="line">	r = RSA_check_signature(st, hash_val, hash_len</span><br><span class="line">	    , &amp;md-&gt;chain[ISAKMP_NEXT_SIG]-&gt;pbs</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">	    , kc == <span class="literal">NULL</span>? <span class="literal">NULL</span> : kc-&gt;ac.keys_from_dns</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_KEYRR */</span></span></span><br><span class="line">	    , kc == <span class="literal">NULL</span>? <span class="literal">NULL</span> : kc-&gt;ac.gateways_from_dns</span><br><span class="line">	    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r == STF_SUSPEND)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* initiate/resume asynchronous DNS lookup for key */</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">key_continuation</span> *<span class="title">nkc</span></span></span><br><span class="line"><span class="class">		=</span> alloc_thing(struct key_continuation, <span class="string">&quot;key continuation&quot;</span>);</span><br><span class="line">	    <span class="class"><span class="keyword">enum</span> <span class="title">key_oppo_step</span> <span class="title">step_done</span> =</span> kc == <span class="literal">NULL</span>? kos_null : kc-&gt;step;</span><br><span class="line">	    <span class="keyword">err_t</span> ugh;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Record that state is used by a suspended md */</span></span><br><span class="line">	    passert(st-&gt;st_suspended_md == <span class="literal">NULL</span>);</span><br><span class="line">	    set_suspended(st,md);</span><br><span class="line"></span><br><span class="line">	    nkc-&gt;failure_ok = FALSE;</span><br><span class="line">	    nkc-&gt;md = md;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">switch</span> (step_done)</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">case</span> kos_null:</span><br><span class="line">		<span class="comment">/* first try: look for the TXT records */</span></span><br><span class="line">		nkc-&gt;step = kos_his_txt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">		nkc-&gt;failure_ok = TRUE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ugh = start_adns_query(&amp;st-&gt;st_connection-&gt;spd.that.id</span><br><span class="line">				       , &amp;st-&gt;st_connection-&gt;spd.that.id	<span class="comment">/* SG itself */</span></span><br><span class="line">				       , ns_t_txt</span><br><span class="line">				       , cont_fn</span><br><span class="line">				       , &amp;nkc-&gt;ac);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_KEYRR</span></span><br><span class="line">	    <span class="keyword">case</span> kos_his_txt:</span><br><span class="line">		<span class="comment">/* second try: look for the KEY records */</span></span><br><span class="line">		nkc-&gt;step = kos_his_key;</span><br><span class="line">		ugh = start_adns_query(&amp;st-&gt;st_connection-&gt;spd.that.id</span><br><span class="line">				       , <span class="literal">NULL</span>	<span class="comment">/* no sgw for KEY */</span></span><br><span class="line">				       , ns_t_key</span><br><span class="line">				       , cont_fn</span><br><span class="line">				       , &amp;nkc-&gt;ac);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_KEYRR */</span></span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">		bad_case(step_done);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (ugh != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		report_key_dns_failure(&amp;st-&gt;st_connection-&gt;spd.that.id, ugh);</span><br><span class="line">		set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">		r = STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * since this state is waiting for a DNS query, delete</span></span><br><span class="line"><span class="comment">		 * any events that might kill it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		delete_event(st);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	bad_case(st-&gt;st_oakley.auth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == STF_OK)</span><br><span class="line">	DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;authentication succeeded&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>主模式第四包：main_inI2_outR2</title>
    <url>/blogs/2021/11/20/%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E5%9B%9B%E5%8C%85%EF%BC%9Amain_inI2_outR2/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p><code>main_inI2_outR2()</code>函数是ISAKMP协商过程中==第四包的核心处理函数的入口==，同时在此处理流程中已经获取到足够的隧道信息，可以生成需要的密钥信息。这里我们主要说明<code>main_inI2_outR2</code>的函数调用关系、处理流程以及对源码的注释分析，关于<code>main_inI2_outR2</code>的上下文环境暂不叙述，留给后面的文章进行更新。</p>
<span id="more"></span>
<p>ISAKMP协商报文的处理流程都比较复杂，此函数在协商的报文处理函数中比较复杂的，因此个人学习期间难免有遗漏和理解错误的地方，请大家多多批评指正。</p>
<p>对于源码的学习，我并没有把每一行进行备注，而是将自己认为的关键点做了注释或者标注。</p>
<h3 id="2-函数调用关系"><a href="#2-函数调用关系" class="headerlink" title="2.函数调用关系"></a>2.函数调用关系</h3><p>暂略。(此流程调用比较多，后面会在补充上)</p>
<h3 id="3-第四个报文流程图"><a href="#3-第四个报文流程图" class="headerlink" title="3. 第四个报文流程图"></a>3. 第四个报文流程图</h3><p>第四个报文处理流程大致可以划分为四类功能：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解析收到的第三个报文内容</li>
<li><input checked="" disabled="" type="checkbox"> 生成随机数(本段的KE和Nonce值)</li>
<li><input checked="" disabled="" type="checkbox"> 构造应答报文</li>
<li><input checked="" disabled="" type="checkbox"> 使用DH算法制作秘钥(三把钥匙)</li>
</ul>
<p>整理的处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204827.png" alt="image-20200522000821053"></p>
<p>个人觉得这个流程做的还是很清晰和准确的(原谅我没有上色)<img src="" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120204834.gif" alt="img"></p>
<h3 id="4-main-inI2-outR2源码分析"><a href="#4-main-inI2-outR2源码分析" class="headerlink" title="4. main_inI2_outR2源码分析"></a>4. main_inI2_outR2源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    pb_stream *keyex_pbs = &amp;md-&gt;chain[ISAKMP_NEXT_KE]-&gt;pbs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we are already processing a packet on this st, we will be unable</span></span><br><span class="line"><span class="comment">     * to start another crypto operation below */</span></span><br><span class="line">    <span class="keyword">if</span> (is_suspended(st)) &#123;<span class="comment">/*为了方式该流程处理时间过长导致对端超时重发*/</span></span><br><span class="line">        openswan_log(<span class="string">&quot;%s: already processing a suspended cyrpto operation &quot;</span></span><br><span class="line">                     <span class="string">&quot;on this SA, duplicate will be dropped.&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE in */</span><span class="comment">/*从报文中获取KE载荷，并填充到st-&gt;st_gi上*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_KE(&amp;st-&gt;st_gi, <span class="string">&quot;Gi&quot;</span></span><br><span class="line">				 , st-&gt;st_oakley.group, keyex_pbs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ni in */</span><span class="comment">/*从报文中获取Nonce载荷，并填充到st-&gt;st_ni上*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_ni, <span class="string">&quot;Ni&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decode certificate requests */</span><span class="comment">/*解析证书载荷，以链表的方式存储在st-&gt;st_connection-&gt;requested_ca*/</span></span><br><span class="line">    ikev1_decode_cr(md, &amp;st-&gt;st_connection-&gt;ikev1_requested_ca_names);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;requested_ca != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	st-&gt;hidden_variables.st_got_certrequest = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    DBG(DBG_NATT</span><br><span class="line">	, DBG_log(<span class="string">&quot;inI2: checking NAT-T: %d and %d&quot;</span></span><br><span class="line">		  , nat_traversal_enabled</span><br><span class="line">		  , st-&gt;hidden_variables.st_nat_traversal));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">       DBG(DBG_NATT, DBG_log(<span class="string">&quot; NAT_T_WITH_NATD detected&quot;</span>));</span><br><span class="line">       nat_traversal_natd_lookup(md);<span class="comment">/*根据哈希值确定是否经过NAT;状态上的NAT-T标志在此处做的修改*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal) &#123;<span class="comment">/*打印NAT-T、端口浮动相关信息*/</span></span><br><span class="line">       nat_traversal_show_result(st-&gt;hidden_variables.st_nat_traversal</span><br><span class="line">				 , md-&gt;sender_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_KA) &#123;</span><br><span class="line">       DBG(DBG_NATT, DBG_log(<span class="string">&quot; NAT_T_WITH_KA detected&quot;</span>));</span><br><span class="line">       nat_traversal_new_ka_event();<span class="comment">/*添加NAT-T的保活事件*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> alloc_thing(struct ke_continuation</span><br><span class="line">					     , <span class="string">&quot;inI2_outR2 KE&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ke-&gt;md = md;</span><br><span class="line">	set_suspended(st, md);</span><br><span class="line"></span><br><span class="line">	passert(st-&gt;st_sec_in_use == FALSE);</span><br><span class="line">	pcrc_init(&amp;ke-&gt;ke_pcrc);</span><br><span class="line">	ke-&gt;ke_pcrc.pcrc_func = main_inI2_outR2_continue;</span><br><span class="line">	<span class="keyword">return</span> build_ke(&amp;ke-&gt;ke_pcrc, st</span><br><span class="line">			, st-&gt;st_oakley.group, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-nat-traversal-natd-lookup源码分析"><a href="#5-nat-traversal-natd-lookup源码分析" class="headerlink" title="5. nat_traversal_natd_lookup源码分析"></a>5. nat_traversal_natd_lookup源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*检查是否需要经过NAT-T*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nat_traversal_natd_lookup</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash_me[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hash_him[MAX_DIGEST_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">	<span class="keyword">bool</span> found_me = FALSE;</span><br><span class="line">	<span class="keyword">bool</span> found_him= FALSE;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	passert(st);</span><br><span class="line">	passert(md-&gt;iface);</span><br><span class="line">	passert(st-&gt;st_oakley.prf_hasher);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Count NAT-D **/</span></span><br><span class="line">	<span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_NATD_RFC], i=<span class="number">0</span>;</span><br><span class="line">	     p != <span class="literal">NULL</span>;</span><br><span class="line">	     p = p-&gt;next, i++);<span class="comment">/*统计NAT-D的数量*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * We need at least 2 NAT-D (1 for us, many for peer)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS,</span><br><span class="line">		<span class="string">&quot;NAT-Traversal: Only %d NAT-D - Aborting NAT-Traversal negotiation&quot;</span>, i);</span><br><span class="line">		st-&gt;hidden_variables.st_nat_traversal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * First one with my IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	_natd_hash(st-&gt;st_oakley.prf_hasher, hash_me</span><br><span class="line">		   , st-&gt;st_icookie, st-&gt;st_rcookie</span><br><span class="line">		   , &amp;(md-&gt;iface-&gt;ip_addr)</span><br><span class="line">		   , ntohs(md-&gt;iface-&gt;port));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The others with sender IP &amp; port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	_natd_hash(st-&gt;st_oakley.prf_hasher, hash_him</span><br><span class="line">		   , st-&gt;st_icookie, st-&gt;st_rcookie</span><br><span class="line">		   , &amp;(md-&gt;sender), ntohs(md-&gt;sender_port));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (p = md-&gt;chain[ISAKMP_NEXT_NATD_RFC], i=<span class="number">0</span>;</span><br><span class="line">	     p != <span class="literal">NULL</span> &amp;&amp; (!found_me || !found_him);</span><br><span class="line">	     p = p-&gt;next)</span><br><span class="line">	  &#123;</span><br><span class="line">	    DBG(DBG_NATT,</span><br><span class="line">		DBG_log(<span class="string">&quot;NAT_TRAVERSAL hash=%d (me:%d) (him:%d)&quot;</span></span><br><span class="line">			, i, found_me, found_him);</span><br><span class="line">		DBG_dump(<span class="string">&quot;expected NAT-D(me):&quot;</span>, hash_me,</span><br><span class="line">			 st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len);</span><br><span class="line">		DBG_dump(<span class="string">&quot;expected NAT-D(him):&quot;</span>, hash_him,</span><br><span class="line">			 st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len);</span><br><span class="line">		DBG_dump(<span class="string">&quot;received NAT-D:&quot;</span>, p-&gt;pbs.cur, pbs_left(&amp;p-&gt;pbs));</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ( (pbs_left(&amp;p-&gt;pbs) == st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)</span><br><span class="line">		 &amp;&amp; (<span class="built_in">memcmp</span>(p-&gt;pbs.cur, hash_me</span><br><span class="line">			    , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)==<span class="number">0</span>))</span><br><span class="line">	      &#123;</span><br><span class="line">		found_me = TRUE;<span class="comment">/*本端未经过NAT*/</span></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ( (pbs_left(&amp;p-&gt;pbs) == st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)</span><br><span class="line">		 &amp;&amp; (<span class="built_in">memcmp</span>(p-&gt;pbs.cur, hash_him</span><br><span class="line">			    , st-&gt;st_oakley.prf_hasher-&gt;hash_digest_len)==<span class="number">0</span>))</span><br><span class="line">	      &#123;</span><br><span class="line">		found_him = TRUE;<span class="comment">/*对端未经过NAT*/</span></span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    i++;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	DBG(DBG_NATT,</span><br><span class="line">	    DBG_log(<span class="string">&quot;NAT_TRAVERSAL hash=%d (me:%d) (him:%d)&quot;</span></span><br><span class="line">		    , i, found_me, found_him));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!found_me) &#123;</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_ME);<span class="comment">/*本端经过NAT*/</span></span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;st-&gt;hidden_variables.st_natd,<span class="number">0</span>,<span class="keyword">sizeof</span>(st-&gt;hidden_variables.st_natd));</span><br><span class="line">	anyaddr(AF_INET, &amp;st-&gt;hidden_variables.st_natd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!found_him) &#123;</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_PEER);<span class="comment">/*对端经过NAT*/</span></span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;forceencaps) &#123;<span class="comment">/*如果需要强制使用UDP封装双方都需要NAT-D*/</span></span><br><span class="line">	    DBG(DBG_NATT,</span><br><span class="line">		DBG_log(<span class="string">&quot;NAT_TRAVERSAL forceencaps enabled&quot;</span>));</span><br><span class="line"></span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_PEER);</span><br><span class="line">	    st-&gt;hidden_variables.st_nat_traversal |= LELEM(NAT_TRAVERSAL_NAT_BHND_ME);</span><br><span class="line">	    st-&gt;hidden_variables.st_natd = md-&gt;sender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-build-ke源码分析"><a href="#6-build-ke源码分析" class="headerlink" title="6. build_ke源码分析"></a>6. build_ke源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">stf_status <span class="title">build_ke</span><span class="params">(struct pluto_crypto_req_cont *cn</span></span></span><br><span class="line"><span class="params"><span class="function">		    , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">const</span> struct oakley_group_desc *group</span></span></span><br><span class="line"><span class="params"><span class="function">		    , <span class="keyword">enum</span> crypto_importance importance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> <span class="title">rd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pluto_crypto_req</span> *<span class="title">r</span> =</span> &amp;rd;</span><br><span class="line">    <span class="keyword">err_t</span> e;</span><br><span class="line">    <span class="keyword">bool</span> toomuch = FALSE;</span><br><span class="line"><span class="comment">/*初始化加密请求*/</span></span><br><span class="line">    pcr_init(r, pcr_build_kenonce, importance);</span><br><span class="line">    r-&gt;pcr_d.kn.oakley_group   = group-&gt;group;</span><br><span class="line"></span><br><span class="line">    cn-&gt;pcrc_serialno = st-&gt;st_serialno;</span><br><span class="line">	<span class="comment">/*申请制作加密材料请求*/</span></span><br><span class="line">    e= send_crypto_helper_request(r, cn, &amp;toomuch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">NULL</span>) &#123;<span class="comment">/*加密失败*/</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;can not start crypto helper: %s&quot;</span>, e);</span><br><span class="line">	<span class="keyword">if</span>(toomuch) &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_TOOMUCHCRYPTO;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!toomuch) &#123;<span class="comment">/*加密任务繁忙，先挂起等待再次调度*/</span></span><br><span class="line">	st-&gt;st_calculating = TRUE;</span><br><span class="line">	delete_event(st);</span><br><span class="line">	event_schedule(EVENT_CRYPTO_FAILED, EVENT_CRYPTO_FAILED_DELAY, st);</span><br><span class="line">	<span class="keyword">return</span> STF_SUSPEND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* we must have run the continuation directly, so</span></span><br><span class="line"><span class="comment">	 * complete_v1_state_transition already got called.</span></span><br><span class="line"><span class="comment">	 * 由于我们已经手动执行了main_inR1_outI2_continue(),该函数最终会调用到complete_v1_state_transition</span></span><br><span class="line"><span class="comment">	 * 因此在(process_v1_state_xxx流程中不必再此执行状态转换函数。因此返回STF_INLINE，当再次到complete_v1_state_transition</span></span><br><span class="line"><span class="comment">	 *判断返回值为它，则不再执行此函数。)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_INLINE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-main-inI2-outR2-continue源码分析"><a href="#7-main-inI2-outR2-continue源码分析" class="headerlink" title="7. main_inI2_outR2_continue源码分析"></a>7. main_inI2_outR2_continue源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    stf_status e;</span><br><span class="line">    ... ... </span><br><span class="line">    set_suspended(st, <span class="literal">NULL</span>);	<span class="comment">/* no longer connected or suspended */</span></span><br><span class="line"></span><br><span class="line">    set_cur_state(st);</span><br><span class="line"></span><br><span class="line">    st-&gt;st_calculating = FALSE;</span><br><span class="line">    e = main_inI2_outR2_tail(pcrc, r);<span class="comment">/*构造应答报文*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ke-&gt;md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        complete_v1_state_transition(&amp;ke-&gt;md, e);<span class="comment">/*发送报文并完后后续处理工作*/</span></span><br><span class="line">        <span class="keyword">if</span>(ke-&gt;md) release_md(ke-&gt;md);</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-main-inI2-outR2-tail源码分析"><a href="#8-main-inI2-outR2-tail源码分析" class="headerlink" title="8. main_inI2_outR2_tail源码分析"></a>8. main_inI2_outR2_tail源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this routine gets called after any DH exponentiation that needs to be done</span></span><br><span class="line"><span class="comment"> * has been done, and we are ready to send our g^y.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ke_continuation</span> *<span class="title">ke</span> =</span> (struct ke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> ke-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send CR if auth is RSA and no preloaded RSA public key exists*/</span></span><br><span class="line">    <span class="keyword">bool</span> send_cr = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build output packet HDR;KE;Nr ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果以下四个条件同时满足，则通过需要发送证书。。*/</span></span><br><span class="line">    send_cr = !no_cr_send							<span class="comment">/*配置中允许发送证书*/</span></span><br><span class="line">	&amp;&amp; (st-&gt;st_oakley.auth == OAKLEY_RSA_SIG)		<span class="comment">/*使用RSA签名*/</span></span><br><span class="line">	&amp;&amp; !has_preloaded_public_key(st)				<span class="comment">/*未加载未共享秘钥*/</span></span><br><span class="line">	&amp;&amp; st-&gt;st_connection-&gt;spd.that.ca.ptr != <span class="literal">NULL</span>;	<span class="comment">/*对端证书非空*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR out */</span></span><br><span class="line">    echo_hdr(md, FALSE, ISAKMP_NEXT_KE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KE out */</span><span class="comment">/*添加KE载荷，并将其存储在st-&gt;st_gr*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_KE(st, r, &amp;st-&gt;st_gr</span><br><span class="line">		 , &amp;md-&gt;rbody, ISAKMP_NEXT_NONCE))</span><br><span class="line">	&#123;</span><br><span class="line">	    osw_abort();</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">/* Nr out */</span></span><br><span class="line">    <span class="keyword">int</span> next_payload;</span><br><span class="line">    next_payload = ISAKMP_NEXT_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur_debugging &amp; IMPAIR_BUST_MR2)</span><br><span class="line">    &#123;</span><br><span class="line">	next_payload = ISAKMP_NEXT_VID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">        next_payload = ISAKMP_NEXT_CR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_nr, r</span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , next_payload</span><br><span class="line">		    , <span class="string">&quot;Nr&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_debugging &amp; IMPAIR_BUST_MR2)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">/* generate a pointless large VID payload to push message over MTU */</span></span><br><span class="line">	pb_stream vid_pbs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!out_generic((send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_NONE,</span><br><span class="line">	    &amp;isakmp_vendor_id_desc, &amp;md-&gt;rbody, &amp;vid_pbs))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	<span class="keyword">if</span> (!out_zero(<span class="number">1500</span> <span class="comment">/*MTU?*/</span>, &amp;vid_pbs, <span class="string">&quot;Filler VID&quot;</span>))</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	close_output_pbs(&amp;vid_pbs);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Nr out */</span><span class="comment">/*添加NONCE载荷，并将其存储在st-&gt;st_nr*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_nr, r</span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , (send_cr)? ISAKMP_NEXT_CR : ISAKMP_NEXT_NONE</span><br><span class="line">		    , <span class="string">&quot;Nr&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CR out */</span><span class="comment">/*如果需要发送证书*/</span></span><br><span class="line">    <span class="keyword">if</span> (send_cr)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">if</span> (st-&gt;st_connection-&gt;kind == CK_PERMANENT)<span class="comment">/*双方连接固定,即两端的IP的确定的*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE <span class="comment">/*添加对端证书载荷*/</span></span><br><span class="line">				   , st-&gt;st_connection-&gt;spd.that.ca</span><br><span class="line">				   , &amp;md-&gt;rbody, ISAKMP_NEXT_NONE))</span><br><span class="line">		<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    generalName_t *ca = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*查询可用的证书   ???*/</span></span><br><span class="line">	    <span class="keyword">if</span> (collect_rw_ca_candidates(md, &amp;ca))<span class="comment">/*收集所有可用证书,并全部加载到ca链表上*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">		generalName_t *gn;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (gn = ca; gn != <span class="literal">NULL</span>; gn = gn-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE, gn-&gt;name<span class="comment">/*将所有的可用证书加载到链表上*/</span></span><br><span class="line">		    , &amp;md-&gt;rbody</span><br><span class="line">		    , gn-&gt;next == <span class="literal">NULL</span> ? ISAKMP_NEXT_NONE : ISAKMP_NEXT_CR))</span><br><span class="line">			<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		free_generalNames(ca, FALSE);<span class="comment">/*释放可用证书链表*/</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;<span class="comment">/*确实没有找到可用的证书，则填充一个空的证书载荷*/</span></span><br><span class="line">		<span class="keyword">if</span> (!build_and_ship_CR(CERT_X509_SIGNATURE, empty_chunk</span><br><span class="line">		, &amp;md-&gt;rbody, ISAKMP_NEXT_NONE))</span><br><span class="line">		    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATD) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!nat_traversal_add_natd(ISAKMP_NEXT_NONE, &amp;md-&gt;rbody, md))<span class="comment">/*添加NAT-D载荷*/</span></span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish message */</span></span><br><span class="line">    close_message(&amp;md-&gt;rbody);</span><br><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	使  用  DH  算  法  开  始  制  作  密  钥</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * next message will be encrypted, so, we need to have</span></span><br><span class="line"><span class="comment">     * the DH value calculated. We can do this in the background,</span></span><br><span class="line"><span class="comment">     * sending the reply right away. We have to be careful on the next</span></span><br><span class="line"><span class="comment">     * state, since the other end may reply faster than we can calculate</span></span><br><span class="line"><span class="comment">     * things. If it is the case, then the packet is placed in the</span></span><br><span class="line"><span class="comment">     * continuation, and we let the continuation process it. If there</span></span><br><span class="line"><span class="comment">     * is a retransmit, we keep only the last packet.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also, note that this is not a suspended state, since we are</span></span><br><span class="line"><span class="comment">     * actually just doing work in the background.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* Looks like we missed perform_dh() declared at</span></span><br><span class="line"><span class="comment">     * programs/pluto/pluto_crypt.h as external and implemented nowhere.</span></span><br><span class="line"><span class="comment">     * Following code regarding dh_continuation allocation seems useless</span></span><br><span class="line"><span class="comment">     * as it&#x27;s never used. At least, we should free it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> alloc_thing(struct dh_continuation</span><br><span class="line">						 , <span class="string">&quot;main_inI2_outR2_tail&quot;</span>);</span><br><span class="line">	stf_status e;</span><br><span class="line"></span><br><span class="line">	dh-&gt;md = <span class="literal">NULL</span>;</span><br><span class="line">	dh-&gt;serialno = st-&gt;st_serialno;</span><br><span class="line">	pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">	dh-&gt;dh_pcrc.pcrc_func = main_inI2_outR2_calcdone;</span><br><span class="line">	passert(st-&gt;st_suspended_md == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_CONTROLMORE</span><br><span class="line">	    , DBG_log(<span class="string">&quot;main inI2_outR2: starting async DH calculation (group=%d)&quot;</span>, st-&gt;st_oakley.group-&gt;group));</span><br><span class="line"></span><br><span class="line">	e = start_dh_secretiv(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">			      , st-&gt;st_import</span><br><span class="line">			      , RESPONDER</span><br><span class="line">			      , st-&gt;st_oakley.group-&gt;group);</span><br><span class="line"></span><br><span class="line">	DBG(DBG_CONTROLMORE,</span><br><span class="line">	    DBG_log(<span class="string">&quot;started dh_secretiv, returned: stf=%s\n&quot;</span></span><br><span class="line">		    , stf_status_name(e)));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(e == STF_FAIL) &#123;</span><br><span class="line">	    loglog(RC_LOG_SERIOUS, <span class="string">&quot;failed to start async DH calculation, stf=%s\n&quot;</span></span><br><span class="line">		   , stf_status_name(e));</span><br><span class="line">	    <span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we are calculating in the background, so it doesn&#x27;t count */</span></span><br><span class="line">	<span class="keyword">if</span>(e == STF_SUSPEND) &#123;</span><br><span class="line">	    st-&gt;st_calculating = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-main-inI2-outR2-calcdone源码分析"><a href="#9-main-inI2-outR2-calcdone源码分析" class="headerlink" title="9. main_inI2_outR2_calcdone源码分析"></a>9. main_inI2_outR2_calcdone源码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main_inI2_outR2_calcdone</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">			 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">			 , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> (struct dh_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROLMORE</span><br><span class="line">	, DBG_log(<span class="string">&quot;main inI2_outR2: calculated DH finished&quot;</span>));</span><br><span class="line"></span><br><span class="line">    st = state_with_serialno(dh-&gt;serialno);</span><br><span class="line">    <span class="keyword">if</span>(st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	openswan_log(<span class="string">&quot;state %ld disappeared during crypto\n&quot;</span>, dh-&gt;serialno);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);</span><br><span class="line">    <span class="keyword">if</span>(ugh) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;DH crypto failed: %s\n&quot;</span>, ugh);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*将生成的三把秘钥、DH-IV等信息存储在状态上*/</span></span><br><span class="line">    finish_dh_secretiv(st, r);</span><br><span class="line">    <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">        loglog(RC_LOG_SERIOUS, <span class="string">&quot;DH crypto failed, invalid keys&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ikev2_validate_key_lengths(st);</span><br><span class="line"></span><br><span class="line">    st-&gt;hidden_variables.st_skeyid_calculated = TRUE;</span><br><span class="line">    update_iv(st);<span class="comment">/*更新IV值*/</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> Do we need to free dh here? If so, how about the other exits?</span></span><br><span class="line"><span class="comment">     * pfree(dh); dh = NULL;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * if there was a packet received while we were calculating, then</span></span><br><span class="line"><span class="comment">     * process it now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*如果在计算秘钥的过程中收到新的报文则现在再处理该报文*/</span></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_suspended_md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> st-&gt;st_suspended_md;</span><br><span class="line"></span><br><span class="line">	set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">	process_packet_tail(&amp;md);</span><br><span class="line">	<span class="keyword">if</span>(md != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    release_md(md);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reset_cur_state();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













































































]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>快速模式第三包之quick_inR1_outI2()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85%20quick_inR1_outI2()/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205850.png" alt="image-20200909232524545"></p>
<span id="more"></span>
<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p>在上一篇中博客中长话短说了第二包的处理流程，前两个报文的交互是快速模式的关键交互，用来协商会话参数(加解密算法、会话秘钥等)，而第三包则是对前两个报文的认证，流程上简单了很多 。<code>quick_inR1_outI2()</code>处理流程实现的功能如下：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>解析SA载荷</strong>(对端选择的加解密算法信息)、<strong>KE载荷</strong>(pfs)、<strong>Nonce载荷</strong>。</li>
<li><input checked="" disabled="" type="checkbox"> 构造第三个报文</li>
<li><input checked="" disabled="" type="checkbox"> <strong>生成密钥生成材料keymats</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>建立完整的IPsec SA</strong><ul>
<li><input checked="" disabled="" type="checkbox"> 发起端建立的为完整IPSec SA,包括入SA和出SA，响应端有所不同。</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>启动DPD检测</strong></li>
</ul>
<h3 id="2-quick-inR1-outI2-的处理流程"><a href="#2-quick-inR1-outI2-的处理流程" class="headerlink" title="2. quick_inR1_outI2()的处理流程"></a>2. quick_inR1_outI2()的处理流程</h3><p>第三个报文的完整处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205853.png" alt="image-20200913094835778"></p>
<h3 id="3-快速模式第③包报文格式"><a href="#3-快速模式第③包报文格式" class="headerlink" title="3. 快速模式第③包报文格式"></a>3. 快速模式第③包报文格式</h3><p> 该报文中的杂凑载荷是对前面交换的认证。第③包仅有ISAKMP头部和杂凑载荷构成，杂凑载荷的消息摘要是以==一个0字节的MsgID、去掉载荷头的发起者Nonce以及去掉了载荷头的响应者Nonce==为输入参数生成的，计算公式如下：<br>$$<br>HASH(3) = PRF(SKEY-a,  0|MsgID|Ni_b|Nr_b)<br>$$</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205858.png" alt="图片1"></p>
<h3 id="4-quick-inR1-outI2-源码分析"><a href="#4-quick-inR1-outI2-源码分析" class="headerlink" title="4. quick_inR1_outI2()源码分析"></a>4. quick_inR1_outI2()源码分析</h3><p>接口<code>quick_inR1_outI2()</code>的主要功能如下：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> ==验证报文的完整性==</li>
<li><input checked="" disabled="" type="checkbox"> ==解析响应端选择的SA载荷==<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>加解密算法(ESP协议、AH协议，…)</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>认证算法</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>封装模式（隧道模式 ？传输模式）</strong></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> ==解析Nonce载荷==</li>
<li><input checked="" disabled="" type="checkbox"> 如果启用PFS<ul>
<li><input disabled="" type="checkbox"> 解析KE载荷</li>
<li><input disabled="" type="checkbox"> 再次计算DH交换值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inR1_outI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(2) in */</span><span class="comment">/*验证报文的哈希载荷*/</span></span><br><span class="line">    CHECK_QUICK_HASH(md</span><br><span class="line">	, quick_mode_hash12(hash_val, hash_pbs-&gt;roof, md-&gt;message_pbs.roof</span><br><span class="line">	    , st, &amp;st-&gt;st_msgid, TRUE)</span><br><span class="line">	, <span class="string">&quot;HASH(2)&quot;</span>, <span class="string">&quot;Quick R1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA in */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">sa_pd</span> =</span> md-&gt;chain[ISAKMP_NEXT_SA];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*解析对端选择的SA载荷*/</span></span><br><span class="line">	RETURN_STF_FAILURE(parse_ipsec_sa_body(&amp;sa_pd-&gt;pbs</span><br><span class="line">	    , &amp;sa_pd-&gt;payload.sa, <span class="literal">NULL</span>, TRUE, st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nr in */</span><span class="comment">/*解析对端Nonce载荷*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_v1_nonce(md, &amp;st-&gt;st_nr, <span class="string">&quot;Nr&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [ KE ] in (for PFS) */</span><span class="comment">/*根据配置策略解析对端KE载荷*/</span></span><br><span class="line">    RETURN_STF_FAILURE(accept_PFS_KE(md, &amp;st-&gt;st_gr, <span class="string">&quot;Gr&quot;</span>, <span class="string">&quot;Quick Mode R1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_pfs_group) &#123;<span class="comment">/*如果支持PFS功能，则需要进行DH算法计算*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dh_continuation</span> *<span class="title">dh</span> =</span> alloc_thing(struct dh_continuation</span><br><span class="line">							 , <span class="string">&quot;quick outI2 DH&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* set up DH calculation */</span></span><br><span class="line">		dh-&gt;md = md;</span><br><span class="line">		passert(st != <span class="literal">NULL</span>);</span><br><span class="line">		set_suspended(st, md);</span><br><span class="line">		pcrc_init(&amp;dh-&gt;dh_pcrc);</span><br><span class="line">		dh-&gt;dh_pcrc.pcrc_func = quick_inR1_outI2_continue;</span><br><span class="line">		<span class="keyword">return</span> start_dh_secret(&amp;dh-&gt;dh_pcrc, st</span><br><span class="line">				       , st-&gt;st_import</span><br><span class="line">				       , INITIATOR</span><br><span class="line">				       , st-&gt;st_pfs_group-&gt;group);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* just call the tail function */</span></span><br><span class="line">		struct dh_continuation dh;</span><br><span class="line"></span><br><span class="line">		dh.md=md;</span><br><span class="line">		<span class="keyword">return</span> quick_inR1_outI2_cryptotail(&amp;dh, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-quick-inR1-outI2-cryptotail-源码分析"><a href="#4-quick-inR1-outI2-cryptotail-源码分析" class="headerlink" title="4. quick_inR1_outI2_cryptotail()源码分析"></a>4. quick_inR1_outI2_cryptotail()源码分析</h3><p>接口<code>quick_inR1_outI2_cryptotail()</code>的主要功能如下：</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  ==检验ID载荷收发是否一致==</p>
<p>这里是通过ID载荷来协商IPSec隧道的保护子网信息</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  NAT-T相关处理</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  构造应答报文</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==计算keymats值==</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==建立IPSecSA==</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  ==初始化本隧道的DPD定时器==</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inR1_outI2_cryptotail</span><span class="params">(struct dh_continuation *dh</span></span></span><br><span class="line"><span class="params"><span class="function">			    , struct pluto_crypto_req *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_digest</span> *<span class="title">md</span> =</span> dh-&gt;md;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span> =</span> st-&gt;st_connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_pfs_group != <span class="literal">NULL</span> &amp;&amp; r!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">	finish_dh_secret(st, r);<span class="comment">/*获取密钥信息*/</span></span><br><span class="line">        <span class="keyword">if</span>(!r-&gt;pcr_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> STF_FAIL + INVALID_KEY_INFORMATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [ IDci, IDcr ] in; these must match what we sent */</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">const</span> <span class="title">IDci</span> =</span> md-&gt;chain[ISAKMP_NEXT_ID];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">payload_digest</span> *<span class="title">IDcr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IDci != <span class="literal">NULL</span>)<span class="comment">/*应答报文中包含ID载荷*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* ??? we are assuming IPSEC_DOI */</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* IDci (we are initiator) */</span><span class="comment">/*确定收发ID载荷是否一致*/</span></span><br><span class="line">	    <span class="keyword">if</span> (!check_net_id(&amp;IDci-&gt;payload.ipsec_id, &amp;IDci-&gt;pbs</span><br><span class="line">			      , &amp;st-&gt;st_myuserprotoid, &amp;st-&gt;st_myuserport</span><br><span class="line">			      , &amp;st-&gt;st_connection-&gt;spd.<span class="keyword">this</span></span><br><span class="line">                              , &amp;st-&gt;st_localaddr</span><br><span class="line">			      , <span class="string">&quot;our client&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* we checked elsewhere that we got two of them */</span></span><br><span class="line">	    IDcr = IDci-&gt;next;<span class="comment">/*响应端ID载荷是否匹配*/</span></span><br><span class="line">	    passert(IDcr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* IDcr (responder is peer) */</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!check_net_id(&amp;IDcr-&gt;payload.ipsec_id, &amp;IDcr-&gt;pbs</span><br><span class="line">			      , &amp;st-&gt;st_peeruserprotoid, &amp;st-&gt;st_peeruserport</span><br><span class="line">			      , &amp;st-&gt;st_connection-&gt;spd.that</span><br><span class="line">                              , &amp;st-&gt;st_remoteaddr</span><br><span class="line">			      , <span class="string">&quot;peer client&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	     * if there is a NATOA payload, then use it as</span></span><br><span class="line"><span class="comment">	     *    &amp;st-&gt;st_connection-&gt;spd.that.client, if the type</span></span><br><span class="line"><span class="comment">	     * of the ID was FQDN</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">	... ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">/* no IDci, IDcr: we must check that the defaults match our proposal */</span></span><br><span class="line">	    <span class="keyword">if</span> (!subnetisaddr(&amp;c-&gt;spd.<span class="keyword">this</span>.client, &amp;c-&gt;spd.<span class="keyword">this</span>.host_addr)<span class="comment">/*两个地址一样即可*/</span></span><br><span class="line">		|| !subnetisaddr(&amp;c-&gt;spd.that.client, &amp;c-&gt;spd.that.host_addr))</span><br><span class="line">	    &#123;</span><br><span class="line">		loglog(RC_LOG_SERIOUS, <span class="string">&quot;IDci, IDcr payloads missing in message&quot;</span></span><br><span class="line">		    <span class="string">&quot; but default does not match proposal&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> STF_FAIL + INVALID_ID_INFORMATION;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************** build reply packet HDR*, HASH(3) ****************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out done ISAKMP头部已经填充完毕*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(3) out -- sometimes, we add more content */</span></span><br><span class="line">    &#123;</span><br><span class="line">	u_char	<span class="comment">/* set by START_HASH_PAYLOAD: */</span></span><br><span class="line">	    *r_hashval,	<span class="comment">/* where in reply to jam hash value */</span></span><br><span class="line">	    *r_hash_start;      <span class="comment">/* start of what is to be hashed */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*填充hash载荷*/</span></span><br><span class="line">	START_HASH_PAYLOAD(md-&gt;rbody, ISAKMP_NEXT_NONE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*计算哈希载荷值，用于对端检测报文的完整性*/</span></span><br><span class="line">	(<span class="keyword">void</span>)quick_mode_hash3(r_hashval, st);</span><br><span class="line">        r_hash_start = r_hash_start;   <span class="comment">/* otherwise complaint about never used */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Derive new keying material */</span><span class="comment">/*计算密钥生成材料*/</span></span><br><span class="line">    compute_keymats(st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tell the kernel to establish the inbound, outbound, and routing part</span></span><br><span class="line"><span class="comment">     * of the new SA (unless the commit bit is set -- which we don&#x27;t support).</span></span><br><span class="line"><span class="comment">     * We do this before any state updating so that</span></span><br><span class="line"><span class="comment">     * failure won&#x27;t look like success.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!install_ipsec_sa(md-&gt;pst, st, TRUE))<span class="comment">/*建立IPsecSA*/</span></span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line">	<span class="comment">/*加密*/</span></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;md-&gt;rbody, st))</span><br><span class="line">    &#123;</span><br><span class="line">        delete_ipsec_sa(st, FALSE);</span><br><span class="line">        <span class="keyword">return</span> STF_INTERNAL_ERROR;	<span class="comment">/* ??? we may be partly committed */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_connection-&gt;newest_ipsec_sa = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note (presumed) success */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;gw_info != <span class="literal">NULL</span>)</span><br><span class="line">	c-&gt;gw_info-&gt;key-&gt;last_worked_time = now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have dpd delay and dpdtimeout set, then we are doing DPD</span></span><br><span class="line"><span class="comment">	on this conn, so initialize it */</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_connection-&gt;dpd_delay &amp;&amp; st-&gt;st_connection-&gt;dpd_timeout) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dpd_init(st) != STF_OK) &#123;<span class="comment">/*启动DPD定时器*/</span></span><br><span class="line">            delete_ipsec_sa(st, FALSE);</span><br><span class="line">            <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-compute-keymats-源码分析"><a href="#4-compute-keymats-源码分析" class="headerlink" title="4. compute_keymats()源码分析"></a>4. compute_keymats()源码分析</h3><p><code>compute_keymats()</code>是一个很重的函数，功能是第二阶段计算生成密钥材料，它的计算方式如下：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 如果启用PFS功能：</li>
</ul>
<p>$$<br>KEYMATS = PRF(SKEYSTR-d, g^{xy} | protocol | SPI | Ni-b |Nr-b   )<br>$$</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 未用PFS功能：</li>
</ul>
<p>$$<br>KEYMATS = PRF(SKEYSTR-d, protocol | SPI | Ni-b |Nr-b   )<br>$$</p>
<p>需要注意的是：</p>
<ul>
<li>$g^{xy}$是第二阶段通过额外的DH交换计算得到的(==DH计算出的共享秘钥==)，存储在<code>st-&gt;st_shared</code>中。此变量虽然在第一阶段时也有生成，但是第二阶段使用了第一阶段复制的state状态，并未使用第一阶段中的<code>st_shared</code>的值，因此第二阶段的<code>st-&gt;st_shared</code>只有在进行额外的DH交换后才会生成，且不会使用第一阶段的共享密钥的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">compute_keymats</span><span class="params">(struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_ah.present)</span><br><span class="line">	compute_proto_keymat(st, PROTO_IPSEC_AH, &amp;st-&gt;st_ah, <span class="string">&quot;AH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_esp.present)</span><br><span class="line">	compute_proto_keymat(st, PROTO_IPSEC_ESP, &amp;st-&gt;st_esp, <span class="string">&quot;ESP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Produce the new key material of Quick Mode.</span></span><br><span class="line"><span class="comment"> * RFC 2409 &quot;IKE&quot; section 5.5</span></span><br><span class="line"><span class="comment"> * specifies how this is to be done.</span></span><br><span class="line"><span class="comment"> *###############################################</span></span><br><span class="line"><span class="comment"> *	compute_proto_keymat非常重要的密钥协商函数</span></span><br><span class="line"><span class="comment"> *###############################################</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">compute_proto_keymat</span><span class="params">(struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">u_int8_t</span> protoid</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct ipsec_proto_info *pi</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">const</span> <span class="keyword">char</span> *satypename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> needed_len = <span class="number">0</span>; <span class="comment">/* bytes of keying material needed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add up the requirements for keying material</span></span><br><span class="line"><span class="comment">     * (It probably doesn&#x27;t matter if we produce too much!)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (protoid)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PROTO_IPSEC_ESP:</span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.encrypt)<span class="comment">/*加密算法*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	    <span class="keyword">case</span> ESP_NULL:</span><br><span class="line">			needed_len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_DES:</span><br><span class="line">			needed_len = DES_CBC_BLOCK_SIZE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_3DES:</span><br><span class="line">			needed_len = DES_CBC_BLOCK_SIZE * <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> ESP_AES:</span><br><span class="line">			needed_len = AES_CBC_BLOCK_SIZE;</span><br><span class="line">			<span class="comment">/* if an attribute is set, then use that! */</span></span><br><span class="line">			<span class="keyword">if</span>(st-&gt;st_esp.attrs.transattrs.enckeylen) &#123;<span class="comment">/*如果属性载荷设置了此参数，则使用此参数的值*/</span></span><br><span class="line">			    needed_len = st-&gt;st_esp.attrs.transattrs.enckeylen/<span class="number">8</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">			<span class="keyword">if</span>((needed_len=kernel_alg_esp_enc_keylen(pi-&gt;attrs.transattrs.encrypt))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">/* <span class="doctag">XXX:</span> check key_len &quot;coupling with kernel.c&#x27;s */</span></span><br><span class="line">				<span class="keyword">if</span> (pi-&gt;attrs.transattrs.enckeylen) &#123;</span><br><span class="line">					needed_len=pi-&gt;attrs.transattrs.enckeylen/<span class="number">8</span>;</span><br><span class="line">					DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">							<span class="string">&quot;key_len=%d from peer&quot;</span>,</span><br><span class="line">							(<span class="keyword">int</span>)needed_len));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.encrypt);</span><br><span class="line">	    &#125;</span><br><span class="line">	    DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">				     <span class="string">&quot;needed_len (after ESP enc)=%d&quot;</span>,</span><br><span class="line">				     (<span class="keyword">int</span>)needed_len));</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.integ_hash)<span class="comment">/*哈希算法*/</span></span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_NONE:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_HMAC_MD5:</span><br><span class="line">			needed_len += HMAC_MD5_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_HMAC_SHA1:</span><br><span class="line">			needed_len += HMAC_SHA1_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">		      <span class="keyword">if</span> (kernel_alg_esp_auth_ok(pi-&gt;attrs.transattrs.integ_hash, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			  needed_len += kernel_alg_esp_auth_keylen(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">		      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		    <span class="keyword">case</span> AUTH_ALGORITHM_DES_MAC:</span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	    DBG(DBG_PARSING, DBG_log(<span class="string">&quot;compute_proto_keymat:&quot;</span></span><br><span class="line">				    <span class="string">&quot;needed_len (after ESP auth)=%d&quot;</span>,</span><br><span class="line">				    (<span class="keyword">int</span>)needed_len));</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PROTO_IPSEC_AH:</span><br><span class="line">	    <span class="keyword">switch</span> (pi-&gt;attrs.transattrs.encrypt)</span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="keyword">case</span> AH_MD5:</span><br><span class="line">			needed_len = HMAC_MD5_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> AH_SHA:</span><br><span class="line">			needed_len = HMAC_SHA1_KEY_LEN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL_ALG</span></span><br><span class="line">			<span class="keyword">if</span> (kernel_alg_ah_auth_ok(pi-&gt;attrs.transattrs.integ_hash, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			    needed_len += kernel_alg_ah_auth_keylen(pi-&gt;attrs.transattrs.integ_hash);</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			bad_case(pi-&gt;attrs.transattrs.encrypt);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	bad_case(protoid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将所有算法需要的密钥长度全部相加，从而生成所需长度的密钥材料*/</span></span><br><span class="line"></span><br><span class="line">    pi-&gt;keymat_len = needed_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate space for the keying material.</span></span><br><span class="line"><span class="comment">     * Although only needed_len bytes are desired, we</span></span><br><span class="line"><span class="comment">     * must round up to a multiple of ctx.hmac_digest_len</span></span><br><span class="line"><span class="comment">     * so that our buffer isn&#x27;t overrun.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx_me</span>, <span class="title">ctx_peer</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> needed_space;	<span class="comment">/* space needed for keying material (rounded up) */</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">	hmac_init_chunk(&amp;ctx_me, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_d);</span><br><span class="line"></span><br><span class="line">	ctx_peer = ctx_me;	<span class="comment">/* duplicate initial conditions */</span></span><br><span class="line">	needed_space = needed_len + pad_up(needed_len, ctx_me.hmac_digest_len);</span><br><span class="line">	replace(pi-&gt;our_keymat, alloc_bytes(needed_space, <span class="string">&quot;keymat in compute_keymat()&quot;</span>));</span><br><span class="line">	replace(pi-&gt;peer_keymat, alloc_bytes(needed_space, <span class="string">&quot;peer_keymat in quick_inI1_outR1()&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 准备计算秘钥所需的所有材料</span></span><br><span class="line"><span class="comment">*	1. DH交换生成的共享秘钥</span></span><br><span class="line"><span class="comment">*	2. 协议protocol</span></span><br><span class="line"><span class="comment">*	3. SPI</span></span><br><span class="line"><span class="comment">*	4. Ni_b</span></span><br><span class="line"><span class="comment">*	5. Nr_b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;; )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*1. DH交换生成的共享秘钥*/</span></span><br><span class="line">	    <span class="keyword">if</span> (st-&gt;st_shared.ptr != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">            <span class="comment">/* PFS: include the g^xy */</span></span><br><span class="line">            hmac_update_chunk(&amp;ctx_me, st-&gt;st_shared);</span><br><span class="line">            hmac_update_chunk(&amp;ctx_peer, st-&gt;st_shared);</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="comment">/*2. 协议protocol*/</span></span><br><span class="line">	    hmac_update(&amp;ctx_me, &amp;protoid, <span class="keyword">sizeof</span>(protoid));</span><br><span class="line">	    hmac_update(&amp;ctx_peer, &amp;protoid, <span class="keyword">sizeof</span>(protoid));</span><br><span class="line">		<span class="comment">/*3. SPI*/</span></span><br><span class="line">	    hmac_update(&amp;ctx_me, (u_char *)&amp;pi-&gt;our_spi, <span class="keyword">sizeof</span>(pi-&gt;our_spi));</span><br><span class="line">	    hmac_update(&amp;ctx_peer, (u_char *)&amp;pi-&gt;attrs.spi, <span class="keyword">sizeof</span>(pi-&gt;attrs.spi));</span><br><span class="line">		<span class="comment">/*4. Ni_b*/</span></span><br><span class="line">	    hmac_update_chunk(&amp;ctx_me, st-&gt;st_ni);</span><br><span class="line">	    hmac_update_chunk(&amp;ctx_peer, st-&gt;st_ni);</span><br><span class="line">		<span class="comment">/*5. Nr_b*/</span></span><br><span class="line">	    hmac_update_chunk(&amp;ctx_me, st-&gt;st_nr);</span><br><span class="line">	    hmac_update_chunk(&amp;ctx_peer, st-&gt;st_nr);</span><br><span class="line"></span><br><span class="line">	    hmac_final(pi-&gt;our_keymat + i, &amp;ctx_me);</span><br><span class="line">	    hmac_final(pi-&gt;peer_keymat + i, &amp;ctx_peer);</span><br><span class="line"></span><br><span class="line">	    i += ctx_me.hmac_digest_len;</span><br><span class="line">	    <span class="keyword">if</span> (i &gt;= needed_space)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* more keying material needed: prepare to go around again */</span></span><br><span class="line">	    hmac_reinit(&amp;ctx_me);</span><br><span class="line">	    hmac_reinit(&amp;ctx_peer);</span><br><span class="line"></span><br><span class="line">	    hmac_update(&amp;ctx_me, pi-&gt;our_keymat + i - ctx_me.hmac_digest_len, ctx_me.hmac_digest_len);</span><br><span class="line">	    hmac_update(&amp;ctx_peer, pi-&gt;peer_keymat + i - ctx_peer.hmac_digest_len, ctx_peer.hmac_digest_len);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*双方能计算出对端的密钥材料信息???*/</span></span><br><span class="line">    DBG(DBG_CRYPT,</span><br><span class="line">	DBG_log(<span class="string">&quot;%s KEYMAT\n&quot;</span>,satypename);</span><br><span class="line">	DBG_dump(<span class="string">&quot;  KEYMAT computed:\n&quot;</span>, pi-&gt;our_keymat, pi-&gt;keymat_len);</span><br><span class="line">	DBG_dump(<span class="string">&quot;  Peer KEYMAT computed:\n&quot;</span>, pi-&gt;peer_keymat, pi-&gt;keymat_len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-dpd-init-源码分析"><a href="#5-dpd-init-源码分析" class="headerlink" title="5. dpd_init()源码分析"></a>5. dpd_init()源码分析</h3><p>DPD功能对应有两个事件：</p>
<ul>
<li><p><strong>EVENT_DPD_TIMEOUT</strong></p>
<p>第一阶段的定时器，在第二阶段已经断开的情况下，用来检测第一阶段是否超时</p>
</li>
<li><p><strong>DPD_EVENT</strong></p>
<p>第二阶段的定时器，长时间未通讯时断开连接，并启动第一阶段的定时器</p>
</li>
</ul>
<p>这个定时器机制实际使用时会复杂一点。可以参考注释说明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize RFC 3706 Dead Peer Detection</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param st An initialized state structure</span></span><br><span class="line"><span class="comment"> * @return void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * How DPD works.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are two kinds of events that can be scheduled.</span></span><br><span class="line"><span class="comment"> * At most one of them is schedule at any given time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The EVENT_DPD_TIMEOUT event, if it ever goes off, means that</span></span><br><span class="line"><span class="comment"> * neither the ISAKMP SA nor the IPsec SA has *RECEIVED* any DPD</span></span><br><span class="line"><span class="comment"> * events lately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0) So, every time we receive a DPD (R_U_THERE or R_U_ACK), then</span></span><br><span class="line"><span class="comment"> *    we delete any DPD event (EVENT_DPD or EVENT_DPD_TIMEOUT), and</span></span><br><span class="line"><span class="comment"> *    we schedule a new DPD_EVENT (sending) for &quot;delay&quot; in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) When the DPD_EVENT goes off, we check the phase 2 (if there is one)</span></span><br><span class="line"><span class="comment"> *    SA to see if there was incoming traffic. If there was, then we are happy,</span></span><br><span class="line"><span class="comment"> *    we set a new DPD_EVENT, and we are done.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2) If there was no phase 2 activity, we check if there was a recent enough</span></span><br><span class="line"><span class="comment"> *    DPD activity (st-&gt;st_last_dpd). If so, we just reschedule, and do</span></span><br><span class="line"><span class="comment"> *    nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3) Otherwise, we send a DPD R_U_THERE message, and set the</span></span><br><span class="line"><span class="comment"> *    EVENT_DPD_TIMEOUT on the phase 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * One thing to realize when looking at &quot;ipsec whack --listevents&quot; output,</span></span><br><span class="line"><span class="comment"> * is there there will only be DPD_EVENT_TIMEOUT events if there are</span></span><br><span class="line"><span class="comment"> * outstanding R_U_THERE messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above is the basic idea, but things are a bit more complicated because</span></span><br><span class="line"><span class="comment"> * multiple phase 2s can share the same phase 1 ISAKMP SA. Each phase 2 state</span></span><br><span class="line"><span class="comment"> * has its own DPD_EVENT. Further, we start a DPD_EVENT for phase 1 when it</span></span><br><span class="line"><span class="comment"> * gets established. This is because the phase 2 may never actually succeed</span></span><br><span class="line"><span class="comment"> * (usually due to authorization issues, which may be DNS or otherwise related)</span></span><br><span class="line"><span class="comment"> * and if the responding end dies (gets restarted, or the conn gets reloaded</span></span><br><span class="line"><span class="comment"> * with the right policy), then we may have a bum phase 1 SA, and we can not</span></span><br><span class="line"><span class="comment"> * re-negotiate. (This happens WAY too often)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The phase 2 dpd_init() will attempt to kill the phase 1 DPD_EVENT, if it</span></span><br><span class="line"><span class="comment"> * can, to reduce the amount of work.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The st_last_dpd member which is used is always the one from the phase 1.</span></span><br><span class="line"><span class="comment"> * So, if there are multiple phase 2s, then if any of them receive DPD data</span></span><br><span class="line"><span class="comment"> * they will update the st_last_dpd, so the test in #2 will avoid the traffic</span></span><br><span class="line"><span class="comment"> * for all by one phase 2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the EVENT_DPD are attached to phase 2s (typically), while the</span></span><br><span class="line"><span class="comment"> * EVENT_DPD_TIMEOUT are attached to phase 1s only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally, if the connection is using NAT-T, then we ignore the phase 2</span></span><br><span class="line"><span class="comment"> * activity check, because in the case of a unidirectional stream (VoIP for</span></span><br><span class="line"><span class="comment"> * a conference call, for instance), we may not send enough traffic to keep</span></span><br><span class="line"><span class="comment"> * the NAT port mapping valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">dpd_init</span><span class="params">(struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used to store the 1st state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_connection-&gt;loopback) &#123;</span><br><span class="line">            openswan_log(<span class="string">&quot;dpd is not required for ipsec connections over loopback&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> STF_OK;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">p1st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find the related Phase 1 state */</span></span><br><span class="line">    p1st = find_state_ikev1(st-&gt;st_icookie, st-&gt;st_rcookie,</span><br><span class="line">		      &amp;st-&gt;st_connection-&gt;spd.that.host_addr, <span class="number">0</span>);<span class="comment">/*第一阶段的msgid为0*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        loglog(RC_LOG_SERIOUS, <span class="string">&quot;could not find phase 1 state for DPD&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if the phase 1 state has gone away, it really should have</span></span><br><span class="line"><span class="comment">	 * deleted all of its children.</span></span><br><span class="line"><span class="comment">	 * Why would this happen? because a quick mode SA can take</span></span><br><span class="line"><span class="comment">	 * some time to create (DNS lookups for instance), and the phase 1</span></span><br><span class="line"><span class="comment">	 * might have been taken down for some reason in the meantime.</span></span><br><span class="line"><span class="comment">	 * We really can not do anything here --- attempting to invoke</span></span><br><span class="line"><span class="comment">	 * the DPD action would be a good idea, but we really should</span></span><br><span class="line"><span class="comment">	 * do that outside this function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> STF_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it was enabled, and we haven&#x27;t turned it on already */</span></span><br><span class="line">    <span class="keyword">if</span> (p1st-&gt;hidden_variables.st_dpd) &#123;</span><br><span class="line">	<span class="keyword">time_t</span> n = now();</span><br><span class="line">	openswan_log(<span class="string">&quot;Dead Peer Detection (RFC 3706): enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;st_dpd_event == <span class="literal">NULL</span> || (st-&gt;st_connection-&gt;dpd_delay + n) &lt; st-&gt;st_dpd_event-&gt;ev_time) &#123;</span><br><span class="line">	    delete_dpd_event(st);</span><br><span class="line">	    event_schedule(EVENT_DPD, st-&gt;st_connection-&gt;dpd_delay, st);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      openswan_log(<span class="string">&quot;Dead Peer Detection (RFC 3706): not enabled because peer did not advertise it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1st != st) &#123;<span class="comment">/*第一阶段的DPD_EVENT事件已经没有必要，可以进行删除了，第二阶段会有自己的DPD_EVENT*/</span></span><br><span class="line">	<span class="comment">/* st was not a phase 1 SA, so kill the DPD_EVENT on the phase 1 */</span></span><br><span class="line">	<span class="keyword">if</span>(p1st-&gt;st_dpd_event != <span class="literal">NULL</span></span><br><span class="line">	   &amp;&amp; p1st-&gt;st_dpd_event-&gt;ev_type == EVENT_DPD) &#123;</span><br><span class="line">	    delete_dpd_event(p1st);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-install-ipsec-sa-源码分析"><a href="#6-install-ipsec-sa-源码分析" class="headerlink" title="6. install_ipsec_sa()源码分析"></a>6. install_ipsec_sa()源码分析</h3><p>略。<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205907.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>快速模式第三包收尾之quick_inI2()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%89%E5%8C%85-2%20quick_inI2()/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205321.png" alt="image-20200913162318278"></p>
<span id="more"></span>
<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p>快速模式有三个报文交换，四个核心函数入口。我们已经对前三个函数处理流程对了一个简单的学习和这里，下面对第四个函数入口<code>quick_inI2()</code>的处理流程做一个简单的介绍。</p>
<p>首先需要说明的是快速模式的前两个报文是为了协商感兴趣流的相关参数(如使用的加密算法、认证算法、封装方式、感兴趣流以及生成相关的密钥信息等)，而第三个报文则简单了很多：只是为了对前两个报文做认证。那么自然而然引出一个问题：为什么需要第三个报文呢？前两个报文不是已经包含HASH杂凑载荷吗？ 供大家思考吧。</p>
<h3 id="2-quick-inI2-处理流程图"><a href="#2-quick-inI2-处理流程图" class="headerlink" title="2.  quick_inI2()处理流程图"></a>2.  quick_inI2()处理流程图</h3><p><code>quick_inI2()</code>的处理流程很简单，其中最主要的便是建立出站IPsecSA。（如果IPsec处理流程都是这种精简的，该多好呀:) :) ）</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205604.png" alt="image-20200913164700196"></p>
<h3 id="3-报文格式"><a href="#3-报文格式" class="headerlink" title="3.  报文格式"></a>3.  报文格式</h3><p><code>quick_inR1_outI2()</code>和<code>quick_inI2()</code>都是用来处理快速模式最后一个包的，报文格式完全一致。，<code>quick_inR1_outI2()</code>包括发送处理流程，而<code>quick_inI2()</code>则只为处理接收流程。</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205602.png" alt="图片1"></p>
<h3 id="4-quick-inI2-源码"><a href="#4-quick-inI2-源码" class="headerlink" title="4.  quick_inI2()源码"></a>4.  quick_inI2()源码</h3><p>这个源码主要流程很清晰（除了建立IPsecSA），代码也很少。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle last message of Quick Mode.</span></span><br><span class="line"><span class="comment"> * HDR*, HASH(3) -&gt; done</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5)</span></span><br><span class="line"><span class="comment"> * Installs outbound IPsec SAs, routing, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_inI2</span><span class="params">(struct msg_digest *md)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> md-&gt;st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HASH(3) in */</span><span class="comment">/*验证哈希报文完整性*/</span></span><br><span class="line">    CHECK_QUICK_HASH(md, quick_mode_hash3(hash_val, st)</span><br><span class="line">	, <span class="string">&quot;HASH(3)&quot;</span>, <span class="string">&quot;Quick I2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tell the kernel to establish the outbound and routing part of the new SA</span></span><br><span class="line"><span class="comment">     * (the previous state established inbound)</span></span><br><span class="line"><span class="comment">     * (unless the commit bit is set -- which we don&#x27;t support).</span></span><br><span class="line"><span class="comment">     * We do this before any state updating so that</span></span><br><span class="line"><span class="comment">     * failure won&#x27;t look like success.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!install_ipsec_sa(md-&gt;pst, st, FALSE))</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      DBG(DBG_CONTROLMORE, DBG_log(<span class="string">&quot;inI2: instance %s[%ld], setting newest_ipsec_sa to #%ld (was #%ld) (spd.eroute=#%ld)&quot;</span></span><br><span class="line">			       , st-&gt;st_connection-&gt;name</span><br><span class="line">			       , st-&gt;st_connection-&gt;instance_serial</span><br><span class="line">			       , st-&gt;st_serialno</span><br><span class="line">			       , st-&gt;st_connection-&gt;newest_ipsec_sa</span><br><span class="line">			       , st-&gt;st_connection-&gt;spd.eroute_owner));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_connection-&gt;newest_ipsec_sa = st-&gt;st_serialno;</span><br><span class="line"></span><br><span class="line">    update_iv(st);	<span class="comment">/* not actually used, but tidy */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note (presumed) success */</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gw_info</span> *<span class="title">gw</span> =</span> st-&gt;st_connection-&gt;gw_info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gw != <span class="literal">NULL</span>)</span><br><span class="line">	    gw-&gt;key-&gt;last_worked_time = now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have dpd delay and dpdtimeout set, then we are doing DPD</span></span><br><span class="line"><span class="comment">	on this conn, so initialize it */</span></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;dpd_delay &amp;&amp; st-&gt;st_connection-&gt;dpd_timeout) &#123;</span><br><span class="line">	<span class="keyword">if</span>(dpd_init(st) != STF_OK) &#123;</span><br><span class="line">	    delete_ipsec_sa(st, FALSE);</span><br><span class="line">	    <span class="keyword">return</span> STF_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-其他接口说明"><a href="#4-其他接口说明" class="headerlink" title="4.  其他接口说明"></a>4.  其他接口说明</h3><h4 id="4-1-hash载荷计算方式"><a href="#4-1-hash载荷计算方式" class="headerlink" title="4.1  hash载荷计算方式"></a>4.1  hash载荷计算方式</h4><p>快速模式虽然仅有三个报文交互，但是它们的hash杂凑载荷的计算方式却不相同：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 第①包计算方式：<br>$$<br>HASH(1) = PRF(SKEYID-a, MsgID | SA | Ni | [| IDi | IDr ])<br>$$</li>
<li><input checked="" disabled="" type="checkbox"> 第②包计算方式：<br>$$<br>HASH(2) = PRF(SKEYID-a, MsgID | Ni | SA | Nr |      [| IDi | IDr ])<br>$$</li>
<li><input checked="" disabled="" type="checkbox"> 第③包计算方式：</li>
</ul>
<p>$$<br>HASH(3) = PRF(SKEYID-a, 0 | MsgID | Ni | Nr)<br>$$</p>
<hr>
<ul>
<li><p>第①包实现方式和第②包实现方式为同一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute HASH(1), HASH(2) of Quick Mode.</span></span><br><span class="line"><span class="comment"> * HASH(1) is part of Quick I1 message.</span></span><br><span class="line"><span class="comment"> * HASH(2) is part of Quick R1 message.</span></span><br><span class="line"><span class="comment"> * Used by: quick_outI1, quick_inI1_outR1 (twice), quick_inR1_outI2</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5, pg. 18 or draft-ietf-ipsec-ike-01.txt 6.2 pg 25)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span></span></span><br><span class="line"><span class="function"><span class="title">quick_mode_hash12</span><span class="params">(u_char *dest, <span class="keyword">const</span> u_char *start, <span class="keyword">const</span> u_char *roof</span></span></span><br><span class="line"><span class="params"><span class="function">, <span class="keyword">const</span> struct state *st, <span class="keyword">const</span> <span class="keyword">msgid_t</span> *msgid, <span class="keyword">bool</span> hash2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    hmac_init_chunk(&amp;ctx, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_a);<span class="comment">/*PRF算法 + 认证秘钥*/</span></span><br><span class="line">    </span><br><span class="line">    hmac_update(&amp;ctx, (<span class="keyword">const</span> <span class="keyword">void</span> *) msgid, <span class="keyword">sizeof</span>(<span class="keyword">msgid_t</span>));<span class="comment">/*填充msgid，由于认证需要msgid，而它唯一*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hash2)</span><br><span class="line">		hmac_update_chunk(&amp;ctx, st-&gt;st_ni);	<span class="comment">/* include Ni_b in the hash */</span></span><br><span class="line">    </span><br><span class="line">    hmac_update(&amp;ctx, start, roof-start);<span class="comment">/*数据起始位置和终止位置*/</span></span><br><span class="line">    hmac_final(dest, &amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx.hmac_digest_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第③包实现方式：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute HASH(3) in Quick Mode (part of Quick I2 message).</span></span><br><span class="line"><span class="comment"> * Used by: quick_inR1_outI2, quick_inI2</span></span><br><span class="line"><span class="comment"> * See RFC2409 &quot;The Internet Key Exchange (IKE)&quot; 5.5.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this hash (unlike HASH(1) and HASH(2)) ONLY covers the</span></span><br><span class="line"><span class="comment"> * Message ID and Nonces.  This is a mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span></span></span><br><span class="line"><span class="function"><span class="title">quick_mode_hash3</span><span class="params">(u_char *dest, struct state *st)</span><span class="comment">/*第二阶段的三个报文hash值算法方式各不相同*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmac_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    hmac_init_chunk(&amp;ctx, st-&gt;st_oakley.prf_hasher, st-&gt;st_skeyid_a);</span><br><span class="line">    hmac_update(&amp;ctx, (<span class="keyword">const</span> u_char *)<span class="string">&quot;\0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    hmac_update(&amp;ctx, (u_char *) &amp;st-&gt;st_msgid, <span class="keyword">sizeof</span>(st-&gt;st_msgid));</span><br><span class="line">    hmac_update_chunk(&amp;ctx, st-&gt;st_ni);</span><br><span class="line">    hmac_update_chunk(&amp;ctx, st-&gt;st_nr);</span><br><span class="line">    hmac_final(dest, &amp;ctx);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;HASH(3) computed:&quot;</span>, dest, ctx.hmac_digest_len);</span><br><span class="line">    <span class="keyword">return</span> ctx.hmac_digest_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-install-ipsec-sa"><a href="#4-2-install-ipsec-sa" class="headerlink" title="4.2  install_ipsec_sa"></a>4.2  install_ipsec_sa</h4><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205609.gif" alt="timg22" style="zoom:50%;" />

<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205624.jpg" alt="img"></p>
<p>IPsec协商流程之主模式+快速模式学习跨度比较久（3个月多），协商流程却是很复杂，而且只是看原理性知识，很多功能都没有敢去涉及，如证书认证、out_sa、 DPD、建立IPsecSA、NAT-T等等。学习期间最主要的体会是：openswan封装了很多很多接口，常用接口需要好好学习，否则在看代码时很困难。就拿<code>out_sa</code> 、<code>out_struct</code>、<code>out_generic</code>等系列，能恶心死人，全文基本都用这几个接口在封装报文和解封装报文，可以说这些基本函数是看openswan源码的接口。</p>
<p>后面计划继续更新几个函数接口实现，也是以前学习整理过程中遗留的坑，先填几个然后在更新学习其他流程。</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>快速模式第一包之quick_outI1()</title>
    <url>/blogs/2021/11/20/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1/</url>
    <content><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h3><p>openswan源码中有关隧道协商的文章已经比较久没有更新了，那么从这篇开始再重新回到更新流程上。这中间停了将近2个月，第一个月几乎没有更新任何博客，而第二个月主要整理翻译QAT相关的文章，接下来我将继续更新openswan源码相关的内容。</p>
<p>下面开始介绍IPSec 快速模式协商流程中的第①包，主要函数的入口为**quick_outI1()**：</p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205311.png" alt="image-20200826002057928"></p>
<h3 id="2-quick-outI1-流程图"><a href="#2-quick-outI1-流程图" class="headerlink" title="2. quick_outI1()流程图"></a>2. quick_outI1()流程图</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120205313.png" alt="image-20200826003329910"></p>
<h3 id="3-quick-outI1-源码分析"><a href="#3-quick-outI1-源码分析" class="headerlink" title="3. quick_outI1()源码分析"></a>3. quick_outI1()源码分析</h3><p><code>quick_outI1()</code>接口是第二阶段快速模式第一包的入口函数，它最主要的工作就是将==第一阶段协商的ipsecsa状态信息转换为第二阶段的状态信息==。通过<code>duplicate_state</code>实现状态的拷贝，然后将新的状态插入到全局的状态表中。之后就是根据隧道的配置信息(PFS, 算法信息)等做秘钥申请等准备工作。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>复制第一阶段ipsecsa状态，并将其插入全局状态表中</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>显示第二阶段算法相关的debug信息</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>根据配置做秘钥申请</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_outI1</span><span class="params">(<span class="keyword">int</span> whack_sock</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct state *isakmp_sa</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct connection *c</span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">lset_t</span> policy</span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">try</span></span></span></span><br><span class="line"><span class="params"><span class="function">	    , <span class="keyword">so_serial_t</span> replacing</span></span></span><br><span class="line"><span class="params"><span class="function">	    , struct xfrm_user_sec_ctx_ike * uctx UNUSED</span></span></span><br><span class="line"><span class="params"><span class="function">	    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span> =</span> duplicate_state(isakmp_sa);<span class="comment">/*复制第一阶段的状态,包括了所有的基本信息*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span>;</span></span><br><span class="line">    stf_status e;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pfsgroupname;</span><br><span class="line">    <span class="keyword">char</span> p2alg[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    st-&gt;st_whack_sock = whack_sock;</span><br><span class="line">    st-&gt;st_connection = c;<span class="comment">/*从这里可以看出每一个连接c可对应多个state结构，比如一个phase1,一个phase2.因此在隧道状态时需要特别注意*/</span></span><br><span class="line">    passert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_calculating) &#123;</span><br><span class="line">	<span class="keyword">return</span> STF_IGNORE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* we must reset before exit */</span></span><br><span class="line">    st-&gt;st_policy = policy;</span><br><span class="line">    st-&gt;st_try = <span class="keyword">try</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_LABELED_IPSEC</span></span><br><span class="line">    st-&gt;sec_ctx=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(uctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    st-&gt;sec_ctx = clone_thing(*uctx, <span class="string">&quot;sec ctx structure&quot;</span>);</span><br><span class="line">    DBG(DBG_CONTROL, DBG_log(<span class="string">&quot;pending phase 2 with security context %s, %d&quot;</span>, st-&gt;sec_ctx-&gt;sec_ctx_value, st-&gt;sec_ctx-&gt;ctx_len));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*本端协议、对端协议、本端端口、对端端口*/</span></span><br><span class="line">    st-&gt;st_myuserprotoid   = c-&gt;spd.<span class="keyword">this</span>.protocol;</span><br><span class="line">    st-&gt;st_peeruserprotoid = c-&gt;spd.that.protocol;</span><br><span class="line">    st-&gt;st_myuserport       = c-&gt;spd.<span class="keyword">this</span>.port;</span><br><span class="line">    st-&gt;st_peeruserport     = c-&gt;spd.that.port;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_msgid = generate_msgid(isakmp_sa);<span class="comment">/*随机生成唯一的msgid*/</span></span><br><span class="line">    change_state(st, STATE_QUICK_I1);<span class="comment">/*设置当前状态为STATE_QUICK_I1*/</span></span><br><span class="line"></span><br><span class="line">    insert_state(st);	<span class="comment">/* needs cookies, connection, and msgid */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(p2alg, <span class="string">&quot;defaults&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;st_connection-&gt;alg_info_esp) &#123;<span class="comment">/*将alg_info_esp中的算法(第二阶段算法信息)解析转换为字符串，存储在p2alg*/</span></span><br><span class="line">	alg_info_snprint_phase2(p2alg, <span class="keyword">sizeof</span>(p2alg)<span class="comment">/*只是为了显示使用*/</span></span><br><span class="line">				, (struct alg_info_esp *)st-&gt;st_connection-&gt;alg_info_esp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pfsgroupname=<span class="string">&quot;no-pfs&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * See if pfs_group has been specified for this conn,</span></span><br><span class="line"><span class="comment">     * if not, fallback to old use-same-as-P1 behaviour</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;st_connection) &#123;<span class="comment">/*获取pfs组*/</span></span><br><span class="line">	st-&gt;st_pfs_group = ike_alg_pfsgroup(st-&gt;st_connection</span><br><span class="line">					    , st-&gt;st_policy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If PFS specified, use the same group as during Phase 1:</span></span><br><span class="line"><span class="comment">     * since no negotiation is possible, we pick one that is</span></span><br><span class="line"><span class="comment">     * very likely supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!st-&gt;st_pfs_group)</span><br><span class="line">	    st-&gt;st_pfs_group = policy &amp; POLICY_PFS? isakmp_sa-&gt;st_oakley.group : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(policy &amp; POLICY_PFS &amp;&amp; st-&gt;st_pfs_group) &#123;</span><br><span class="line">	pfsgroupname = enum_name(&amp;oakley_group_names, st-&gt;st_pfs_group-&gt;group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">char</span> replacestr[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	replacestr[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(replacing != SOS_NOBODY)</span><br><span class="line">	    <span class="built_in">snprintf</span>(replacestr, <span class="number">32</span>, <span class="string">&quot; to replace #%lu&quot;</span>, replacing);</span><br><span class="line"></span><br><span class="line">	openswan_log(<span class="string">&quot;initiating Quick Mode %s%s &#123;using isakmp#%lu msgid:%08x proposal=%s pfsgroup=%s&#125;&quot;</span></span><br><span class="line">		     , prettypolicy(policy)</span><br><span class="line">		     , replacestr</span><br><span class="line">		     , isakmp_sa-&gt;st_serialno, st-&gt;st_msgid, p2alg, pfsgroupname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qke = alloc_thing(struct qke_continuation , <span class="string">&quot;quick_outI1 KE&quot;</span>);</span><br><span class="line">    qke-&gt;replacing = replacing;</span><br><span class="line">    pcrc_init(&amp;qke-&gt;qke_pcrc);</span><br><span class="line">    qke-&gt;qke_pcrc.pcrc_func = quick_outI1_continue;<span class="comment">/*对于KE载荷、NONCE载荷的填充是在此回调函数中实现的*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(policy &amp; POLICY_PFS) &#123;<span class="comment">/*生成KE载荷*/</span></span><br><span class="line">	e=build_ke(&amp;qke-&gt;qke_pcrc, st, st-&gt;st_pfs_group, st-&gt;st_import);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/*生成NONCE载荷*/</span></span><br><span class="line">	e=build_nonce(&amp;qke-&gt;qke_pcrc, st, st-&gt;st_import);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset_globals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中应该注意到一点：就是<strong>一个connection(隧道)可以对应多个state结构</strong>。这有什么影响呢？</p>
<p>我们在查询隧道状态时，是通过查询该隧道(connection)对应的state来获取到协商的阶段，但是我们在遍历全局state表时只有全部遍历一遍才能查到最新的协商阶段，否则可能只是查询其中的一个state,这个可能不是最新的state。这样的话如果不采用效率高的数据结构存储状态，随着state增多，遍历的效率会很低。</p>
<p><strong>PFS（Perfect Forward Secrecy，完善的前向安全性）</strong>是一种安全特性，指一个密钥被破解(例如说协商的第一阶段秘钥被破解)，并不影响第二阶段密钥的安全性，因为这些密钥间没有派生关系。此特性是通过在IKE第二阶段的协商中增加密钥交换来实现的，因此源码实现中，如果策略启动了PFS，则再次增加一个KE载荷进行秘钥交换。</p>
<h3 id="4-quick-outI1-continue-源码分析"><a href="#4-quick-outI1-continue-源码分析" class="headerlink" title="4. quick_outI1_continue()源码分析"></a>4. quick_outI1_continue()源码分析</h3><p>这个continue函数与之前的函数功能基本一致，通过pcrc中的状态序号获取到相应的状态，然后调用后续的函数进行报文封装操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">quick_outI1_continue</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		     , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">		     , <span class="keyword">err_t</span> ugh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span> =</span> (struct qke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">const</span> <span class="title">st</span> =</span> state_with_serialno(qke-&gt;qke_pcrc.pcrc_serialno);<span class="comment">/*一个效率比较低的接口*/</span></span><br><span class="line">    stf_status e;</span><br><span class="line"></span><br><span class="line">    DBG(DBG_CONTROLMORE</span><br><span class="line">	, DBG_log(<span class="string">&quot;quick outI1: calculated ke+nonce, sending I1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: Request was disconnected from state&quot;</span>,</span><br><span class="line">		__FUNCTION__);</span><br><span class="line">	<span class="keyword">if</span> (qke-&gt;md)</span><br><span class="line">	    release_md(qke-&gt;md);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;st_calculating = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX should check out ugh */</span></span><br><span class="line">    passert(ugh == <span class="literal">NULL</span>);</span><br><span class="line">    passert(cur_state == <span class="literal">NULL</span>);</span><br><span class="line">    passert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    set_cur_state(st);	<span class="comment">/* we must reset before exit */</span></span><br><span class="line">    set_suspended(st, <span class="literal">NULL</span>);</span><br><span class="line">    e = quick_outI1_tail(pcrc, r, st);</span><br><span class="line">    <span class="keyword">if</span> (e == STF_INTERNAL_ERROR)</span><br><span class="line">	loglog(RC_LOG_SERIOUS, <span class="string">&quot;%s: quick_outI1_tail() failed with STF_INTERNAL_ERROR&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    reset_globals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个有一个需要说明的地方，<code>state_with_serialno</code>函数需要遍历全局state哈希表，虽然O(n)的时间复杂度，但是如果state结构非常多的情况下，效率很低。因此如果应用场景中可添加的隧道比较多(成百上千条)，那么需要对该接口进行优化。</p>
<p><code>state_with_serialno()</code>源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the state object with this serial number.</span></span><br><span class="line"><span class="comment"> * This allows state object references that don&#x27;t turn into dangerous</span></span><br><span class="line"><span class="comment"> * dangling pointers: reference a state by its serial number.</span></span><br><span class="line"><span class="comment"> * Returns NULL if there is no such state.</span></span><br><span class="line"><span class="comment"> * If this turns out to be a significant CPU hog, it could be</span></span><br><span class="line"><span class="comment"> * improved to use a hash table rather than sequential seartch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct state *</span></span><br><span class="line"><span class="function"><span class="title">state_with_serialno</span><span class="params">(<span class="keyword">so_serial_t</span> sn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sn &gt;= SOS_FIRST)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; STATE_TABLE_SIZE; i++)</span><br><span class="line">	    <span class="keyword">for</span> (st = statetable[i]; st != <span class="literal">NULL</span>; st = st-&gt;st_hashchain_next)</span><br><span class="line">		<span class="keyword">if</span> (st-&gt;st_serialno == sn)</span><br><span class="line">		    <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-quick-outI1-tail-源码分析"><a href="#5-quick-outI1-tail-源码分析" class="headerlink" title="5. quick_outI1_tail()源码分析"></a>5. quick_outI1_tail()源码分析</h3><p>quick_outI1_tail()函数的作用：构造第二阶段首包报文，他包括：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 第二阶段的加解密算法、哈希(认证)算法、PFS等策略信息<ul>
<li><input disabled="" type="checkbox"> <strong>构造SA建议载荷out_sa()</strong></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 如果启动PFS，则重新进行秘钥交换，生成KE载荷</li>
<li><input checked="" disabled="" type="checkbox"> 生成Nonce载荷</li>
<li><input checked="" disabled="" type="checkbox"> 构造本端标识和对端标识载荷</li>
<li><input checked="" disabled="" type="checkbox"> NAT穿越中的 OA载荷</li>
<li><input checked="" disabled="" type="checkbox"> ==计算报文的完整性(哈希算法)==</li>
<li><input checked="" disabled="" type="checkbox"> ==对报文进行加密==</li>
</ul>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> stf_status</span></span><br><span class="line"><span class="function"><span class="title">quick_outI1_tail</span><span class="params">(struct pluto_crypto_req_cont *pcrc</span></span></span><br><span class="line"><span class="params"><span class="function">		 , struct pluto_crypto_req *r</span></span></span><br><span class="line"><span class="params"><span class="function">		 , struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qke_continuation</span> *<span class="title">qke</span> =</span> (struct qke_continuation *)pcrc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">state</span> *<span class="title">isakmp_sa</span> =</span> state_with_serialno(st-&gt;st_clonedfrom);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">c</span> =</span> st-&gt;st_connection;</span><br><span class="line">    pb_stream rbody;</span><br><span class="line">    u_char	<span class="comment">/* set by START_HASH_PAYLOAD: */</span></span><br><span class="line">	*r_hashval,	<span class="comment">/* where in reply to jam hash value */</span></span><br><span class="line">	*r_hash_start;	<span class="comment">/* start of what is to be hashed */</span><span class="comment">/*用来记录需要计算hash的起始位置*/</span></span><br><span class="line">    <span class="keyword">bool</span> has_client = c-&gt;spd.<span class="keyword">this</span>.has_client || c-&gt;spd.that.has_client ||</span><br><span class="line">		      	     c-&gt;spd.<span class="keyword">this</span>.protocol    || c-&gt;spd.that.protocol   ||</span><br><span class="line">		            c-&gt;spd.<span class="keyword">this</span>.port         || c-&gt;spd.that.port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isakmp_sa == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* phase1 state got deleted while cryptohelper was working */</span></span><br><span class="line">	loglog(RC_LOG_SERIOUS,<span class="string">&quot;phase2 initiation failed because parent ISAKMP #%lu is gone&quot;</span>, st-&gt;st_clonedfrom);</span><br><span class="line">	<span class="keyword">return</span> STF_FATAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> (isakmp_sa-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_DETECTED) &#123;<span class="comment">/*第一阶段协商过程中发现存在NAT设备*/</span></span><br><span class="line">       <span class="comment">/* Duplicate nat_traversal status in new state */</span><span class="comment">/*将NAT信息存储在新的state上*/</span></span><br><span class="line">       st-&gt;hidden_variables.st_nat_traversal = isakmp_sa-&gt;hidden_variables.st_nat_traversal;</span><br><span class="line">       <span class="keyword">if</span> (isakmp_sa-&gt;hidden_variables.st_nat_traversal &amp; LELEM(NAT_TRAVERSAL_NAT_BHND_ME)) &#123;<span class="comment">/*本端位于NAT之后*/</span></span><br><span class="line"> 	  has_client = TRUE;</span><br><span class="line">       &#125;<span class="comment">/*确定端口浮动后的出接口*/</span></span><br><span class="line">       nat_traversal_change_port_lookup(<span class="literal">NULL</span>, st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       st-&gt;hidden_variables.st_nat_traversal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set up reply */</span></span><br><span class="line">    init_pbs(&amp;reply_stream, reply_buffer, <span class="keyword">sizeof</span>(reply_buffer), <span class="string">&quot;reply packet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HDR* out */</span><span class="comment">/*填充第二阶段的ISAKMP的头部*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isakmp_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line"></span><br><span class="line">	hdr.isa_version = ISAKMP_MAJOR_VERSION &lt;&lt; ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION;</span><br><span class="line">	hdr.isa_np = ISAKMP_NEXT_HASH;</span><br><span class="line">	hdr.isa_xchg = ISAKMP_XCHG_QUICK;</span><br><span class="line">	hdr.isa_msgid = st-&gt;st_msgid;</span><br><span class="line">	hdr.isa_flags = ISAKMP_FLAG_ENCRYPTION;</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_icookie, st-&gt;st_icookie, COOKIE_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(hdr.isa_rcookie, st-&gt;st_rcookie, COOKIE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (!out_struct(&amp;hdr, &amp;isakmp_hdr_desc, &amp;reply_stream, &amp;rbody))<span class="comment">/*填充到报文中*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    reset_cur_state();</span><br><span class="line">	    <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*填充hash载荷头部，数据部分全零，并记录下要填充hash的位置，最后填充*/</span></span><br><span class="line">    <span class="comment">/* HASH(1) -- create and note space to be filled later */</span></span><br><span class="line">    START_HASH_PAYLOAD(rbody, ISAKMP_NEXT_SA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA out */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Emit SA payload based on a subset of the policy bits.</span></span><br><span class="line"><span class="comment">     * POLICY_COMPRESS is considered iff we can do IPcomp.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lset_t</span> pm = POLICY_ENCRYPT | POLICY_AUTHENTICATE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_do_IPcomp)</span><br><span class="line">            pm |= POLICY_COMPRESS;</span><br><span class="line">    <span class="comment">/*填充sa载荷: ESP AH IPCom*/</span></span><br><span class="line">        <span class="keyword">if</span> (!out_sa(&amp;rbody</span><br><span class="line">                , &amp;ipsec_sadb[(st-&gt;st_policy &amp; pm) &gt;&gt; POLICY_IPSEC_SHIFT]</span><br><span class="line">                , st, FALSE, FALSE, ISAKMP_NEXT_NONCE))</span><br><span class="line">        &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> np;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st-&gt;st_policy &amp; POLICY_PFS) &#123;<span class="comment">/*如果使用PFS,则需要再次DH协商*/</span></span><br><span class="line">            np = ISAKMP_NEXT_KE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(has_client) &#123;</span><br><span class="line">            np = ISAKMP_NEXT_ID;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            np = ISAKMP_NEXT_NONE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ni out */</span><span class="comment">/*填充Nonce载荷，并将其存储在st_ni中*/</span></span><br><span class="line">        <span class="keyword">if</span> (!ship_nonce(&amp;st-&gt;st_ni, r, &amp;rbody</span><br><span class="line">                , np</span><br><span class="line">                , <span class="string">&quot;Ni&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [ KE ] out (for PFS) */</span><span class="comment">/*填充KE载荷，并将其存储在st_gi*/</span></span><br><span class="line">        <span class="keyword">if</span> (st-&gt;st_pfs_group != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ship_KE(st, r, &amp;st-&gt;st_gi</span><br><span class="line">                     , &amp;rbody</span><br><span class="line">                     , has_client? ISAKMP_NEXT_ID : ISAKMP_NEXT_NONE))</span><br><span class="line">            &#123;</span><br><span class="line">                reset_cur_state();</span><br><span class="line">                <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [ IDci, IDcr ] out */</span></span><br><span class="line">        <span class="keyword">if</span> (has_client)<span class="comment">/*填充的子网ID*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* IDci (we are initiator), then IDcr (peer is responder) */</span></span><br><span class="line">            <span class="keyword">if</span> (!emit_subnet_id(&amp;c-&gt;spd.<span class="keyword">this</span><span class="comment">/*本端身份标识*/</span></span><br><span class="line">                        , ISAKMP_NEXT_ID</span><br><span class="line">                                    , st-&gt;st_localaddr</span><br><span class="line">                        , st-&gt;st_myuserprotoid</span><br><span class="line">                        , st-&gt;st_myuserport, &amp;rbody)</span><br><span class="line">                || !emit_subnet_id(&amp;c-&gt;spd.that<span class="comment">/*对端身份标识*/</span></span><br><span class="line">                           , ISAKMP_NEXT_NONE</span><br><span class="line">                                       , st-&gt;st_remoteaddr</span><br><span class="line">                           , st-&gt;st_peeruserprotoid</span><br><span class="line">                           , st-&gt;st_peeruserport, &amp;rbody))</span><br><span class="line">            &#123;</span><br><span class="line">                reset_cur_state();</span><br><span class="line">                <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line">    <span class="keyword">if</span> ((st-&gt;hidden_variables.st_nat_traversal &amp; NAT_T_WITH_NATOA)</span><br><span class="line">	&amp;&amp; (!(st-&gt;st_policy &amp; POLICY_TUNNEL))<span class="comment">/*只有传输模式才需要OA载荷????*/</span></span><br><span class="line">	&amp;&amp; (st-&gt;hidden_variables.st_nat_traversal &amp; LELEM(NAT_TRAVERSAL_NAT_BHND_ME))) &#123;</span><br><span class="line">    <span class="comment">/** Send NAT-OA if our address is NATed */</span><span class="comment">/*填充OA载荷，这里需要修改上一个载荷的NP*/</span></span><br><span class="line">        <span class="keyword">if</span> (!nat_traversal_add_natoa(ISAKMP_NEXT_NONE, &amp;rbody, st, TRUE <span class="comment">/* initiator */</span>)) &#123;</span><br><span class="line">            reset_cur_state();</span><br><span class="line">            <span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TPM</span></span><br><span class="line">    &#123;</span><br><span class="line">	pb_stream *pbs = &amp;rbody;</span><br><span class="line">	<span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);</span><br><span class="line"></span><br><span class="line">	TCLCALLOUT_crypt(<span class="string">&quot;preHash&quot;</span>,st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line">	r_hashval = tpm_relocateHash(pbs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finish computing  HASH(1), inserting it in output */</span><span class="comment">/*计算整个载荷的哈希值*/</span></span><br><span class="line">    (<span class="keyword">void</span>) quick_mode_hash12(r_hashval, r_hash_start, rbody.cur</span><br><span class="line">	, st, &amp;st-&gt;st_msgid, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt message, except for fixed part of header */</span></span><br><span class="line"><span class="comment">/*设置第二阶段的IV值*/</span></span><br><span class="line">	</span><br><span class="line">    init_phase2_iv(isakmp_sa, &amp;st-&gt;st_msgid);</span><br><span class="line">    st-&gt;st_new_iv_len = isakmp_sa-&gt;st_new_iv_len;</span><br><span class="line">    set_new_iv(st, isakmp_sa-&gt;st_new_iv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!encrypt_message(&amp;rbody, st))<span class="comment">/*加密除报文头部以外的所有载荷*/</span></span><br><span class="line">    &#123;</span><br><span class="line">	reset_cur_state();</span><br><span class="line">	<span class="keyword">return</span> STF_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save packet, now that we know its size 保留数据包，超时重传会使用到*/</span></span><br><span class="line">    clonetochunk(st-&gt;st_tpacket, reply_stream.start, pbs_offset(&amp;reply_stream)</span><br><span class="line">	, <span class="string">&quot;reply packet from quick_outI1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send the packet */</span></span><br><span class="line">    <span class="comment">/*发送报文，如果使用了NAT-T,则会添加Non-ESP的封装*/</span></span><br><span class="line">    send_packet(st, <span class="string">&quot;quick_outI1&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">    delete_event(st);<span class="comment">/*设置超时重传事件*/</span></span><br><span class="line">    event_schedule(EVENT_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qke-&gt;replacing == SOS_NOBODY)</span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_QUICK_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	whack_log(RC_NEW_STATE + STATE_QUICK_I1</span><br><span class="line">	    , <span class="string">&quot;%s: initiate to replace #%lu&quot;</span></span><br><span class="line">	    , enum_name(&amp;state_names, st-&gt;st_state)</span><br><span class="line">	    , qke-&gt;replacing);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STF_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>下面对<code>quick_outI1_tail()</code>中的几个重要函数做个简单说明：</p>
<h4 id="5-1-out-sa"><a href="#5-1-out-sa" class="headerlink" title="5.1 out_sa()"></a>5.1 out_sa()</h4><p>这个函数在第一阶段的前两个报文中使用过，当时使用的第一阶段的SA载荷，现在使用第二阶段的SA载荷；<code>out_sa</code>同时实现了第一阶段和第二阶段SA载荷封装的功能，它通过<code>bool oakley_mode</code>参数来确定使用第一阶段还是第二阶段的封装流程。如果说<code>out_struct</code>等封装接口已经比较熟的话，那么这个函数可能会比较容易，否则基本流程看起来还是有点吃力。这里只简单说明<code>out_struct</code>各个参数的作用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">将struct_ptr按照sd的描述方式拷贝到outs中。同时如果obj_pbs存在，</span></span><br><span class="line"><span class="comment">则使obj_pbs指向outs数据部分，并更新obj_pbs的cur指针到新填充的位置，</span></span><br><span class="line"><span class="comment">然后将outs的cur设置到最大，其他函数不得再操作outs,除非使用close_output_pbs更新才行</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_struct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *struct_ptr, struct_desc *sd, pb_stream *outs, pb_stream *obj_pbs)</span></span></span><br></pre></td></tr></table></figure>

<p>openswan源码在对齐上做的不敢恭维，而代码是不忍卒读(看不懂<img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1.assets%5C433F992D.gif" alt="img">)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_sa</span><span class="params">(pb_stream *outs</span></span></span><br><span class="line"><span class="params"><span class="function">       , struct db_sa *sadb</span></span></span><br><span class="line"><span class="params"><span class="function">       , struct state *st</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">bool</span> oakley_mode</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">bool</span> aggressive_mode UNUSED</span></span></span><br><span class="line"><span class="params"><span class="function">       , <span class="keyword">u_int8_t</span> np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pb_stream sa_pbs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pcn;</span><br><span class="line">    <span class="keyword">bool</span> ret = FALSE;</span><br><span class="line">    <span class="keyword">bool</span> ah_spi_generated = FALSE</span><br><span class="line">          , esp_spi_generated = FALSE</span><br><span class="line">          , ipcomp_cpi_generated = FALSE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">db_sa</span> *<span class="title">revised_sadb</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oakley_mode) &#123;</span><br><span class="line"><span class="comment">/* Aggr-Mode - Max transforms == 2 - Multiple transforms, 1 DH group */</span></span><br><span class="line"><span class="comment">/*根据配置的秘钥算法信息重新生成一个sadb信息*/</span></span><br><span class="line"><span class="comment">/*传入的sadb应该为固定的秘钥算法信息，因此需要根据策略来重新生成一个新的sadb*/</span></span><br><span class="line">      revised_sadb = oakley_alg_makedb(st-&gt;st_connection-&gt;alg_info_ike<span class="comment">/*第一阶段算法*/</span></span><br><span class="line">                                               , sadb</span><br><span class="line">                                               , aggressive_mode ? <span class="number">2</span> : <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/*根据配置生成第二阶段的算法信息*/</span></span><br><span class="line">      revised_sad = kernel_alg_makedb(st-&gt;st_connection-&gt;policy</span><br><span class="line">                   , st-&gt;st_connection-&gt;alg_info_esp<span class="comment">/*第二阶段算法*/</span></span><br><span class="line">                   , TRUE);</span><br><span class="line">		<span class="comment">/*IPComp代码略*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* more sanity */</span></span><br><span class="line">    <span class="keyword">if</span>(revised_sadb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          sadb = revised_sadb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SA header out */</span></span><br><span class="line">    &#123;<span class="comment">/*添加SA头部*/</span></span><br><span class="line"><span class="comment">/*                      1                   2                   3</span></span><br><span class="line"><span class="comment"> *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * ! Next Payload  !   RESERVED    !         Payload Length        !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * !              Domain of Interpretation  (DOI)                  !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> * !                                                               !</span></span><br><span class="line"><span class="comment"> * ~                           Situation                           ~</span></span><br><span class="line"><span class="comment"> * !                                                               !</span></span><br><span class="line"><span class="comment"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_sa</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">          sa.isasa_np = np;</span><br><span class="line">          st-&gt;st_doi = sa.isasa_doi = ISAKMP_DOI_IPSEC; <span class="comment">/* all we know */</span></span><br><span class="line">          <span class="keyword">if</span> (!out_struct(&amp;sa, &amp;isakmp_sa_desc, outs, &amp;sa_pbs))</span><br><span class="line">              return_on(ret, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* within SA: situation out */</span><span class="comment">/*填充上图中的Situation字段*/</span></span><br><span class="line">    st-&gt;st_situation = SIT_IDENTITY_ONLY;</span><br><span class="line">    <span class="keyword">if</span> (!out_struct(&amp;st-&gt;st_situation, &amp;ipsec_sit_desc, &amp;sa_pbs, <span class="literal">NULL</span>))</span><br><span class="line">          return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* within SA: Proposal Payloads   建议载荷</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Multiple Proposals with the same number are simultaneous</span></span><br><span class="line"><span class="comment">     * (conjuncts) and must deal with different protocols (AH or ESP).</span></span><br><span class="line"><span class="comment">     * Proposals with different numbers are alternatives (disjuncts),</span></span><br><span class="line"><span class="comment">     * in preference order.</span></span><br><span class="line"><span class="comment">     * Proposal numbers must be monotonic.</span></span><br><span class="line"><span class="comment">     * See RFC 2408 &quot;ISAKMP&quot; 4.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pcn = <span class="number">0</span>; pcn &lt; sadb-&gt;prop_conj_cnt; pcn++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">db_prop_conj</span> *<span class="title">pc</span>;</span></span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> pn;</span><br><span class="line">          <span class="keyword">int</span> valid_prop_cnt;</span><br><span class="line"></span><br><span class="line">          pc = &amp;sadb-&gt;prop_conjs[pcn];<span class="comment">/*遍历建议载荷*/</span></span><br><span class="line">          valid_prop_cnt = pc-&gt;prop_cnt;</span><br><span class="line">          DBG(DBG_EMITTING,</span><br><span class="line">              DBG_log(<span class="string">&quot;out_sa pcn: %d has %d valid proposals&quot;</span>,</span><br><span class="line">                        pcn, valid_prop_cnt));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (pn = <span class="number">0</span>; pn &lt; pc-&gt;prop_cnt; pn++)<span class="comment">/*遍历建议载荷*/</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="class"><span class="keyword">struct</span> <span class="title">db_prop</span> *<span class="title">p</span>;</span></span><br><span class="line">              pb_stream proposal_pbs;</span><br><span class="line">              <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_proposal</span> <span class="title">proposal</span>;</span></span><br><span class="line">              struct_desc *trans_desc;</span><br><span class="line">              struct_desc *attr_desc;</span><br><span class="line">              enum_names **attr_val_descs;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> tn;</span><br><span class="line">              <span class="keyword">bool</span> tunnel_mode;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * set the tunnel_mode bit on the last proposal only, and</span></span><br><span class="line"><span class="comment">               * only if we are trying to negotiate tunnel mode in the first</span></span><br><span class="line"><span class="comment">               * place.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              tunnel_mode = (valid_prop_cnt == <span class="number">1</span>)</span><br><span class="line">                    &amp;&amp; (st-&gt;st_policy &amp; POLICY_TUNNEL);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * pick the part of the proposal we are trying to work on</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		 <span class="comment">/*                      1                   2                   3</span></span><br><span class="line"><span class="comment">		 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * ! Next Payload  !   RESERVED    !         Payload Length        !</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * !  Proposal #   !  Protocol-Id  !    SPI Size   !# of Transforms!</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 * !                        SPI (variable)                         !</span></span><br><span class="line"><span class="comment">		 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">			  </span><br><span class="line">              p = &amp;pc-&gt;props[pn];</span><br><span class="line"></span><br><span class="line">              proposal.isap_proposal = pcn;</span><br><span class="line">              proposal.isap_protoid = p-&gt;protoid;</span><br><span class="line">              proposal.isap_spisize = oakley_mode ? <span class="number">0</span></span><br><span class="line">                    : p-&gt;protoid == PROTO_IPCOMP ? IPCOMP_CPI_SIZE</span><br><span class="line">                    : IPSEC_DOI_SPI_SIZE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* but, skip things if the transform count is zero */</span></span><br><span class="line">              <span class="keyword">if</span>(p-&gt;trans_cnt == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Proposal header */</span></span><br><span class="line">              <span class="keyword">if</span>(--valid_prop_cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    proposal.isap_np = ISAKMP_NEXT_P;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    proposal.isap_np = ISAKMP_NEXT_NONE;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              proposal.isap_notrans = p-&gt;trans_cnt;<span class="comment">/*变换载荷的个数*/</span></span><br><span class="line">              <span class="keyword">if</span> (!out_struct(&amp;proposal, &amp;isakmp_proposal_desc</span><br><span class="line">                                  , &amp;sa_pbs, &amp;proposal_pbs))</span><br><span class="line">                    return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Per-protocols stuff:</span></span><br><span class="line"><span class="comment">       * Set trans_desc.</span></span><br><span class="line"><span class="comment">       * Set attr_desc.</span></span><br><span class="line"><span class="comment">       * Set attr_val_descs.</span></span><br><span class="line"><span class="comment">       * If not oakley_mode, emit SPI.</span></span><br><span class="line"><span class="comment">       * We allocate SPIs on demand.</span></span><br><span class="line"><span class="comment">       * All ESPs in an SA will share a single SPI.</span></span><br><span class="line"><span class="comment">       * All AHs in an SAwill share a single SPI.</span></span><br><span class="line"><span class="comment">       * AHs&#x27; SPI will be distinct from ESPs&#x27;.</span></span><br><span class="line"><span class="comment">       * This latter is needed because KLIPS doesn&#x27;t</span></span><br><span class="line"><span class="comment">       * use the protocol when looking up a (dest, protocol, spi).</span></span><br><span class="line"><span class="comment">       * ??? If multiple ESPs are composed, how should their SPIs</span></span><br><span class="line"><span class="comment">       * be allocated?</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       &#123;</span><br><span class="line">		  <span class="class"><span class="keyword">struct</span> <span class="title">ipsec_proto_info</span> *<span class="title">pi</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		  <span class="keyword">int</span> proto = <span class="number">0</span>;</span><br><span class="line">		  <span class="keyword">bool</span> *spi_generated;</span><br><span class="line"></span><br><span class="line">                    spi_generated = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> (p-&gt;protoid)</span><br><span class="line">                    &#123;</span><br><span class="line">	                    <span class="keyword">case</span> PROTO_ISAKMP:</span><br><span class="line">	                        passert(oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_isakmp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_oakley_attribute_desc;</span><br><span class="line">	                        attr_val_descs = oakley_attr_val_descs;</span><br><span class="line">	                        <span class="comment">/* no SPI needed */</span></span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/*第二阶段时，在kernel_alg_db_new中根据策略配置选择采用的封装方式*/</span></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPSEC_AH:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_ah_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line">				pi = &amp;st-&gt;st_ah;</span><br><span class="line">	                        spi_generated = &amp;ah_spi_generated;</span><br><span class="line">	                        proto = IPPROTO_AH;</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPSEC_ESP:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_esp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line">				pi = &amp;st-&gt;st_esp;</span><br><span class="line">	                        spi_generated = &amp;esp_spi_generated;</span><br><span class="line">	                        proto = IPPROTO_ESP;</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">case</span> PROTO_IPCOMP:</span><br><span class="line">	                        passert(!oakley_mode);</span><br><span class="line">	                        trans_desc = &amp;isakmp_ipcomp_transform_desc;</span><br><span class="line">	                        attr_desc = &amp;isakmp_ipsec_attribute_desc;</span><br><span class="line">	                        attr_val_descs = ipsec_attr_val_descs;</span><br><span class="line"></span><br><span class="line">	                        <span class="comment">/* a CPI isn&#x27;t quite the same as an SPI</span></span><br><span class="line"><span class="comment">	                         * so we use specialized code to emit it.</span></span><br><span class="line"><span class="comment">	                         */</span></span><br><span class="line">	                        <span class="keyword">if</span> (!ipcomp_cpi_generated)</span><br><span class="line">	                        &#123;</span><br><span class="line">	                              st-&gt;st_ipcomp.our_spi = get_my_cpi(st, tunnel_mode);</span><br><span class="line">	                              <span class="keyword">if</span> (st-&gt;st_ipcomp.our_spi == <span class="number">0</span>)</span><br><span class="line">	                                  return_on(ret, FALSE);          <span class="comment">/* problem generating CPI */</span></span><br><span class="line"></span><br><span class="line">	                              ipcomp_cpi_generated = TRUE;</span><br><span class="line">	                        &#125;</span><br><span class="line">	                        <span class="comment">/* CPI is stored in network low order end of an</span></span><br><span class="line"><span class="comment">	                         * ipsec_spi_t.  So we start a couple of bytes in.</span></span><br><span class="line"><span class="comment">	                         */</span></span><br><span class="line">	                        <span class="keyword">if</span> (!out_raw((u_char *)&amp;st-&gt;st_ipcomp.our_spi</span><br><span class="line">	                         + IPSEC_DOI_SPI_SIZE - IPCOMP_CPI_SIZE</span><br><span class="line">	                        , IPCOMP_CPI_SIZE</span><br><span class="line">	                        , &amp;proposal_pbs, <span class="string">&quot;CPI&quot;</span>))</span><br><span class="line">	                              return_on(ret, FALSE);</span><br><span class="line">	                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	                    <span class="keyword">default</span>:</span><br><span class="line">	                        bad_case(p-&gt;protoid);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pi != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">	                        <span class="keyword">if</span> (spi_generated != <span class="literal">NULL</span> &amp;&amp; !*spi_generated)</span><br><span class="line">	                        &#123;</span><br><span class="line">					    <span class="keyword">if</span> (!get_ipsec_spi(pi</span><br><span class="line">							       , proto</span><br><span class="line">							       , st</span><br><span class="line">							       , tunnel_mode)) &#123;</span><br><span class="line">						<span class="keyword">return</span> FALSE;</span><br><span class="line">					    &#125;</span><br><span class="line">					    *spi_generated = TRUE;</span><br><span class="line">	                        &#125;</span><br><span class="line">	                        <span class="keyword">if</span> (!out_raw((u_char *)&amp;pi-&gt;our_spi, IPSEC_DOI_SPI_SIZE</span><br><span class="line">					     , &amp;proposal_pbs, <span class="string">&quot;SPI&quot;</span>))</span><br><span class="line">				    	return_on(ret, FALSE);</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 填充变换载荷 within proposal: Transform Payloads */</span></span><br><span class="line">              <span class="keyword">for</span> (tn = <span class="number">0</span>; tn != p-&gt;trans_cnt; tn++)</span><br><span class="line">              &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">db_trans</span> *<span class="title">t</span> =</span> &amp;p-&gt;trans[tn];</span><br><span class="line">                    pb_stream trans_pbs;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_transform</span> <span class="title">trans</span>;</span></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> an;</span><br><span class="line"></span><br><span class="line">                    trans.isat_np = (tn == p-&gt;trans_cnt - <span class="number">1</span>)</span><br><span class="line">                        ? ISAKMP_NEXT_NONE : ISAKMP_NEXT_T;</span><br><span class="line">                    trans.isat_transnum = tn;</span><br><span class="line">                    trans.isat_transid = t-&gt;transid;</span><br><span class="line">                    <span class="keyword">if</span> (!out_struct(&amp;trans, trans_desc, &amp;proposal_pbs, &amp;trans_pbs))</span><br><span class="line">                        return_on(ret, FALSE);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Within tranform: Attributes. */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* For Phase 2 / Quick Mode, GROUP_DESCRIPTION is</span></span><br><span class="line"><span class="comment">                     * automatically generated because it must be the same</span></span><br><span class="line"><span class="comment">                     * in every transform.  Except IPCOMP.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;protoid != PROTO_IPCOMP</span><br><span class="line">                    &amp;&amp; st-&gt;st_pfs_group != <span class="literal">NULL</span>)<span class="comment">/*添加PFS组属性信息*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        passert(!oakley_mode);</span><br><span class="line">                        passert(st-&gt;st_pfs_group != &amp;unset_group);</span><br><span class="line">                        out_attr(GROUP_DESCRIPTION, st-&gt;st_pfs_group-&gt;group</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* automatically generate duration</span></span><br><span class="line"><span class="comment">                     * and, for Phase 2 / Quick Mode, encapsulation.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (oakley_mode)<span class="comment">/*第一阶段*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        out_attr(OAKLEY_LIFE_TYPE, OAKLEY_LIFE_SECONDS</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                        out_attr(OAKLEY_LIFE_DURATION</span><br><span class="line">                              , st-&gt;st_connection-&gt;sa_ike_life_seconds</span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">/*第二阶段*/</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* RFC 2407 (IPSEC DOI) 4.5 specifies that</span></span><br><span class="line"><span class="comment">                         * the default is &quot;unspecified (host-dependent)&quot;.</span></span><br><span class="line"><span class="comment">                         * This makes little sense, so we always specify it.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * Unlike other IPSEC transforms, IPCOMP defaults</span></span><br><span class="line"><span class="comment">                         * to Transport Mode, so we can exploit the default</span></span><br><span class="line"><span class="comment">                         * (draft-shacham-ippcp-rfc2393bis-05.txt 4.1).</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;protoid != PROTO_IPCOMP</span><br><span class="line">                        || st-&gt;st_policy &amp; POLICY_TUNNEL)</span><br><span class="line">                        &#123;</span><br><span class="line">							<span class="comment">/*隧道模式? 传输模式*/</span></span><br><span class="line">                            out_attr(ENCAPSULATION_MODE</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAT_TRAVERSAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> I_KNOW_TRANSPORT_MODE_HAS_SECURITY_CONCERN_BUT_I_WANT_IT</span></span><br><span class="line">                                  , NAT_T_ENCAPSULATION_MODE(st,st-&gt;st_policy)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                          <span class="comment">/* If NAT-T is detected, use UDP_TUNNEL as long as Transport</span></span><br><span class="line"><span class="comment">                           * Mode has security concerns.</span></span><br><span class="line"><span class="comment">                           *</span></span><br><span class="line"><span class="comment">                           * User has been informed of that</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line">                                  , NAT_T_ENCAPSULATION_MODE(st,POLICY_TUNNEL)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ! NAT_TRAVERSAL */</span></span></span><br><span class="line">                                  , st-&gt;st_policy &amp; POLICY_TUNNEL</span><br><span class="line">                                    ? ENCAPSULATION_MODE_TUNNEL : 			ENCAPSULATION_MODE_TRANSPORT</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                                  , attr_desc, attr_val_descs</span><br><span class="line">                                  , &amp;trans_pbs);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out_attr(SA_LIFE_TYPE, SA_LIFE_TYPE_SECONDS <span class="comment">/*单位:秒*/</span> </span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line">                        out_attr(SA_LIFE_DURATION</span><br><span class="line">                              , st-&gt;st_connection-&gt;sa_ipsec_life_seconds <span class="comment">/*生存时间从连接上获取*/</span></span><br><span class="line">                              , attr_desc, attr_val_descs</span><br><span class="line">                              , &amp;trans_pbs);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* spit out attributes from table */</span></span><br><span class="line">                    <span class="keyword">for</span> (an = <span class="number">0</span>; an != t-&gt;attr_cnt; an++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">db_attr</span> *<span class="title">a</span> =</span> &amp;t-&gt;attrs[an];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(oakley_mode) &#123;</span><br><span class="line">                              out_attr(a-&gt;type.oakley, a-&gt;val</span><br><span class="line">                                         , attr_desc, attr_val_descs</span><br><span class="line">                                         , &amp;trans_pbs);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           out_attr(a-&gt;type.ipsec,  a-&gt;val , attr_desc, attr_val_descs , &amp;trans_pbs);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    close_output_pbs(&amp;trans_pbs);</span><br><span class="line">              &#125;</span><br><span class="line">              close_output_pbs(&amp;proposal_pbs);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* end of a conjunction of proposals */</span></span><br><span class="line">    &#125;</span><br><span class="line">    close_output_pbs(&amp;sa_pbs);</span><br><span class="line">    ret = TRUE;</span><br><span class="line"></span><br><span class="line">return_out:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(KERNEL_ALG) || defined(IKE_ALG)</span></span><br><span class="line">    <span class="keyword">if</span> (revised_sadb)</span><br><span class="line">          free_sa(revised_sadb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般而言，比较关心我们配置的参数在哪里生效？ 例如加密算法、认证算法、隧道模式or传输模式都是在<code>out_sa()</code>中通过属性载荷封装在报文中的。下图为属性载荷结构：</p>
<p><img src="F:%5C%E9%9A%8F%E7%AC%94%5Copenswan%5C%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E5%8C%85%EF%BC%9Aquick_outI1.assets%5Cimage-20200827002952001.png" alt="image-20200827002952001"></p>
<p>属性类型的最高比特位AF指定数据为定长还是变长，如果为0表示定长；如果为1表示变长。</p>
<p>具体属性类型有以下几种（全是定长类型）：</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>属性类型取值</th>
<th>属性值说明</th>
</tr>
</thead>
<tbody><tr>
<td>SA生存周期</td>
<td>1</td>
<td>0: 保留    1:秒    2:千字节</td>
</tr>
<tr>
<td>SA生存期</td>
<td>2</td>
<td>0: 保留    1:秒    2:千字节</td>
</tr>
<tr>
<td>组描述</td>
<td>3</td>
<td>略</td>
</tr>
<tr>
<td><strong>封装模式</strong></td>
<td>4</td>
<td>0：保留     1：隧道模式      2：传输模式</td>
</tr>
<tr>
<td><strong>认证算法</strong></td>
<td>5</td>
<td>0：RESERVED    1：HMAC-MD5      2:HMAC-SHA   ….</td>
</tr>
<tr>
<td>密钥长度</td>
<td>6</td>
<td>略</td>
</tr>
<tr>
<td>密钥轮数</td>
<td>7</td>
<td>略</td>
</tr>
<tr>
<td>压缩字典长度</td>
<td>8</td>
<td>略</td>
</tr>
<tr>
<td>私有压缩算法</td>
<td>9</td>
<td>略</td>
</tr>
</tbody></table>
<p>注：加密算法不适用属性载荷进行封装。</p>
<h4 id="5-2-emit-subnet-id"><a href="#5-2-emit-subnet-id" class="headerlink" title="5.2 emit_subnet_id()"></a>5.2 emit_subnet_id()</h4><p>第二阶段除了协商加解密算法信息，还会对双方的保护子网进行匹配。而保护子网是通过ID载荷来传输的。在第一阶段中使用<code>build_id_payload()</code>接口将我们在配置隧道的“<strong>身份标识</strong>”发送对方以供双方认证，第二阶段使用<code>emit_subnet_id()</code>来协商两端的保护子网信息。</p>
<p>每一条隧道有本端和对端两个节点，这两个节点都是用<code>struct end</code>结构描述，而两端的保护子网使用<code>struct end</code>中的<code>ip_subnet client;</code>描述，<code>ip_subnet</code>结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ip_address addr;</span><br><span class="line">	<span class="keyword">int</span> maskbits;</span><br><span class="line">&#125; ip_subnet;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initiate quick mode.</span></span><br><span class="line"><span class="comment"> * --&gt; HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]</span></span><br><span class="line"><span class="comment"> * (see RFC 2409 &quot;IKE&quot; 5.5)</span></span><br><span class="line"><span class="comment"> * Note: this is not called from demux.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*填充的是隧道端口IP还是子网的信息? </span></span><br><span class="line"><span class="comment">*保护子网是如何协商的???</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">emit_subnet_id</span><span class="params">(struct end *e</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int8_t</span> np</span></span></span><br><span class="line"><span class="params"><span class="function">               , ip_address endpoint</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int8_t</span> protoid</span></span></span><br><span class="line"><span class="params"><span class="function">	       , <span class="keyword">u_int16_t</span> port</span></span></span><br><span class="line"><span class="params"><span class="function">	       , pb_stream *outs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">isakmp_ipsec_id</span> <span class="title">id</span>;</span></span><br><span class="line">    pb_stream id_pbs;</span><br><span class="line">    ip_address ta;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *tbp;</span><br><span class="line">    <span class="keyword">size_t</span> tal;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">af_info</span> *<span class="title">ai</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> usehost = FALSE;</span><br><span class="line">    ip_subnet clientnet;</span><br><span class="line"></span><br><span class="line">    clientnet = e-&gt;client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!e-&gt;has_client) &#123;</span><br><span class="line">        <span class="comment">/* we propose the IP address of the interface that we are using. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could instead propose 0.0.0.0-&gt;255.255.255.255 and let the other</span></span><br><span class="line"><span class="comment">     * end narrow the TS, but if one wants that, it is easy to just specify</span></span><br><span class="line"><span class="comment">     * in the configuration file: rightsubnet=0.0.0.0/0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When there is NAT involved, we may really want a tunnel to the</span></span><br><span class="line"><span class="comment">     * address that this end point thinks it is.  That works only when</span></span><br><span class="line"><span class="comment">     * virtual_ip includes the IP involved.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        addrtosubnet(&amp;endpoint, &amp;clientnet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ai = aftoinfo(subnettypeof(&amp;clientnet));</span><br><span class="line">    passert(ai != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    id.isaiid_np = np;</span><br><span class="line">    id.isaiid_idtype = (usehost ? ai-&gt;id_addr : ai-&gt;id_subnet);<span class="comment">/*确定使用主机ID还是子网ID；由于usehost===FALSE,因此这里使用子网ID*/</span></span><br><span class="line">    id.isaiid_protoid = protoid;</span><br><span class="line">    id.isaiid_port = port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out_struct(&amp;id, &amp;isakmp_ipsec_identification_desc, outs, &amp;id_pbs))</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    networkof(&amp;clientnet, &amp;ta);<span class="comment">/*获取保护子网*/</span></span><br><span class="line">    tal = addrbytesptr(&amp;ta, &amp;tbp);</span><br><span class="line">    <span class="keyword">if</span> (!out_raw(tbp, tal, &amp;id_pbs, <span class="string">&quot;client network&quot;</span>))<span class="comment">/*填充保护子网信息*/</span></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!usehost)</span><br><span class="line">    &#123;</span><br><span class="line">	maskof(&amp;clientnet, &amp;ta);<span class="comment">/*获取保护子网掩码*/</span></span><br><span class="line">	tal = addrbytesptr(&amp;ta, &amp;tbp);</span><br><span class="line">	<span class="keyword">if</span> (!out_raw(tbp, tal, &amp;id_pbs, <span class="string">&quot;client mask&quot;</span>))<span class="comment">/*填充保护子网掩码信息*/</span></span><br><span class="line">	    <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close_output_pbs(&amp;id_pbs);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ID载荷(标识载荷)包含以下几种类型：</p>
<table>
<thead>
<tr>
<th>ID类型</th>
<th>描述</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>ID_NONE</td>
<td>未使用</td>
<td>0</td>
</tr>
<tr>
<td><strong>ID_IPV4_ADDR</strong></td>
<td>单独的一个IPv4地址</td>
<td>1</td>
</tr>
<tr>
<td><strong>ID_FQDN</strong></td>
<td>全域名字符串，如topsec.com.cn</td>
<td>2</td>
</tr>
<tr>
<td><strong>ID_USER_FQDN</strong></td>
<td>用户名字符串，如<a href="mailto:&#x6c;&#105;&#95;&#115;&#105;&#64;&#116;&#x6f;&#112;&#115;&#x65;&#x63;&#x2e;&#99;&#111;&#x6d;&#46;&#99;&#x6e;">&#x6c;&#105;&#95;&#115;&#105;&#64;&#116;&#x6f;&#112;&#115;&#x65;&#x63;&#x2e;&#99;&#111;&#x6d;&#46;&#99;&#x6e;</a></td>
<td>3</td>
</tr>
<tr>
<td>ID_RFC822_ADDR</td>
<td>同ID_USER_FQDN</td>
<td>ID_USER_FQDN</td>
</tr>
<tr>
<td><strong>ID_IPV4_ADDR_SUBNET</strong></td>
<td>IPv4类子网地址，如192.168.1.1 255.255.255.0</td>
<td>4</td>
</tr>
<tr>
<td>ID_IPV6_ADDR</td>
<td>单独IPv6地址</td>
<td>5</td>
</tr>
<tr>
<td>ID_IPV6_ADDR_SUBNET</td>
<td>IPv6子网地址</td>
<td>6</td>
</tr>
<tr>
<td>ID_IPV4_ADDR_RANGE</td>
<td>IPv4地址范围区间, 如192.168.2.3 192.168.2.200</td>
<td>7</td>
</tr>
<tr>
<td>ID_IPV6_ADDR_RANGE</td>
<td>IPv6地址范围区间</td>
<td>8</td>
</tr>
<tr>
<td>ID_DER_ASN1_DN</td>
<td>x.500编码格式</td>
<td>9</td>
</tr>
<tr>
<td>ID_DER_ASN1_GN</td>
<td>x.500编码格式</td>
<td>10</td>
</tr>
<tr>
<td>ID_KEY_ID</td>
<td>传递特定厂商信息的字节流</td>
<td>11</td>
</tr>
</tbody></table>
<h4 id="5-3-encrypt-message"><a href="#5-3-encrypt-message" class="headerlink" title="5.3 encrypt_message()"></a>5.3 encrypt_message()</h4><p>报文的加密范围：除了ISAKMP头部之外都需要进行加密。加密使用第一阶段协商的加密秘钥（报文认证时同时也会用到认证密钥）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* encrypt message, sans fixed part of header</span></span><br><span class="line"><span class="comment"> * IV is fetched from st-&gt;st_new_iv and stored into st-&gt;st_iv.</span></span><br><span class="line"><span class="comment"> * The theory is that there will be no &quot;backing out&quot;, so we commit to IV.</span></span><br><span class="line"><span class="comment"> * We also close the pbs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">encrypt_message</span><span class="params">(pb_stream *pbs, struct state *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">encrypt_desc</span> *<span class="title">e</span> =</span> st-&gt;st_oakley.encrypter;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *enc_start = pbs-&gt;start + <span class="keyword">sizeof</span>(struct isakmp_hdr);<span class="comment">/*加密的内容为ISAKMP头部之后*/</span></span><br><span class="line">    <span class="keyword">size_t</span> enc_len = pbs_offset(pbs) - <span class="keyword">sizeof</span>(struct isakmp_hdr);<span class="comment">/*加密内容的长度*/</span></span><br><span class="line"></span><br><span class="line">    DBG_cond_dump(DBG_CRYPT | DBG_RAW, <span class="string">&quot;encrypting:\n&quot;</span>, enc_start, enc_len);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT | DBG_RAW, <span class="string">&quot;IV:\n&quot;</span></span><br><span class="line">		  , st-&gt;st_new_iv</span><br><span class="line">		  , st-&gt;st_new_iv_len);</span><br><span class="line">    DBG(DBG_CRYPT, DBG_log(<span class="string">&quot;unpadded size is: %u&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)enc_len));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad up to multiple of encryption blocksize.</span></span><br><span class="line"><span class="comment">     * See the description associated with the definition of</span></span><br><span class="line"><span class="comment">     * struct isakmp_hdr in packet.h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*确定需要填充的长度*/</span></span><br><span class="line">	<span class="keyword">size_t</span> padding = pad_up(enc_len, e-&gt;enc_blocksize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (padding != <span class="number">0</span>)<span class="comment">/*如果填充的长度不为0,则需要进行填充数据*/</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!out_zero(padding, pbs, <span class="string">&quot;encryption padding&quot;</span>))<span class="comment">/*在输出流上进行报文填充*/</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	    enc_len += padding;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DBG(DBG_CRYPT</span><br><span class="line">	, DBG_log(<span class="string">&quot;encrypting %d using %s&quot;</span></span><br><span class="line">		  , (<span class="keyword">unsigned</span> <span class="keyword">int</span>)enc_len</span><br><span class="line">		  , enum_show(&amp;oakley_enc_names, st-&gt;st_oakley.encrypt)));</span><br><span class="line"></span><br><span class="line">    TCLCALLOUT_crypt(<span class="string">&quot;preEncrypt&quot;</span>, st, pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);<span class="comment">/*非TPM未做任何处理*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* e-&gt;crypt(TRUE, enc_start, enc_len, st); */</span></span><br><span class="line">    crypto_cbc_encrypt(e, TRUE, enc_start, enc_len, st);<span class="comment">/*使用CBC算法进行加密:使用连接上第一阶段协商的加密算法和加密密钥信息*/</span></span><br><span class="line"></span><br><span class="line">    TCLCALLOUT_crypt(<span class="string">&quot;postEncrypt&quot;</span>, st,pbs,<span class="keyword">sizeof</span>(struct isakmp_hdr),enc_len);</span><br><span class="line"></span><br><span class="line">    update_iv(st);</span><br><span class="line">    DBG_cond_dump(DBG_CRYPT, <span class="string">&quot;next IV:&quot;</span>, st-&gt;st_iv, st-&gt;st_iv_len);</span><br><span class="line">    close_message(pbs);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-out-modify-previous-np"><a href="#5-4-out-modify-previous-np" class="headerlink" title="5.4 out_modify_previous_np()"></a>5.4 out_modify_previous_np()</h4><p>此函数的作用在于修改前一个载荷头部中的下一个载荷字段。它在填充NAT-T相关的OA载荷时用到。基本原理是从头部开始向后遍历每一个载荷，直到找到最后一个载荷的头部(尚未填充新的载荷，因此它还是最后一个载荷)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">out_modify_previous_np</span><span class="params">(<span class="keyword">u_int8_t</span> np, pb_stream *outs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *pl = outs-&gt;start;</span><br><span class="line">    <span class="keyword">size_t</span> left = outs-&gt;cur - outs-&gt;start;</span><br><span class="line"></span><br><span class="line">    passert(left &gt;= NSIZEOF_isakmp_hdr);    <span class="comment">/* not even room for isakmp_hdr! */</span></span><br><span class="line">    <span class="keyword">if</span> (left == NSIZEOF_isakmp_hdr) &#123;</span><br><span class="line">	<span class="comment">/* no payloads, just the isakmp_hdr: insert np here */</span></span><br><span class="line">	passert(pl[NOFFSETOF_isa_np] == ISAKMP_NEXT_NONE ||</span><br><span class="line">		pl[NOFFSETOF_isa_np] == ISAKMP_NEXT_HASH);</span><br><span class="line">	pl[NOFFSETOF_isa_np] = np;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	pl += NSIZEOF_isakmp_hdr;       <span class="comment">/* skip over isakmp_hdr */</span></span><br><span class="line">	left -= NSIZEOF_isakmp_hdr;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> pllen;</span><br><span class="line"></span><br><span class="line">		passert(left &gt;= NSIZEOF_isakmp_generic);</span><br><span class="line">		pllen = (pl[NOFFSETOF_isag_length] &lt;&lt; <span class="number">8</span>)<span class="comment">/*payload 一般为两个字节*/</span></span><br><span class="line">			| pl[NOFFSETOF_isag_length + <span class="number">1</span>];</span><br><span class="line">		passert(left &gt;= pllen);</span><br><span class="line">		<span class="keyword">if</span> (left == pllen) &#123;<span class="comment">/*当前载荷长度和剩余长度相同时，说明已经找到上一个载荷*/</span></span><br><span class="line">			<span class="comment">/* found last top-level payload */</span></span><br><span class="line">			pl[NOFFSETOF_isag_np] = np;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">/* done */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* this payload is not the last: scan forward */</span></span><br><span class="line">			pl += pllen;</span><br><span class="line">			left -= pllen;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>略</p>
]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>👉👉RCU锁原理深度思考</title>
    <url>/blogs/2021/11/20/RCU%E9%94%81%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="RCU经典文献"><a href="#RCU经典文献" class="headerlink" title="RCU经典文献"></a>RCU经典文献</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/264090/">RCU part 3: the RCU API</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Kernel/Index/">linux kernel</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://www.rdrop.com/users/paulmck/RCU/">RCU作者的主页介绍</a></li>
</ul>
<span id="more"></span>

<p>这几个连接简直就是一个宝藏，里面的干活很多很多！！！有时间一定要多看看。下文中的内容是看第一个和第二个链接的笔记和整理。直接观看原文，效果更佳。</p>
<p><img src="https://static.lwn.net/images/logo/barepenguin-70.png" alt="LWN.net Logo"></p>
<h2 id="RCU锁特点介绍"><a href="#RCU锁特点介绍" class="headerlink" title="RCU锁特点介绍"></a>RCU锁特点介绍</h2><p>Read-copy_update(简称RCU)技术是一种数据同步机制。常见的数据同步机制有：互斥锁，自旋锁，读写锁，顺序锁，信号量等手段。而RCU锁是一种比较高效的并发编程技术，它与2002年10月被添加到Linux内核中，在很多场景中它是用来替代读写锁的。</p>
<p>RCU锁的特点有：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>允许读写同时进行</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>任意读；写操作时先拷贝一个副本，在副本上进行修改、发布，并在合适时间释放原来的旧数据</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>读端不存在睡眠、阻塞、轮询，不会形成死锁，相比读写锁效率更高。</strong></li>
</ul>
<p>RCU也有自己的缺点：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>低优先级的读操作可阻塞高优先级的写操作</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>宽限期可能比较长</strong></li>
</ul>
<p>这是由于RCU 写操作完毕后，会等待读端的完毕，等所有的读操作完毕后，宽限期结束，此时写端才会将资源释放。这里没有区分优先级，因此低优先级的读操作可能会影响到高优先级的写操作。</p>
<p>其实，RCU技术的特点还不仅如此，而有一个更重要的特点：<strong>多核扩展性</strong>。RCU虽然我们将其称之为RCU锁，但它并没有采用锁技术，而读写锁则是一个真正的锁，在扩展性上很差，设备CPU核越多，锁的竞争会越激烈，效率会越低。因此在现在很多的实现中，越来越注重<strong>无锁技术</strong>的实现。 下图是在文章<a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>中的一张RCU和rwlock在多核扩展性上对比图片：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191148.jpg" alt="Graph showing RCU read-side primitives running multiple orders of magnitude faster than those of rwlock."></p>
<h2 id="RCU中常见问题"><a href="#RCU中常见问题" class="headerlink" title="RCU中常见问题"></a>RCU中常见问题</h2><h3 id="1-有没有使用引用计数"><a href="#1-有没有使用引用计数" class="headerlink" title="1. 有没有使用引用计数"></a>1. 有没有使用引用计数</h3><p>关于RCU实现原理还有一个误解：<strong>RCU采用了引用计数的方式确定是否存在读者。</strong> 这个观点也是错的。首先RCU并没有采用引用计数的机制，而是采用了一种非常简单的技术来实现；其次如果非要深究到底有没有引用计数，按照<a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>中的说法是“RCU is a Restricted Reference-Counting Mechanism”，但<strong>本质上是没有采用引用计数的机制</strong>。它的解释如下：</p>
<p>“rcu_read_lock() 语句可以被认为是获取对 p 的引用，相当于一个引用计数。因为在 rcu_dereference() 分配给 p 之后开始的宽限期不可能在我们到达匹配的 rcu_read_unlock() 之前结束。 这种引用计数方案受到限制，因为我们不允许在 RCU 读端临界区中阻塞，也不允许我们将 RCU 读端临界区从一个任务切换到另一个任务“。 <strong>虽然有点像引用计数，但绝对不是</strong>。</p>
 <img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191142.png" alt="image-20211016165636411" style="zoom:80%;" />

<p>至于它怎么实现：检测是否有人在引用当前变量呢？ 我在下面介绍下 </p>
<h3 id="2-RCU既然没有使用引用计数，那又是确定是否存在读者引用之？"><a href="#2-RCU既然没有使用引用计数，那又是确定是否存在读者引用之？" class="headerlink" title="2. RCU既然没有使用引用计数，那又是确定是否存在读者引用之？"></a>2. RCU既然没有使用引用计数，那又是确定是否存在读者引用之？</h3><p>RCU 读锁加锁和去锁最基本的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_lock()		preempt_disable()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_unlock()	preempt_enable()</span></span><br></pre></td></tr></table></figure>

<p>加锁实际上是禁止上下文切换；而解锁是允许上下文切换。<strong>它们是一个全局设置，不与任何一项锁绑定</strong>。这也是为啥RCU读锁不需要任何参数的原因。</p>
<p><strong>基于此，便可以通过让CPU进行一次上下文切换来实现检测读端是否完成，而不必跟踪每一个引用的进程。</strong> 这是一个RCU非常重要的特点.</p>
<p>进行这个操作是：<code>synchronize_rcu()</code>, 这个函数在内核中实现有点复杂，它毕竟还需要考虑中断，热插拔等因素。如果只考虑RCU部分，它的功能可以概括为：</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191154.png" alt="image-20211016173620773" style="zoom:80%;" />

<p>第一个函数用来遍历所有的CPU；第二行run_on()函数用来将当前线程切换到指定的CPU上。如果这个任务顺利完成，则说明所有的核已经经历过一次上下文切换，此刻必定读端已经结束，否则无法触发切换。</p>
<p>关于这里，我曾经有一个疑问：<strong>假如最初CPU1读端结束，执行了一次上下文切换；然后在等待其他CPU过程中，又再次进入RCU读临界区，如果此时释放，会导致严重后果吗？</strong> 有点类似于下图(黄色部分表示可以进行上下文切换)</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191157.png" alt="image-20211016174842445" style="zoom: 80%;" />

<p>不过后来想明白了。以替换一个节点为例进行说明：</p>
<ul>
<li><font color="#0000ff"><b>链表最初状态如下：</b></font></li>
</ul>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191202.png" alt="image-20211016175959004" style="zoom:80%;" />



<ul>
<li><p><font color="#0000ff"><b>插入一个元素时，先复制一个副本，再次基础上修改，然后完成发布</b></font></p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191203.png" alt="image-20211016180113839" style="zoom:80%;" />

<p>从此刻开始，rcu宽限期也开始。在发布之前的RCU读端访问的是2号节点(如果有的话)，发布之后，新来的RCU读端读取的是2_new新节点。这是RCU的一个重要特点，<strong>实时性很好</strong>。</p>
<p>这里还没有完，旧的2号节点还没有被释放。</p>
</li>
<li><p><font color="#0000ff"><b>更新操作（资源回收）</b></font></p>
</li>
</ul>
<p><font color="#ff0000"><b>那么什么时候释放呢？</b></font> <strong>当然是所有使用2号节点的读端都完成了再释放</strong>。</p>
<p><font color="#ff0000"><b>那么什么时候所有的读端完成呢？</b></font>就是刚才提到的，**<code>synchronize_rcu()</code>函数的任务**。此函数返回后我们就可以释放了（异步释放也差不多，只不过通过回调函数来完成此项操作）</p>
<p>再回到刚才的问题：<font color="#ff00f0"><b>如果CPU都已经完成了一次上下文切换，准备进行资源释放时(例如将上面的2节点释放)，其他CPU又重新进入临界区怎么办？  </b></font></p>
<p>答案是：<font color="#0000ff"><b>再次进入临界区的读端获取的是新的节点2_new, 原来的节点2已经不能再被新的读者访问到了。</b></font></p>
<blockquote>
<p>这种检查原理上简单了很多，<strong>但也导致了rcu宽限期比较长</strong>。毕竟这个上下文切换是个全局设置，得照顾到所有的CPU。</p>
</blockquote>
<h3 id="3-RCU-读端和写端同时操作，不会触发段错误吗？"><a href="#3-RCU-读端和写端同时操作，不会触发段错误吗？" class="headerlink" title="3.  RCU 读端和写端同时操作，不会触发段错误吗？"></a>3.  RCU 读端和写端同时操作，不会触发段错误吗？</h3><p>这个问题也是我当初百思不得其解的地方。</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191207.png" alt="image-20211016182131327" style="zoom:80%;" />

<p>场景：</p>
<ul>
<li>读端已经进入到1号节点</li>
<li>写端已经复制了2号节点2_new，完成了数据更新，并且将2_new的后继指针指向了3号节点</li>
<li>写端开始修改1号节点的后继指针，从2号节点切换到2_new节点；但是读端也正好在1号节点的后继节点，此时会出现后继节点为空导致<strong>链表遍历提前结束的情况</strong>吗？</li>
</ul>
<p>这个问题困扰了很久。不过当我再次读<a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a>时，发现了上面有这个问题的回答。最初看时竟然没有注意到这个问题。</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191212.png" alt="image-20211016182733118"></p>
<p>简单的说：<font color="#0000ff"><b>在Linux系统中，所有的加载和存储操都是原子的，不可能被分割。针对上述场景，读端要么读取到2节点，要么读取到2_new节点。不会出现第三结果。</b></font></p>
<h3 id="4-RCU-与资源回收"><a href="#4-RCU-与资源回收" class="headerlink" title="4.  RCU 与资源回收"></a>4.  RCU 与资源回收</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191216.png" alt="image-20211016183741869"></p>
<p>最初怎么也不会将这两个联系起来。但是慢慢发现有那么一丁点像</p>
<p><strong>RCU会等待资源不再被引用时释放对应的资源</strong>。从这么一点看还确实有点像GC的赶脚</p>
<p>不过他们最大的区别在于(从资源回收上看)：程序员必须手动指定RCU读端临界区资源，甚至手动指定释放的位置。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>同步互斥机制</tag>
      </tags>
  </entry>
</search>
