<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>💝openswan专栏目录💝</title>
    <url>/blogs/2021/11/20/openswan%E4%B8%93%E6%A0%8F%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><font color="#0000bb">为了方便查阅现有的文章，特准备一个目录页供后续查询使用</font></p>
<span id="more"></span>

<img src="https://img-blog.csdnimg.cn/20201122205357123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MyNjAzODk4MjYw,size_16,color_FFFFFF,t_70#pic_center"  />


<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105780700">专栏序言</a></li>
</ul>
<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105810406">openswan任务调度基础知识之信号</a><h3 id="2-openswan环境搭建"><a href="#2-openswan环境搭建" class="headerlink" title="2. openswan环境搭建"></a>2. openswan环境搭建</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112975141">openswan框架和编译时说明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105855454">openswan编译安装</a><h3 id="3-NAT穿越"><a href="#3-NAT穿越" class="headerlink" title="3. NAT穿越"></a>3. NAT穿越</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105214411">NAT-T下的端口浮动</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/105212626">NAT-T原理和环境搭建</a><h3 id="4-openswan函数笔记"><a href="#4-openswan函数笔记" class="headerlink" title="4. openswan函数笔记"></a>4. openswan函数笔记</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106172947">in_struct和out_struct讲解</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106131750">openswan发送状态分析</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107913541">pluto中监听各个网口的500端口处理逻辑</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="">pluto中CPU占有率高的接口与优化方案</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106578067">Openswan支持的算法及参数信息</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113447879">命令行解析函数：getopt_long、getopt</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113445039">ipsec.conf配置文件多个保护子网解析流程</a> </li>
</ul>
<h3 id="5-IKEv1协商流程"><a href="#5-IKEv1协商流程" class="headerlink" title="5. IKEv1协商流程"></a>5. IKEv1协商流程</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226299">openswan协商流程之（一）：main_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106226416">openswan协商流程之（二）：main_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106247599">openswan协商流程之（三）：main_inR1_outI2()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106271199">openswan协商流程之（四）：main_inI2_outR2()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106310714">openswan协商流程之（五）：main_inR2_outI3()</a> </li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106580396">openswan协商流程之（六）：main_inI3_outR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106592883">openswan协商流程之（七）：main_inR3()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108252077">openswan快速模式协商流程之（一）：quick_outI1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108459144">openswan快速模式协商流程之（二）：quick_inI1_outR1()</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/108560293">openswan快速模式协商流程之（三）：quick_inR1_outI2()</a></li>
</ul>
<hr>
<h3 id="6-IKEv2协议相关"><a href="#6-IKEv2协议相关" class="headerlink" title="6. IKEv2协议相关"></a>6. IKEv2协议相关</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/106915035">IKEv2协议简介</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/107117675">IKEv2协议关键知识点总结整理</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109019539">IKEv2协议协商流程: （IKE-SA-INIT 交换）第一包</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109062848">IKEv2协议协商流程: （IKE-SA-INIT 交换）第二包</a></li>
</ul>
<h3 id="7-加密流程"><a href="#7-加密流程" class="headerlink" title="7. 加密流程"></a>7. 加密流程</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109929113">ipsec 加密流程（一）：ipsec策略匹配</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/109943878">ipsec 加密流程（二）：ipsec初始化操作</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110018251">ipsec 加密流程（三）：ESP加密、AH认证处理流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/110410067">ipsec 加密流程（四）：封装状态机和发送流程</a></li>
</ul>
<h3 id="8-💖openswan进阶💖"><a href="#8-💖openswan进阶💖" class="headerlink" title="8. 💖openswan进阶💖"></a>8. 💖openswan进阶💖</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113043610">ubantu与CentOS虚拟机之间搭建GRE隧道</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113008094">🔥openswan一条隧道多保护子网配置</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://mp.csdn.net/mp_blog/creation/editor/113075156">🔥为何GRE可以封装组播报文而IPSEC却不行？</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/120593578">🔥SSL/TLS 与 IPSec 对比</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/113575857">🔥IKE 多预共享密钥问题 解决方案</a><h3 id="9-图解密码学技术"><a href="#9-图解密码学技术" class="headerlink" title="9. 图解密码学技术"></a>9. 图解密码学技术</h3></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112341844">DH算法图解+数学证明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112503905">openswan中DH算法说明</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/s2603898260/article/details/112744384">图解密码学(一)</a></li>
</ul>
<h3 id="10-Linux内核IPSEC实现"><a href="#10-Linux内核IPSEC实现" class="headerlink" title="10. Linux内核IPSEC实现"></a>10. Linux内核IPSEC实现</h3>]]></content>
      <categories>
        <category>IPSecVPN</category>
        <category>openswan</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>openswan</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>👉👉RCU锁原理深度思考</title>
    <url>/blogs/2021/11/20/RCU%E9%94%81%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="RCU经典文献"><a href="#RCU经典文献" class="headerlink" title="RCU经典文献"></a>RCU经典文献</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Articles/264090/">RCU part 3: the RCU API</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://lwn.net/Kernel/Index/">linux kernel</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://www.rdrop.com/users/paulmck/RCU/">RCU作者的主页介绍</a></li>
</ul>
<span id="more"></span>

<p>这几个连接简直就是一个宝藏，里面的干活很多很多！！！有时间一定要多看看。下文中的内容是看第一个和第二个链接的笔记和整理。直接观看原文，效果更佳。</p>
<p><img src="https://static.lwn.net/images/logo/barepenguin-70.png" alt="LWN.net Logo"></p>
<h2 id="RCU锁特点介绍"><a href="#RCU锁特点介绍" class="headerlink" title="RCU锁特点介绍"></a>RCU锁特点介绍</h2><p>Read-copy_update(简称RCU)技术是一种数据同步机制。常见的数据同步机制有：互斥锁，自旋锁，读写锁，顺序锁，信号量等手段。而RCU锁是一种比较高效的并发编程技术，它与2002年10月被添加到Linux内核中，在很多场景中它是用来替代读写锁的。</p>
<p>RCU锁的特点有：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>允许读写同时进行</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>任意读；写操作时先拷贝一个副本，在副本上进行修改、发布，并在合适时间释放原来的旧数据</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>读端不存在睡眠、阻塞、轮询，不会形成死锁，相比读写锁效率更高。</strong></li>
</ul>
<p>RCU也有自己的缺点：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>低优先级的读操作可阻塞高优先级的写操作</strong></li>
<li><input checked="" disabled="" type="checkbox"> <strong>宽限期可能比较长</strong></li>
</ul>
<p>这是由于RCU 写操作完毕后，会等待读端的完毕，等所有的读操作完毕后，宽限期结束，此时写端才会将资源释放。这里没有区分优先级，因此低优先级的读操作可能会影响到高优先级的写操作。</p>
<p>其实，RCU技术的特点还不仅如此，而有一个更重要的特点：<strong>多核扩展性</strong>。RCU虽然我们将其称之为RCU锁，但它并没有采用锁技术，而读写锁则是一个真正的锁，在扩展性上很差，设备CPU核越多，锁的竞争会越激烈，效率会越低。因此在现在很多的实现中，越来越注重<strong>无锁技术</strong>的实现。 下图是在文章<a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>中的一张RCU和rwlock在多核扩展性上对比图片：</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191148.jpg" alt="Graph showing RCU read-side primitives running multiple orders of magnitude faster than those of rwlock."></p>
<h2 id="RCU中常见问题"><a href="#RCU中常见问题" class="headerlink" title="RCU中常见问题"></a>RCU中常见问题</h2><h3 id="1-有没有使用引用计数"><a href="#1-有没有使用引用计数" class="headerlink" title="1. 有没有使用引用计数"></a>1. 有没有使用引用计数</h3><p>关于RCU实现原理还有一个误解：<strong>RCU采用了引用计数的方式确定是否存在读者。</strong> 这个观点也是错的。首先RCU并没有采用引用计数的机制，而是采用了一种非常简单的技术来实现；其次如果非要深究到底有没有引用计数，按照<a href="https://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a>中的说法是“RCU is a Restricted Reference-Counting Mechanism”，但<strong>本质上是没有采用引用计数的机制</strong>。它的解释如下：</p>
<p>“rcu_read_lock() 语句可以被认为是获取对 p 的引用，相当于一个引用计数。因为在 rcu_dereference() 分配给 p 之后开始的宽限期不可能在我们到达匹配的 rcu_read_unlock() 之前结束。 这种引用计数方案受到限制，因为我们不允许在 RCU 读端临界区中阻塞，也不允许我们将 RCU 读端临界区从一个任务切换到另一个任务“。 <strong>虽然有点像引用计数，但绝对不是</strong>。</p>
 <img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191142.png" alt="image-20211016165636411" style="zoom:80%;" />

<p>至于它怎么实现：检测是否有人在引用当前变量呢？ 我在下面介绍下 </p>
<h3 id="2-RCU既然没有使用引用计数，那又是确定是否存在读者引用之？"><a href="#2-RCU既然没有使用引用计数，那又是确定是否存在读者引用之？" class="headerlink" title="2. RCU既然没有使用引用计数，那又是确定是否存在读者引用之？"></a>2. RCU既然没有使用引用计数，那又是确定是否存在读者引用之？</h3><p>RCU 读锁加锁和去锁最基本的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_lock()		preempt_disable()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_unlock()	preempt_enable()</span></span><br></pre></td></tr></table></figure>

<p>加锁实际上是禁止上下文切换；而解锁是允许上下文切换。<strong>它们是一个全局设置，不与任何一项锁绑定</strong>。这也是为啥RCU读锁不需要任何参数的原因。</p>
<p><strong>基于此，便可以通过让CPU进行一次上下文切换来实现检测读端是否完成，而不必跟踪每一个引用的进程。</strong> 这是一个RCU非常重要的特点.</p>
<p>进行这个操作是：<code>synchronize_rcu()</code>, 这个函数在内核中实现有点复杂，它毕竟还需要考虑中断，热插拔等因素。如果只考虑RCU部分，它的功能可以概括为：</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191154.png" alt="image-20211016173620773" style="zoom:80%;" />

<p>第一个函数用来遍历所有的CPU；第二行run_on()函数用来将当前线程切换到指定的CPU上。如果这个任务顺利完成，则说明所有的核已经经历过一次上下文切换，此刻必定读端已经结束，否则无法触发切换。</p>
<p>关于这里，我曾经有一个疑问：<strong>假如最初CPU1读端结束，执行了一次上下文切换；然后在等待其他CPU过程中，又再次进入RCU读临界区，如果此时释放，会导致严重后果吗？</strong> 有点类似于下图(黄色部分表示可以进行上下文切换)</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191157.png" alt="image-20211016174842445" style="zoom: 80%;" />

<p>不过后来想明白了。以替换一个节点为例进行说明：</p>
<ul>
<li><font color="#0000ff"><b>链表最初状态如下：</b></font></li>
</ul>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191202.png" alt="image-20211016175959004" style="zoom:80%;" />



<ul>
<li><p><font color="#0000ff"><b>插入一个元素时，先复制一个副本，再次基础上修改，然后完成发布</b></font></p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191203.png" alt="image-20211016180113839" style="zoom:80%;" />

<p>从此刻开始，rcu宽限期也开始。在发布之前的RCU读端访问的是2号节点(如果有的话)，发布之后，新来的RCU读端读取的是2_new新节点。这是RCU的一个重要特点，<strong>实时性很好</strong>。</p>
<p>这里还没有完，旧的2号节点还没有被释放。</p>
</li>
<li><p><font color="#0000ff"><b>更新操作（资源回收）</b></font></p>
</li>
</ul>
<p><font color="#ff0000"><b>那么什么时候释放呢？</b></font> <strong>当然是所有使用2号节点的读端都完成了再释放</strong>。</p>
<p><font color="#ff0000"><b>那么什么时候所有的读端完成呢？</b></font>就是刚才提到的，**<code>synchronize_rcu()</code>函数的任务**。此函数返回后我们就可以释放了（异步释放也差不多，只不过通过回调函数来完成此项操作）</p>
<p>再回到刚才的问题：<font color="#ff00f0"><b>如果CPU都已经完成了一次上下文切换，准备进行资源释放时(例如将上面的2节点释放)，其他CPU又重新进入临界区怎么办？  </b></font></p>
<p>答案是：<font color="#0000ff"><b>再次进入临界区的读端获取的是新的节点2_new, 原来的节点2已经不能再被新的读者访问到了。</b></font></p>
<blockquote>
<p>这种检查原理上简单了很多，<strong>但也导致了rcu宽限期比较长</strong>。毕竟这个上下文切换是个全局设置，得照顾到所有的CPU。</p>
</blockquote>
<h3 id="3-RCU-读端和写端同时操作，不会触发段错误吗？"><a href="#3-RCU-读端和写端同时操作，不会触发段错误吗？" class="headerlink" title="3.  RCU 读端和写端同时操作，不会触发段错误吗？"></a>3.  RCU 读端和写端同时操作，不会触发段错误吗？</h3><p>这个问题也是我当初百思不得其解的地方。</p>
<img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191207.png" alt="image-20211016182131327" style="zoom:80%;" />

<p>场景：</p>
<ul>
<li>读端已经进入到1号节点</li>
<li>写端已经复制了2号节点2_new，完成了数据更新，并且将2_new的后继指针指向了3号节点</li>
<li>写端开始修改1号节点的后继指针，从2号节点切换到2_new节点；但是读端也正好在1号节点的后继节点，此时会出现后继节点为空导致<strong>链表遍历提前结束的情况</strong>吗？</li>
</ul>
<p>这个问题困扰了很久。不过当我再次读<a href="https://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a>时，发现了上面有这个问题的回答。最初看时竟然没有注意到这个问题。</p>
<p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191212.png" alt="image-20211016182733118"></p>
<p>简单的说：<font color="#0000ff"><b>在Linux系统中，所有的加载和存储操都是原子的，不可能被分割。针对上述场景，读端要么读取到2节点，要么读取到2_new节点。不会出现第三结果。</b></font></p>
<h3 id="4-RCU-与资源回收"><a href="#4-RCU-与资源回收" class="headerlink" title="4.  RCU 与资源回收"></a>4.  RCU 与资源回收</h3><p><img src="https://raw.githubusercontent.com/Top-Fish/PhotoRepository/main/img/SSL-TLS/20211120191216.png" alt="image-20211016183741869"></p>
<p>最初怎么也不会将这两个联系起来。但是慢慢发现有那么一丁点像</p>
<p><strong>RCU会等待资源不再被引用时释放对应的资源</strong>。从这么一点看还确实有点像GC的赶脚</p>
<p>不过他们最大的区别在于(从资源回收上看)：程序员必须手动指定RCU读端临界区资源，甚至手动指定释放的位置。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>同步互斥机制</tag>
      </tags>
  </entry>
</search>
